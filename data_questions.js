// Ngân hàng câu hỏi đầy đủ
// Type: "radio" (trắc nghiệm), "text" (điền từ), "code" (đọc code)
const QUESTION_BANK = [
  // --- CHỦ ĐỀ: OOP FUNDAMENTALS & KHÁI NIỆM CƠ BẢN ---
  {
    id: 1,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "OOP là mô hình lập trình tổ chức mã bằng cách mô hình hóa các thực thể hoặc khái niệm trong thế giới thực thành các...",
    options: ["Classes", "Objects", "Methods", "Variables"],
    answer: 1, // Objects
    explanation:
      "OOP là mô hình lập trình tổ chức mã bằng cách mô hình hóa các thực thể hoặc khái niệm trong thế giới thực thành các đối tượng (objects) [1].",
  },
  {
    id: 2,
    topic: "OOP Fundamentals",
    type: "text",
    question:
      "Trong Java, một đối tượng (object) là một thể hiện (instance) được tạo ra từ một 'khuôn mẫu' gọi là gì?",
    answer: "class",
    explanation:
      "Class có thể được xem là bản thiết kế (blueprint) định nghĩa đối tượng nên trông như thế nào, và đối tượng là thực thể thực tế được tạo ra từ class đó [2].",
  },
  {
    id: 3,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Tính chất nào của OOP cho phép một đối tượng duy nhất (single entity) có khả năng mang nhiều hình thức (multiple forms)?",
    options: ["Inheritance", "Encapsulation", "Polymorphism", "Abstraction"],
    answer: 2, // Polymorphism
    explanation:
      "Polymorphism (Đa hình) đề cập đến khả năng của một thực thể duy nhất (một đối tượng) có thể mang nhiều hình thức [3].",
  },
  {
    id: 4,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Tính chất Đóng gói (Encapsulation) được mô tả tốt nhất là gì?",
    options: [
      "Khả năng mở rộng class mà không cần thay đổi mã nguồn.",
      "Ẩn giấu các chi tiết phức tạp và chỉ hiển thị chức năng cần thiết.",
      "Gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng).",
      "Cho phép các lớp con kế thừa thuộc tính của lớp cha.",
    ],
    answer: 2, // Gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng).
    explanation:
      "Đóng gói (Encapsulation) là việc gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng), giúp thuận tiện cho việc tái sử dụng [4].",
  },
  {
    id: 5,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Khái niệm Trừu tượng (Abstraction) trong OOP có cơ chế chính là gì?",
    options: [
      "Che giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết.",
      "Đảm bảo chỉ có một thể hiện của class tồn tại.",
      "Cho phép truy cập trực tiếp vào tất cả các trường dữ liệu.",
      "Định nghĩa các thuật toán độc lập với kiểu dữ liệu.",
    ],
    answer: 0, // Che giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết.
    explanation:
      "Trừu tượng (Abstraction) là cơ chế ẩn giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết cho người dùng [5].",
  },
  {
    id: 6,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Trong OOP, các hành động mà đối tượng có khả năng thực hiện được gọi là gì trong Java?",
    options: ["Fields", "Attributes", "Methods", "Variables"],
    answer: 2, // Methods
    explanation:
      "Các hành động (actions) của đối tượng trong Java được gọi là methods (phương thức) [6].",
  },
  {
    id: 7,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Nếu một đối tượng chỉ có các trường dữ liệu (fields) mà không bao gồm bất kỳ phương thức nào, mục đích chính của nó là gì?",
    options: [
      "Thực hiện các hành động phức tạp.",
      "Tổ chức lưu trữ dữ liệu.",
      "Đảm bảo tính đa hình.",
      "Gọi các phương thức tĩnh.",
    ],
    answer: 1, // Tổ chức lưu trữ dữ liệu.
    explanation:
      "Một số đối tượng có thể chỉ có các trường dữ liệu, đóng vai trò là cách để tổ chức lưu trữ dữ liệu nhưng không bao gồm bất kỳ phương thức nào [7].",
  },
  {
    id: 8,
    topic: "OOP Fundamentals",
    type: "text",
    question:
      "Trong ngữ cảnh Kế thừa (Inheritance), lớp mà được các lớp khác mở rộng được gọi là lớp cơ sở (Base class) hoặc lớp gì?",
    answer: "Super class",
    explanation:
      "Lớp cơ sở (Base class) còn được gọi là lớp cha (Super class) hoặc lớp chung (general class) [5].",
  },
  {
    id: 9,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Đâu là lợi ích của việc sử dụng các đối tượng (objects) trong mã nguồn?",
    options: [
      "Mã trở nên khó hiểu hơn.",
      "Mã trở nên có tổ chức và dễ hiểu hơn.",
      "Việc bảo trì mã trở nên phức tạp hơn.",
      "Java có thể hoạt động mà không cần đối tượng.",
    ],
    answer: 1, // Mã trở nên có tổ chức và dễ hiểu hơn.
    explanation:
      "Các đối tượng kết hợp các biến lại với nhau để làm cho mã có ý nghĩa hơn, mã trở nên có tổ chức và dễ hiểu hơn, giúp bảo trì đơn giản hơn [8].",
  },
  {
    id: 10,
    topic: "OOP Fundamentals",
    type: "text",
    question:
      "Để truy cập một trường (field) hoặc gọi một phương thức (method) trong một đối tượng Java, người ta sử dụng toán tử nào?",
    answer: ".",
    explanation:
      "Việc truy cập một trường hoặc gọi một phương thức trong một đối tượng được thực hiện bằng cách sử dụng toán tử dấu chấm “.” [9].",
  },
  {
    id: 11,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Một lớp Java (Java class) phải được tạo trong tệp nào?",
    options: [
      "Nó có thể được tạo ở bất cứ đâu trong dự án.",
      "Nó phải được tạo trong tệp riêng của nó.",
      "Nó phải nằm trong tệp .exe.",
      "Tùy thuộc vào IDE.",
    ],
    answer: 1, // Nó phải được tạo trong tệp riêng của nó.
    explanation:
      "Trong Java, mỗi class nên được tạo trong tệp riêng của nó [10].",
  },
  {
    id: 12,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Theo quy ước đặt tên (Naming convention) trong Java, một Class nên được đặt tên theo quy ước nào?",
    options: [
      "camelCase (bắt đầu bằng chữ thường)",
      "PascalCase (bắt đầu bằng chữ hoa)",
      "snake_case",
      "SCREAMING_SNAKE_CASE",
    ],
    answer: 1, // PascalCase (thường được gọi là CamelCase bắt đầu bằng chữ hoa trong nguồn)
    explanation:
      "Quy ước đặt tên cho Class là CamelCase (bắt đầu bằng chữ hoa) [11].",
  },
  {
    id: 13,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Trong Java, String có phải là kiểu dữ liệu nguyên thủy (primitive type) không?",
    options: [
      "Có, String là kiểu nguyên thủy.",
      "Không, String là một class.",
      "Chỉ khi khai báo bằng literal.",
      "Chỉ khi sử dụng từ khóa new.",
    ],
    answer: 1, // Không, String là một class.
    explanation:
      "String không phải là một kiểu nguyên thủy, mà là một class [11].",
  },
  {
    id: 14,
    topic: "OOP Fundamentals",
    type: "text",
    question:
      "Phương thức nào là điểm khởi đầu (starting point) cho bất kỳ chương trình Java nào?",
    answer: "main()",
    explanation:
      "Điểm khởi đầu cho bất kỳ chương trình Java nào là phương thức main() [12, 13].",
  },
  {
    id: 15,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Từ khóa 'static' trong phương thức main() có ý nghĩa gì?",
    options: [
      "Nó cần một đối tượng để chạy.",
      "Nó không cần một đối tượng để chạy.",
      "Nó bắt buộc phải trả về một giá trị.",
      "Nó chỉ có thể được gọi từ bên trong class.",
    ],
    answer: 1, // Nó không cần một đối tượng để chạy.
    explanation:
      "Từ khóa 'static' trong main() có nghĩa là phương thức này không cần một đối tượng để chạy, đó là lý do tại sao máy tính bắt đầu với phương thức này trước khi tạo bất kỳ đối tượng nào [12].",
  },

  // --- CHỦ ĐỀ: JAVA CORE: CONSTRUCTORS & ACCESS MODIFIERS ---
  {
    id: 16,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích chính của Constructor trong Java là gì?",
    options: [
      "Thực hiện các hành động phức tạp",
      "Trả về một giá trị",
      "Tạo và khởi tạo một đối tượng của class đó",
      "Gắn thẻ class là 'final'",
    ],
    answer: 2, // Tạo và khởi tạo một đối tượng của class đó
    explanation:
      "Constructors là các phương thức đặc biệt chịu trách nhiệm tạo và khởi tạo một đối tượng của class đó [14].",
  },
  {
    id: 17,
    topic: "Java Core",
    type: "text",
    question:
      "Điều gì xảy ra nếu một class có constructor có tham số (parameterized constructor) nhưng không có constructor mặc định (default constructor)?",
    answer: "Lỗi biên dịch nếu gọi constructor mặc định.",
    explanation:
      "Nếu một class chỉ có constructor có tham số, việc gọi constructor mặc định (ví dụ: Game g1 = new Game();) sẽ gây ra lỗi biên dịch [15].",
  },
  {
    id: 18,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi nào thì một constructor mặc định (default constructor) được tự động tạo bởi Java?",
    options: [
      "Luôn luôn.",
      "Khi class không có bất kỳ constructor nào khác được định nghĩa.",
      "Khi class được khai báo là 'abstract'.",
      "Không bao giờ.",
    ],
    answer: 1, // Khi class không có bất kỳ constructor nào khác được định nghĩa.
    explanation:
      "Constructor mặc định là tùy chọn. Nếu bạn không tạo một constructor mặc định, Java sẽ tự động giả định có một constructor mặc định không làm gì cả (empty constructor) [16].",
  },
  {
    id: 19,
    topic: "Java Core",
    type: "text",
    question:
      "Từ khóa nào được sử dụng để đề cập đến đối tượng hiện tại (current object) bên trong một phương thức hoặc constructor?",
    answer: "this",
    explanation:
      "Từ khóa 'this' là một biến tham chiếu đề cập đến đối tượng hiện tại [17].",
  },
  {
    id: 20,
    topic: "Java Core",
    type: "code",
    question:
      "Đoạn mã sau in ra gì? (Trong bối cảnh class Main có phương thức change(Test t) không có 'new Test()')",
    code: `
class Test { int x; Test(int i) { x = i; } }
class Main {
    public static void change(Test t) {
        t.x = 10;
    }
    public static void main(String[] args) {
        Test t = new Test(5);
        change(t);
        System.out.println(t.x);
    }
}`,
    options: ["5", "10", "Lỗi biên dịch", "null"],
    answer: 1, // 10
    explanation:
      "Khi truyền đối tượng/tham chiếu, Java tạo một bản sao của tham chiếu và truyền cho phương thức. Nhưng cả hai vẫn trỏ đến cùng một đối tượng trong bộ nhớ (Heap). Việc thay đổi t.x bên trong change() ảnh hưởng đến đối tượng gốc [18].",
  },
  {
    id: 21,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc khai báo các trường (fields) là 'private' và cung cấp các phương thức 'public getter/setter' là gì?",
    options: [
      "Giảm chi phí bộ nhớ.",
      "Giảm thiểu sự phức tạp của mã.",
      "Thực hiện Encapsulation (Đóng gói) và kiểm soát việc thay đổi dữ liệu.",
      "Đảm bảo tính đa hình.",
    ],
    answer: 2, // Thực hiện Encapsulation (Đóng gói) và kiểm soát việc thay đổi dữ liệu.
    explanation:
      "Khai báo tất cả các trường là private và tạo các phương thức getter/setter công khai là một thực hành tốt để kiểm soát khi nào và bằng cách nào một trường được thay đổi, hỗ trợ Đóng gói [19, 20].",
  },
  {
    id: 22,
    topic: "Java Core",
    type: "radio",
    question:
      "Một phương thức được khai báo là 'private' thường được gọi là gì?",
    options: [
      "Utility method",
      "Helper method",
      "Public API",
      "Callback function",
    ],
    answer: 1, // Helper method
    explanation:
      "Các phương thức private thường được gọi là helper methods (phương thức trợ giúp) vì chúng chỉ có thể được nhìn thấy và gọi bởi cùng một class, được sử dụng để tổ chức và giữ cho mã đơn giản hơn [21].",
  },
  {
    id: 23,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu không có access modifier (như public, private, protected) nào được chỉ định cho một class/method/variable, access modifier mặc định là gì?",
    options: ["public", "protected", "default (package-private)", "private"],
    answer: 2, // default (package-private)
    explanation:
      "Nếu không chỉ định một access modifier, class/method/variable sẽ có thể truy cập được bởi tất cả các class khác trong cùng một package [22].",
  },
  {
    id: 24,
    topic: "Java Core",
    type: "text",
    question:
      "Access modifier nào cho phép truy cập thành viên từ cùng một package HOẶC từ các lớp con (subclasses) trong các package khác?",
    answer: "protected",
    explanation:
      "Các phương thức và thành viên dữ liệu được khai báo là protected có thể truy cập được trong cùng một package hoặc trong các lớp con của các package khác [23].",
  },
  {
    id: 25,
    topic: "Java Core",
    type: "radio",
    question: "Từ khóa 'this()' trong một constructor được sử dụng để làm gì?",
    options: [
      "Gọi constructor của lớp cha",
      "Gọi constructor khác của chính class hiện tại",
      "Trả về thể hiện của class hiện tại",
      "Truy cập biến instance của lớp cha",
    ],
    answer: 1, // Gọi constructor khác của chính class hiện tại
    explanation:
      "Sử dụng this() để gọi constructor của chính class hiện tại (current class constructor) [24].",
  },

  // --- CHỦ ĐỀ: JAVA CORE: STATIC & FINAL ---
  {
    id: 26,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra khi một trường (field) được khai báo là 'static'?",
    options: [
      "Giá trị của nó được lưu trữ trong đối tượng (object) và có thể thay đổi.",
      "Giá trị của nó được lưu trữ trong class và chia sẻ bởi tất cả các đối tượng của class đó.",
      "Nó trở thành một hằng số và không thể thay đổi.",
      "Nó được phân bổ trên Stack memory.",
    ],
    answer: 1, // Giá trị của nó được lưu trữ trong class và chia sẻ bởi tất cả các đối tượng của class đó.
    explanation:
      "Khai báo một trường là static có nghĩa là giá trị của nó không còn nằm trong đối tượng nữa mà nằm trong class, và tất cả các đối tượng của class sẽ chia sẻ cùng một giá trị chính xác đó [25].",
  },
  {
    id: 27,
    topic: "Java Core",
    type: "text",
    question: "Một phương thức 'static' thường được sử dụng khi nào?",
    answer:
      "Khi phương thức không cần truy cập bất kỳ trường nào trong đối tượng.",
    explanation:
      "Phương thức static lý tưởng được sử dụng để tạo một phương thức không cần truy cập bất kỳ trường nào trong đối tượng (i.e., một hàm độc lập) [26].",
  },
  {
    id: 28,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức 'static' có thể truy cập các trường (fields) 'non-static' không?",
    options: [
      "Có, luôn luôn.",
      "Không, vì các trường non-static phụ thuộc vào sự tồn tại của một thể hiện (instance) của class.",
      "Chỉ khi được định nghĩa là public.",
      "Chỉ thông qua từ khóa 'this'.",
    ],
    answer: 1, // Không, vì các trường non-static phụ thuộc vào sự tồn tại của một thể hiện (instance) của class.
    explanation:
      "Không thể truy cập một biến non-static trong ngữ cảnh static, vì các biến non-static phụ thuộc vào sự tồn tại của một thể hiện của class [27].",
  },
  {
    id: 29,
    topic: "Java Core",
    type: "radio",
    question: "Một trường (field) được mô tả bằng từ khóa 'final' là gì?",
    options: [
      "Một biến có thể thay đổi",
      "Một biến chỉ có thể được thiết lập một lần",
      "Một biến chỉ có thể được truy cập trong class",
      "Một biến được chia sẻ bởi tất cả các đối tượng",
    ],
    answer: 1, // Một biến chỉ có thể được thiết lập một lần
    explanation:
      "Một trường final đơn giản là một hằng số (constant variable), tức là một biến chỉ được thiết lập một lần và không được phép thay đổi lại theo thời gian [28, 29].",
  },
  {
    id: 30,
    topic: "Java Core",
    type: "radio",
    question: "Một class được khai báo là 'final' sẽ bị hạn chế điều gì?",
    options: [
      "Không thể tạo đối tượng từ class đó.",
      "Các phương thức của nó không thể được gọi.",
      "Nó không thể được kế thừa (inherited).",
      "Các trường của nó phải là 'static'.",
    ],
    answer: 2, // Nó không thể được kế thừa (inherited).
    explanation: "Final class (class cuối cùng): không thể được kế thừa [27].",
  },
  {
    id: 31,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì xảy ra nếu một phương thức được đánh dấu là 'final'?",
    options: [
      "Nó phải được khai báo là static.",
      "Nó không thể bị ghi đè (overridden) trong lớp con.",
      "Nó phải trả về kiểu void.",
      "Nó chỉ có thể được gọi từ bên trong class.",
    ],
    answer: 1, // Nó không thể bị ghi đè (overridden) trong lớp con.
    explanation:
      "Nếu bạn muốn bảo vệ phương thức của mình khỏi bị ghi đè trong lớp con, bạn có thể thêm tiền tố từ khóa 'final'. Phương thức final không thể bị ghi đè [27, 30].",
  },
  {
    id: 32,
    topic: "Java Core",
    type: "text",
    question:
      "Trong bộ nhớ Java, các đối tượng (objects) được phân bổ động (dynamically allocated) ở khu vực nào?",
    answer: "Heap",
    explanation:
      "Trong Java, tất cả các đối tượng được phân bổ động trên Heap [31]. Các biến cục bộ (Local variables) được lưu trữ trên Stack memory [31].",
  },
  {
    id: 33,
    topic: "Java Core",
    type: "radio",
    question: "Sự khác biệt chính giữa Java reference và C++ pointer là gì?",
    options: [
      "Java reference có thể lưu trữ địa chỉ bộ nhớ, pointer thì không.",
      "Pointer là một biến lưu trữ địa chỉ bộ nhớ, Java reference không phải là pointer.",
      "Java không sử dụng reference.",
      "Không có sự khác biệt.",
    ],
    answer: 1, // Pointer là một biến lưu trữ địa chỉ bộ nhớ, Java reference không phải là pointer.
    explanation:
      "Java không có con trỏ (pointers), Java có tham chiếu (references). Con trỏ là một biến lưu trữ địa chỉ bộ nhớ (tức là con trỏ là tham chiếu, nhưng tham chiếu không phải là con trỏ) [31, 32].",
  },
  {
    id: 34,
    topic: "Java Core",
    type: "text",
    question:
      "Trong ngữ cảnh kế thừa, từ khóa nào được sử dụng để gọi phương thức của lớp cha (parent method) từ lớp con (child class)?",
    answer: "super",
    explanation:
      "Để tái sử dụng phương thức của lớp cha trong lớp con, ta sử dụng từ khóa 'super', theo sau là dấu chấm và tên phương thức [33].",
  },
  {
    id: 35,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một constructor của lớp con (child’s constructor) không gọi constructor của lớp cha một cách rõ ràng (explicitly) bằng 'super()', điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Trình biên dịch Java tự động chèn một lệnh gọi đến constructor mặc định của lớp cha.",
      "Lớp cha sẽ không được khởi tạo.",
      "Lớp con tự động kế thừa tất cả các trường private của lớp cha.",
    ],
    answer: 1, // Trình biên dịch Java tự động chèn một lệnh gọi đến constructor mặc định của lớp cha.
    explanation:
      "Nếu constructor của lớp con không gọi rõ ràng constructor của lớp cha bằng 'super', trình biên dịch Java tự động chèn một lệnh gọi đến constructor mặc định của lớp cha [34].",
  },

  // --- CHỦ ĐỀ: INHERITANCE & POLYMORPHISM ---
  {
    id: 36,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều kiện nào sau đây là giới hạn lớn trong tính năng kế thừa của Java?",
    options: [
      "Class không thể kế thừa nhiều hơn hai class.",
      "Class chỉ có thể kế thừa các class trừu tượng.",
      "Class không thể kế thừa nhiều hơn một class.",
      "Không có giới hạn nào.",
    ],
    answer: 2, // Class không thể kế thừa nhiều hơn một class.
    explanation:
      "Một hạn chế lớn trong Java là một class không thể mở rộng nhiều hơn một class (multiple inheritance is not allowed in Java) [35].",
  },
  {
    id: 37,
    topic: "Inheritance",
    type: "text",
    question:
      "Trong ví dụ về cờ vua, việc lớp Queen có thể di chuyển theo cách của Rook (đường thẳng) và Bishop (đường chéo) là một ví dụ cho tính chất nào của OOP?",
    answer: "Polymorphism",
    explanation:
      "Việc một lớp con (như Queen) có thể được xử lý dựa trên nhiều hình thức hành vi (như Rook và Bishop trong ví dụ cờ vua mô tả tính đa hình).",
  },
  {
    id: 38,
    topic: "Inheritance",
    type: "radio",
    question: "Upcasting (Ép kiểu lên) là quá trình nào?",
    options: [
      "Ép kiểu một đối tượng lớp cha thành lớp con, cần làm thủ công.",
      "Ép kiểu một đối tượng lớp con thành kiểu lớp cha hoặc bất kỳ lớp siêu lớp nào, được thực hiện tự động.",
      "Chuyển đổi từ kiểu dữ liệu nguyên thủy sang đối tượng Wrapper.",
      "Chuyển đổi từ kiểu Double sang kiểu Integer.",
    ],
    answer: 1, // Ép kiểu một đối tượng lớp con thành kiểu lớp cha hoặc bất kỳ lớp siêu lớp nào, được thực hiện tự động.
    explanation:
      "Upcasting là khi một đối tượng của lớp con được đối xử như một đối tượng của bất kỳ lớp siêu lớp nào. Upcasting được thực hiện tự động [36, 37].",
  },
  {
    id: 39,
    topic: "Inheritance",
    type: "radio",
    question:
      "Downcasting (Ép kiểu xuống) cần phải được thực hiện như thế nào?",
    options: [
      "Tự động",
      "Thủ công",
      "Chỉ được phép với các kiểu nguyên thủy",
      "Chỉ được phép trong các phương thức static",
    ],
    answer: 1, // Thủ công
    explanation: "Downcasting phải luôn được thực hiện thủ công [38].",
  },
  {
    id: 40,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu một class không phải là Cat, nhưng ta cố gắng downcast một đối tượng Mammal thành Cat (ví dụ: Mammal m = new Mammal(); Cat c = (Cat)m;), điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Nó chạy bình thường.",
      "Nó vượt qua quá trình biên dịch nhưng ném ra java.lang.ClassCastException khi chạy.",
      "Nó chỉ ném ra lỗi nếu class Cat là final.",
    ],
    answer: 2, // Nó vượt qua quá trình biên dịch nhưng ném ra java.lang.ClassCastException khi chạy.
    explanation:
      "Mã này vượt qua quá trình biên dịch, nhưng ném ra ngoại lệ ClassCastException khi chạy vì Mammal không phải là Cat [39].",
  },
  {
    id: 41,
    topic: "Inheritance",
    type: "text",
    question:
      "Toán tử nào được sử dụng để kiểm tra xem một đối tượng có phải là một thể hiện (instance) của một class nào đó (hoặc lớp con) không?",
    answer: "instanceof",
    explanation:
      "Toán tử instanceof được sử dụng để kiểm tra xem một đối tượng có phải là một thể hiện của một class nào đó (hoặc lớp con) không [38].",
  },
  {
    id: 42,
    topic: "Inheritance",
    type: "radio",
    question: "Việc Ghi đè phương thức (Method Overriding) có nghĩa là gì?",
    options: [
      "Định nghĩa lại một phương thức trong lớp con đã được định nghĩa trong lớp cha, với cùng một chữ ký phương thức.",
      "Định nghĩa nhiều phương thức có cùng tên nhưng khác tham số trong cùng một class.",
      "Tạo một phiên bản 'static' của phương thức đó.",
      "Gọi phương thức của lớp cha từ lớp con bằng từ khóa 'super'.",
    ],
    answer: 0, // Định nghĩa lại một phương thức trong lớp con đã được định nghĩa trong lớp cha, với cùng một chữ ký phương thức.
    explanation:
      "Ghi đè (Overriding) về cơ bản có nghĩa là khai báo lại phương thức đó trong lớp con và định nghĩa lại những gì chúng nên làm [40].",
  },
  {
    id: 43,
    topic: "Inheritance",
    type: "radio",
    question:
      "Phương thức nào (nếu tồn tại) được Garbage Collector gọi trên đối tượng MỘT LẦN trước khi thu thập rác?",
    options: ["gc()", "delete()", "finalize()", "dispose()"],
    answer: 2, // finalize()
    explanation:
      "Trước khi hủy một đối tượng, Garbage Collector gọi phương thức finalize() trên đối tượng đó để thực hiện các hoạt động dọn dẹp [41].",
  },
  {
    id: 44,
    topic: "Inheritance",
    type: "text",
    question:
      "Từ khóa 'throws' trong khai báo phương thức được sử dụng để làm gì?",
    answer: "Thông báo về ngoại lệ mà phương thức có thể ném ra (throw).",
    explanation:
      "Việc này đi kèm với việc thêm từ khóa 'throws' theo sau là kiểu ngoại lệ trong khai báo phương thức [42].",
  },
  {
    id: 45,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong thiết kế, nguyên tắc nào nói rằng các thực thể phần mềm nên mở để mở rộng nhưng đóng để sửa đổi?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 1, // OCP (Open/Closed Principle)
    explanation:
      "Open/Closed Principle (OCP): Các thực thể phần mềm (lớp, module, hàm) nên mở để mở rộng nhưng đóng để sửa đổi [43].",
  },

  // --- CHỦ ĐỀ: ABSTRACT CLASS & INTERFACE ---
  {
    id: 46,
    topic: "Abstract Class",
    type: "radio",
    question: "Điều gì đúng về Lớp Trừu tượng (Abstract Class) trong Java?",
    options: [
      "Nó phải chứa ít nhất một phương thức trừu tượng.",
      "Không thể tạo đối tượng (instance) từ lớp trừu tượng.",
      "Constructor của nó không thể được gọi.",
      "Nó không thể kế thừa bất kỳ class nào khác.",
    ],
    answer: 1, // Không thể tạo đối tượng (instance) từ lớp trừu tượng.
    explanation: "Không thể tạo đối tượng của một lớp trừu tượng [44].",
  },
  {
    id: 47,
    topic: "Interface",
    type: "radio",
    question: "Mục đích chính của Interface trong Java là gì?",
    options: [
      "Thực hiện đa kế thừa (Multiple Inheritance) bị Java cấm đối với các class.",
      "Cung cấp implementation cho các phương thức trừu tượng.",
      "Bắt buộc tất cả các trường phải là private.",
      "Tạo ra các hằng số toán học.",
    ],
    answer: 0, // Thực hiện đa kế thừa (Multiple Inheritance) bị Java cấm đối với các class.
    explanation:
      "Java giới thiệu các interface để giải quyết vấn đề đa kế thừa [45]. Interface được sử dụng để đạt được đa kế thừa [46].",
  },
  {
    id: 48,
    topic: "Interface",
    type: "text",
    question:
      "Tất cả các trường (fields) trong một interface đều ngầm định (implicitly) là public, static, và gì?",
    answer: "final",
    explanation:
      "Tất cả các trường trong một interface đều ngầm định là public, static, final [46].",
  },
  {
    id: 49,
    topic: "Interface",
    type: "radio",
    question: "Điều gì đúng về các phương thức trong Interface (trước JDK 8)?",
    options: [
      "Chúng phải là default hoặc static.",
      "Chúng ngầm định là public và abstract.",
      "Chúng phải có implementation (thân hàm).",
      "Chúng có thể là private hoặc protected.",
    ],
    answer: 1, // Chúng ngầm định là public và abstract.
    explanation:
      "Tất cả các phương thức trong một interface đều ngầm định là public và abstract, trừ khi chúng là default hoặc static [46].",
  },
  {
    id: 50,
    topic: "Interface",
    type: "text",
    question:
      "Interface phổ biến nào trong Java bao gồm một phương thức duy nhất là CompareTo(), được sử dụng để so sánh hai đối tượng của cùng một kiểu?",
    answer: "Comparable",
    explanation:
      "Comparable là một interface phổ biến trong Java, bao gồm một phương thức duy nhất là CompareTo() [47].",
  },

  // --- CHỦ ĐỀ: DATA STRUCTURES & JAVA CORE ---
  {
    id: 51,
    topic: "Data Structures",
    type: "radio",
    question: "Lớp Wrapper (Wrapper Class) có mục đích gì?",
    options: [
      "Cung cấp các phương thức tiện ích cho các đối tượng.",
      "Gói gọn kiểu dữ liệu nguyên thủy, mang lại cho nó vẻ ngoài của một đối tượng.",
      "Lưu trữ chuỗi ký tự không thể thay đổi.",
      "Định nghĩa các phương thức toán học tĩnh.",
    ],
    answer: 1, // Gói gọn kiểu dữ liệu nguyên thủy, mang lại cho nó vẻ ngoài của một đối tượng.
    explanation:
      "Lớp Wrapper gói gọn một kiểu dữ liệu, mang lại cho nó vẻ ngoài của một đối tượng [48].",
  },
  {
    id: 52,
    topic: "Data Structures",
    type: "text",
    question:
      "Phương thức nào trong các lớp Wrapper được sử dụng để trả về giá trị nguyên thủy (primitive value) của đối tượng Wrapper?",
    answer: "typeValue()",
    explanation:
      "Tất cả các lớp Wrapper đều có phương thức typeValue(). Phương thức này trả về giá trị của đối tượng dưới dạng kiểu nguyên thủy của nó [49].",
  },
  {
    id: 53,
    topic: "Data Structures",
    type: "radio",
    question:
      "Kiểu dữ liệu nào được sử dụng để đọc input từ command line khi dùng `System.in`?",
    options: ["PrintStream", "Character stream", "Byte stream", "Scanner"],
    answer: 2, // Byte stream
    explanation:
      "Các luồng chuẩn (Standard streams) là byte streams (chứ không phải character streams) [50].",
  },
  {
    id: 54,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì đúng về String trong Java?",
    options: [
      "String là một chuỗi ký tự có thể sửa đổi.",
      "String được tạo thành từ một mảng các kiểu dữ liệu byte.",
      "String là một chuỗi ký tự không thể sửa đổi (unmodifiable sequence of characters).",
      "String là một kiểu dữ liệu nguyên thủy.",
    ],
    answer: 2, // String là một chuỗi ký tự không thể sửa đổi (unmodifiable sequence of characters).
    explanation:
      "String: chuỗi ký tự không thể sửa đổi (unmodifiable sequence of characters) [51].",
  },
  {
    id: 55,
    topic: "Data Structures",
    type: "text",
    question:
      "Vùng bộ nhớ đặc biệt nào trong heap lưu trữ các String literal để giảm sử dụng bộ nhớ và cải thiện hiệu suất?",
    answer: "String Pool (hoặc String Intern Pool / String Constant Pool)",
    explanation:
      "String Pool là khu vực lưu trữ đặc biệt trong heap, lưu trữ các string literal, nhằm giảm sử dụng bộ nhớ và cải thiện hiệu suất [52].",
  },
  {
    id: 56,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn mã sau in ra gì? (Với str1 và str2 sử dụng String literal)",
    code: `
String str1 = "Java";
String str2 = "Java";
System.out.println(str1 == str2);`,
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0, // true
    explanation:
      "Vì cả hai đều là literal, chúng cùng trỏ đến cùng một thể hiện trong String Pool. '==' so sánh tham chiếu nên trả về true [52, 53].",
  },
  {
    id: 57,
    topic: "Data Structures",
    type: "text",
    question:
      "Class nào trong Java cung cấp các phương thức toán học tĩnh như random(), sin(), hoặc abs()?",
    answer: "Math",
    explanation: "Class Math có một loạt các phương thức tĩnh [54, 55].",
  },
  {
    id: 58,
    topic: "Data Structures",
    type: "radio",
    question: "StringBuffer là gì?",
    options: [
      "Chuỗi ký tự không thể sửa đổi.",
      "Một Collection được sử dụng để lưu trữ dữ liệu.",
      "Chuỗi ký tự có thể sửa đổi.",
      "Một interface.",
    ],
    answer: 2, // Chuỗi ký tự có thể sửa đổi.
    explanation:
      "StringBuffer: chuỗi ký tự có thể sửa đổi (modifiable sequence of characters) [56].",
  },
  {
    id: 59,
    topic: "Data Structures",
    type: "radio",
    question: "Hạn chế chính của việc sử dụng Mảng (Arrays) trong Java là gì?",
    options: [
      "Các mảng chỉ có thể lưu trữ kiểu dữ liệu nguyên thủy.",
      "Phải biết chính xác số lượng mục trước khi khởi tạo và không thể thêm/xóa phần tử sau khi khởi tạo.",
      "Không thể sử dụng vòng lặp để truy cập các phần tử.",
      "Các mảng không phải là đối tượng.",
    ],
    answer: 1, // Phải biết chính xác số lượng mục trước khi khởi tạo và không thể thêm/xóa phần tử sau khi khởi tạo.
    explanation:
      "Bạn cần biết chính xác số lượng mục bạn sẽ sử dụng khi khởi tạo mảng, và một khi đã khởi tạo mảng với kích thước cụ thể, bạn không được phép thêm hoặc xóa phần tử [57].",
  },
  {
    id: 60,
    topic: "Data Structures",
    type: "text",
    question:
      "Lớp nào là lớp phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ (internally)?",
    answer: "ArrayList",
    explanation:
      "ArrayList là class phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ [58].",
  },

  // --- CHỦ ĐỀ: COLLECTIONS & DATA STRUCTURES (NÂNG CAO) ---
  {
    id: 61,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cấu trúc dữ liệu Stack trong Java đại diện cho nguyên tắc nào?",
    options: [
      "First-In, First-Out (FIFO)",
      "Last-In, First-Out (LIFO)",
      "Random Access",
      "Ordered Sequence",
    ],
    answer: 1, // Last-In, First-Out (LIFO)
    explanation:
      "Collection Stack đại diện cho một stack đối tượng kiểu Last-in, first-out [59].",
  },
  {
    id: 62,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để thêm một mục vào đỉnh của Stack?",
    options: ["add()", "push()", "insert()", "enqueue()"],
    answer: 1, // push()
    explanation:
      "Phương thức push(e Item): thêm một mục vào đỉnh của stack [59].",
  },
  {
    id: 63,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cấu trúc dữ liệu Queue trong Java đại diện cho nguyên tắc nào?",
    options: [
      "Last-In, First-Out (LIFO)",
      "First-In, First-Out (FIFO)",
      "Random Access",
      "Unordered Collection",
    ],
    answer: 1, // First-In, First-Out (FIFO)
    explanation:
      "Khác với Stack, Queue là cấu trúc dữ liệu First-In, First-Out [60].",
  },
  {
    id: 64,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Giao diện (Interface) đặc biệt nào của Queue cho phép bạn thêm hoặc xóa các phần tử từ cả hai đầu (trước hoặc sau)?",
    answer: "Deque (Double-Ended Queue)",
    explanation:
      "Deque là một loại Queue đặc biệt, đặc biệt là một queue hai đầu, nghĩa là bạn có thể thêm hoặc xóa các phần tử từ cả hai đầu (front or back) của Deque [60].",
  },
  {
    id: 65,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích chính của HashMap là gì?",
    options: [
      "Đảm bảo các phần tử được sắp xếp theo thứ tự chèn.",
      "Tăng tốc quá trình tìm kiếm so với ArrayList.",
      "Chỉ lưu trữ các kiểu dữ liệu nguyên thủy.",
      "Thực hiện nguyên tắc LIFO.",
    ],
    answer: 1, // Tăng tốc quá trình tìm kiếm so với ArrayList.
    explanation:
      "HashMap là một loại collection được giới thiệu trong Java để tăng tốc quá trình tìm kiếm so với ArrayList [61].",
  },
  {
    id: 66,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Trong HashMap, mỗi mục bạn muốn thêm phải được liên kết với một cái gì đó duy nhất (unique) để truy cập nhanh chóng?",
    answer: "key",
    explanation:
      "HashMap cho phép bạn liên kết một key với mỗi mục bạn muốn thêm [61].",
  },
  {
    id: 67,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giao diện Iterator có những phương thức nào để duyệt qua một collection?",
    options: [
      "size(), get(), clear()",
      "push(), pop(), peek()",
      "hasNext(), next(), remove()",
      "add(), poll(), size()",
    ],
    answer: 2, // hasNext(), next(), remove()
    explanation:
      "Giao diện Iterator của Java có các phương thức hasNext(), next(), remove() [62].",
  },
  {
    id: 68,
    topic: "Data Structures",
    type: "text",
    question:
      "Phương thức tiện ích nào của String Class trong Java được sử dụng để so sánh chuỗi mà không phân biệt chữ hoa, chữ thường?",
    answer: "equalsIgnoreCase()",
    explanation:
      "Phương thức boolean equalsIgnoreCase(String) được sử dụng để so sánh chuỗi [63].",
  },
  {
    id: 69,
    topic: "Data Structures",
    type: "radio",
    question:
      'Khi bạn tạo String bằng từ khóa `new String("Java")`, điều gì xảy ra?',
    options: [
      "Chuỗi được lưu trữ duy nhất trong String Pool.",
      "Chuỗi mới được tạo trong Heap.",
      "Tham chiếu được trả về từ String Pool.",
      "Luôn luôn gây ra lỗi biên dịch.",
    ],
    answer: 1, // Chuỗi mới được tạo trong Heap.
    explanation: "Sử dụng từ khóa new tạo một chuỗi mới trong heap [64].",
  },
  {
    id: 70,
    topic: "Data Structures",
    type: "code",
    question:
      "Giả sử `newsFeed` là một Stack<String> và các thao tác sau được thực hiện, đầu ra sẽ là gì?",
    code: `
Stack<String> newsFeed = new Stack<>(); 
newsFeed.push("A"); // 1st
newsFeed.push("B"); // 2nd
newsFeed.push("C"); // 3rd
System.out.println(newsFeed.pop());
System.out.println(newsFeed.pop());`,
    options: ["A, B", "B, C", "C, B", "A, C"],
    answer: 2, // C, B
    explanation:
      "Stack hoạt động theo cơ chế LIFO (Last-In, First-Out). 'C' được thêm vào cuối cùng (top) nên nó được pop() ra đầu tiên, sau đó đến 'B' [59, 65].",
  },

  // --- CHỦ ĐỀ: GENERICS ---
  {
    id: 71,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics (Kiểu chung) được giới thiệu trong JDK 5.0 nhằm giải quyết hạn chế nào khi sử dụng kiểu Object để xử lý các thuật toán độc lập với kiểu dữ liệu?",
    options: [
      "Bắt buộc phải sử dụng từ khóa 'super'.",
      "Mất tính đa hình.",
      "Yêu cầu ép kiểu liên tục và không có cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch.",
      "Không thể sử dụng Collection.",
    ],
    answer: 2, // Yêu cầu ép kiểu liên tục và không có cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch.
    explanation:
      "Hạn chế khi sử dụng Object là cần ép kiểu liên tục và không có cơ chế kiểm tra lỗi [66]. Generics giúp loại bỏ nhu cầu ép kiểu [67].",
  },
  {
    id: 72,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Cú pháp cho Generics class bao gồm danh sách các tham số kiểu (type parameters) nằm bên trong dấu ngoặc nào?",
    answer: "<>",
    explanation:
      "Bạn có thể xác định kiểu dữ liệu bằng cách chỉ định nó giữa các dấu ngoặc nhọn <> khi khai báo biến ArrayList [67].",
  },
  {
    id: 73,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì đúng về mối quan hệ kế thừa giữa các kiểu Generic?",
    options: [
      "Pair<Cat> kế thừa Pair<Animal>.",
      "Pair<Animal> kế thừa Pair<Cat>.",
      "Không có mối quan hệ kế thừa nào giữa Pair<Cat> và Pair<Animal>.",
      "Chỉ có thể sử dụng kiểu `Object`.",
    ],
    answer: 2, // Không có mối quan hệ kế thừa nào giữa Pair<Cat> và Pair<Animal>.
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: Pair<Animal> và Pair<Cat>) [68].",
  },
  {
    id: 74,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Để chỉ định rằng một tham số kiểu T phải là kiểu con của một kiểu BoundingType, ta sử dụng cú pháp nào?",
    answer: "<T extends BoundingType>",
    explanation:
      "Cú pháp cho tham số kiểu bị giới hạn (Bounded type parameters) là <T extends BoundingType>. T phải là kiểu con của BoundingType [69].",
  },
  {
    id: 75,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard không giới hạn (Unbounded wildcard) được chỉ định bằng ký tự nào?",
    options: ["<T>", "<? extends E>", "<? super E>", "<?>"],
    answer: 3, // <?>
    explanation:
      "Kiểu wildcard không giới hạn được chỉ định bằng ký tự wildcard '?' (ví dụ: List<?>) [70].",
  },

  // --- CHỦ ĐỀ: EXCEPTION HANDLING ---
  {
    id: 76,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Lỗi nào xảy ra trong khi chương trình đang chạy và có thể khiến chương trình bị crash?",
    options: [
      "Syntax errors",
      "Compile-time errors",
      "Bugs (Logic errors)",
      "Runtime errors",
    ],
    answer: 3, // Runtime errors
    explanation:
      "Runtime errors (lỗi thời gian chạy) xảy ra khi chương trình đang chạy và có thể gây ra crash [71].",
  },
  {
    id: 77,
    topic: "Exception Handling",
    type: "radio",
    question: "Sự khác biệt chính giữa Error và Exception là gì?",
    options: [
      "Error là vấn đề nghiêm trọng mà ứng dụng KHÔNG nên cố gắng xử lý, trong khi Exception là điều kiện mà ứng dụng CÓ THỂ cố gắng xử lý.",
      "Error có thể được bắt bằng khối 'catch', Exception thì không.",
      "Error chỉ xảy ra ở thời điểm biên dịch.",
      "Không có sự khác biệt.",
    ],
    answer: 0, // Error là vấn đề nghiêm trọng mà ứng dụng KHÔNG nên cố gắng xử lý, trong khi Exception là điều kiện mà ứng dụng CÓ THỂ cố gắng xử lý.
    explanation:
      "Error đại diện cho vấn đề nghiêm trọng mà ứng dụng hợp lý không nên cố gắng xử lý. Exception đại diện cho điều kiện mà ứng dụng hợp lý có thể cố gắng xử lý [72].",
  },
  {
    id: 78,
    topic: "Exception Handling",
    type: "text",
    question:
      "Khối code nào được sử dụng để chứa các câu lệnh có khả năng ném ra ngoại lệ (throw exceptions)?",
    answer: "try",
    explanation:
      "Các câu lệnh có thể ném ra ngoại lệ được chứa trong một khối try [73].",
  },
  {
    id: 79,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối lệnh nào (nếu có) luôn được thực thi sau khi khối 'try' kết thúc, bất kể có ngoại lệ xảy ra hay không?",
    options: ["catch", "throw", "finally", "assert"],
    answer: 2, // finally
    explanation:
      "Bất kỳ mã nào phải được thực thi sau khi khối try hoàn thành đều được đặt trong khối finally. Khối finally luôn được thực thi [73, 74].",
  },
  {
    id: 80,
    topic: "Exception Handling",
    type: "radio",
    question: "Ngoại lệ Checked (Checked Exceptions) là gì?",
    options: [
      "Các ngoại lệ không được kiểm tra ở thời điểm biên dịch.",
      "Các ngoại lệ được kiểm tra ở thời điểm biên dịch, buộc phương thức phải xử lý hoặc chỉ định chúng bằng từ khóa 'throws'.",
      "Chỉ xảy ra trong thời gian chạy.",
      "Các ngoại lệ do người dùng tự định nghĩa.",
    ],
    answer: 1, // Các ngoại lệ được kiểm tra ở thời điểm biên dịch, buộc phương thức phải xử lý hoặc chỉ định chúng bằng từ khóa 'throws'.
    explanation:
      "Checked Exceptions là các ngoại lệ được kiểm tra ở thời điểm biên dịch. Nếu một phương thức ném ra checked exception, nó phải xử lý hoặc chỉ định ngoại lệ đó bằng từ khóa 'throws' [75, 76].",
  },
  {
    id: 81,
    topic: "Exception Handling",
    type: "text",
    question:
      "Ngoại lệ `NullPointerException` thuộc loại Checked hay Unchecked?",
    answer: "Unchecked",
    explanation:
      "NullPointerException là một ví dụ của ngoại lệ Unchecked (Runtime Exception) [42, 77].",
  },
  {
    id: 82,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu cả lớp cơ sở (Base) và lớp dẫn xuất (Derived) đều được bắt làm ngoại lệ, catch block nào phải xuất hiện trước?",
    options: [
      "Catch block của lớp Base.",
      "Catch block của lớp Derived.",
      "Thứ tự không quan trọng.",
      "Nó sẽ gây ra lỗi biên dịch nếu cả hai được bắt.",
    ],
    answer: 1, // Catch block của lớp Derived.
    explanation:
      "Nếu cả lớp cơ sở và lớp dẫn xuất đều được bắt làm ngoại lệ, catch block của lớp dẫn xuất phải xuất hiện trước lớp cơ sở [78, 79].",
  },
  {
    id: 83,
    topic: "Exception Handling",
    type: "text",
    question:
      "Để tự tạo ngoại lệ (User-defined exception), class mới phải là lớp con của class nào?",
    answer: "Exception",
    explanation: "Tất cả các ngoại lệ đều là lớp con của class Exception [80].",
  },
  {
    id: 84,
    topic: "Exception Handling",
    type: "code",
    question: "Đoạn mã sau in ra gì?",
    code: `
public class ExceptionTest {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("A");
        } finally {
            System.out.println("B");
        }
    }
}`,
    options: ["A", "B", "A và B", "Lỗi runtime không thể bắt"],
    answer: 2, // A và B
    explanation:
      "Ngoại lệ ArithmeticException được ném ra và bắt (in ra A), sau đó khối finally luôn được thực thi (in ra B) [74, 81].",
  },
  {
    id: 85,
    topic: "Exception Handling",
    type: "text",
    question: "Phương thức `System.gc()` được sử dụng để làm gì?",
    answer: "Yêu cầu JVM chạy Garbage Collector.",
    explanation:
      "Sử dụng System.gc() là một trong hai cách để yêu cầu JVM chạy Garbage Collector [82].",
  },

  // --- CHỦ ĐỀ: DESIGN PATTERNS ---
  {
    id: 86,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế (Design Pattern) là gì?",
    options: [
      "Các class và object cụ thể để sử dụng lại.",
      "Các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm.",
      "Các cú pháp bắt buộc trong ngôn ngữ lập trình.",
      "Các thuật toán phức tạp.",
    ],
    answer: 1, // Các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm.
    explanation:
      "Design patterns là các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm [83, 84].",
  },
  {
    id: 87,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào (Design Pattern) tập trung vào việc tạo đối tượng (object creation) để đảm bảo tính linh hoạt và tái sử dụng?",
    options: ["Structural", "Behavioral", "Creational", "Utility"],
    answer: 2, // Creational
    explanation:
      "Creational patterns (Mẫu khởi tạo): tập trung vào việc tạo đối tượng để đảm bảo tính linh hoạt và tái sử dụng [84, 85].",
  },
  {
    id: 88,
    topic: "Design Patterns",
    type: "text",
    question:
      "Mẫu thiết kế khởi tạo nào (Creational pattern) đảm bảo rằng chỉ có một thể hiện (instance) của một class tồn tại trong hệ thống?",
    answer: "Singleton",
    explanation:
      "Singleton: đảm bảo rằng chỉ có một thể hiện của class tồn tại [86].",
  },
  {
    id: 89,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích chính của Factory Method Pattern là gì?",
    options: [
      "Tạo các đối tượng mới bằng cách sao chép một đối tượng hiện có.",
      "Định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo.",
      "Thêm chức năng mới vào đối tượng mà không thay đổi cấu trúc của nó.",
      "Tổ chức đối tượng trong cấu trúc phân cấp.",
    ],
    answer: 1, // Định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo.
    explanation:
      "Mục đích của Factory method pattern là định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo [87].",
  },
  {
    id: 90,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern khác với Factory Method Pattern ở điểm nào?",
    options: [
      "Abstract Factory tạo ra các families of related objects (nhóm các đối tượng liên quan), trong khi Factory Method tạo ra một loại đối tượng duy nhất.",
      "Abstract Factory dựa trên Subclassing, còn Factory Method dựa trên Composition.",
      "Factory Method yêu cầu constructor private.",
      "Abstract Factory chỉ được sử dụng cho các class trừu tượng.",
    ],
    answer: 0, // Abstract Factory tạo ra các families of related objects (nhóm các đối tượng liên quan), trong khi Factory Method tạo ra một loại đối tượng duy nhất.
    explanation:
      "Factory Method tạo ra một loại đối tượng duy nhất. Abstract Factory tạo ra families of related objects [88].",
  },
  {
    id: 91,
    topic: "Design Patterns",
    type: "text",
    question:
      "Mẫu thiết kế khởi tạo nào (Creational pattern) được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có (prototype)?",
    answer: "Prototype",
    explanation:
      "Prototype được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có (prototype) [89].",
  },
  {
    id: 92,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào (Structural pattern) hoạt động như một cầu nối (bridge) giữa các đối tượng có giao diện không tương thích?",
    options: ["Decorator", "Composite", "Adapter", "Strategy"],
    answer: 2, // Adapter
    explanation:
      "Adapter pattern giúp các đối tượng có giao diện không tương thích cộng tác bằng cách hoạt động như một cầu nối giữa chúng [90].",
  },
  {
    id: 93,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích của Composite Pattern là gì?",
    options: [
      "Cho phép thay đổi thuật toán tại thời điểm chạy.",
      "Tổ chức và thao tác các đối tượng trong cấu trúc phân cấp (ví dụ: thư mục chứa tệp và thư mục con).",
      "Đảm bảo chỉ có một instance của class.",
      "Xử lý các stream I/O.",
    ],
    answer: 1, // Tổ chức và thao tác các đối tượng trong cấu trúc phân cấp (ví dụ: thư mục chứa tệp và thư mục con).
    explanation:
      "Composite pattern cung cấp một cách để tổ chức và thao tác các đối tượng trong cấu trúc phân cấp [91].",
  },
  {
    id: 94,
    topic: "Design Patterns",
    type: "text",
    question:
      "Mẫu thiết kế nào (Structural pattern) cho phép bạn thêm chức năng mới một cách linh hoạt (dynamically) vào một đối tượng bằng cách 'gói' (wrapping) đối tượng đó với các lớp bổ sung?",
    answer: "Decorator",
    explanation:
      "Decorator là một structural design pattern cho phép bạn thêm chức năng mới một cách linh hoạt vào một đối tượng mà không làm thay đổi cấu trúc của nó [92].",
  },
  {
    id: 95,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Design Pattern thuộc loại nào?",
    options: ["Creational", "Structural", "Behavioral", "Utility"],
    answer: 2, // Behavioral
    explanation: "Strategy design pattern là một mẫu thiết kế Behavioral [93].",
  },
  {
    id: 96,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Design Pattern được sử dụng khi nào?",
    options: [
      "Khi bạn cần chỉ một instance của một class.",
      "Khi bạn muốn chọn hành vi (thuật toán) của một đối tượng một cách linh hoạt tại thời điểm chạy.",
      "Khi cần ép kiểu giữa các interface không tương thích.",
      "Khi cần tạo một nhóm các đối tượng liên quan.",
    ],
    answer: 1, // Khi bạn muốn chọn hành vi (thuật toán) của một đối tượng một cách linh hoạt tại thời điểm chạy.
    explanation:
      "Strategy pattern được sử dụng khi bạn muốn chọn hành vi (thuật toán) của một đối tượng một cách linh hoạt tại thời điểm chạy [94].",
  },
  {
    id: 97,
    topic: "Design Patterns",
    type: "text",
    question:
      "Mẫu thiết kế nào định nghĩa một nhóm các thuật toán, đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi cho nhau?",
    answer: "Strategy",
    explanation:
      "Strategy design pattern định nghĩa một nhóm các thuật toán, đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi cho nhau [93].",
  },
  {
    id: 98,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, class nào duy trì một tham chiếu đến đối tượng Strategy và sử dụng nó để thực thi thuật toán?",
    options: [
      "Strategy Interface",
      "Concrete Strategy",
      "Context Class",
      "Factory",
    ],
    answer: 2, // Context Class
    explanation:
      "Context class: duy trì một tham chiếu đến đối tượng Strategy và sử dụng nó để thực thi thuật toán [94].",
  },
  {
    id: 99,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích của Structural Design Patterns là gì?",
    options: [
      "Tập trung vào giao tiếp và trách nhiệm giữa các đối tượng.",
      "Tập trung vào việc tạo đối tượng để đảm bảo tính linh hoạt.",
      "Tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả.",
      "Tập trung vào xử lý lỗi.",
    ],
    answer: 2, // Tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả.
    explanation:
      "Structural patterns (Mẫu cấu trúc): tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả [5, 85].",
  },
  {
    id: 100,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế nào sau đây thuộc Creational Pattern?",
    options: ["Adapter", "Decorator", "Singleton", "Iterator"],
    answer: 2, // Singleton
    explanation: "Singleton là Creational Pattern [85].",
  },

  // --- CHỦ ĐỀ: I/O Stream (BỔ SUNG) ---
  {
    id: 101,
    topic: "I/O Stream",
    type: "text",
    question:
      "Trong I/O Stream, một 'stream' được định nghĩa là một chuỗi (sequence) gì?",
    answer: "data",
    explanation: "Stream là một chuỗi dữ liệu [95].",
  },
  {
    id: 102,
    topic: "I/O Stream",
    type: "radio",
    question:
      "Khi làm việc với dữ liệu ký tự (character data) trong Java I/O, nên sử dụng loại stream nào?",
    options: [
      "Byte streams",
      "Input streams",
      "Character streams",
      "Print streams",
    ],
    answer: 2, // Character streams
    explanation:
      "Khi tệp chứa dữ liệu ký tự, cách tiếp cận tốt nhất là sử dụng character streams [96, 97].",
  },
  {
    id: 103,
    topic: "I/O Stream",
    type: "radio",
    question: "Điều gì xảy ra nếu sử dụng I/O không đệm (unbuffered I/O)?",
    options: [
      "Mỗi yêu cầu đọc/ghi được xử lý trực tiếp bởi HĐH, làm cho chương trình kém hiệu quả hơn.",
      "Dữ liệu được lưu trữ trong bộ đệm tạm thời.",
      "Tốc độ thực thi được cải thiện đáng kể.",
      "Chỉ có thể đọc dữ liệu byte.",
    ],
    answer: 0, // Mỗi yêu cầu đọc/ghi được xử lý trực tiếp bởi HĐH, làm cho chương trình kém hiệu quả hơn.
    explanation:
      "I/O không đệm làm cho chương trình kém hiệu quả hơn vì mỗi yêu cầu đọc hoặc ghi được xử lý trực tiếp bởi HĐH [98].",
  },
  {
    id: 104,
    topic: "I/O Stream",
    type: "text",
    question:
      "Để lưu một đối tượng Java vào cơ sở dữ liệu hoặc truyền qua mạng, ta cần chuyển đổi trạng thái của đối tượng thành một byte stream bằng cách sử dụng kỹ thuật nào?",
    answer: "Serialization",
    explanation:
      "Để lưu một đối tượng Java, ta cần chuyển đổi trạng thái của đối tượng thành một byte stream bằng cách sử dụng Serialization [99].",
  },
  {
    id: 105,
    topic: "I/O Stream",
    type: "radio",
    question:
      "Để làm cho một đối tượng Java có thể được tuần tự hóa (serializable), nó cần triển khai interface nào?",
    options: ["Comparable", "Cloneable", "java.io.Serializable", "Runnable"],
    answer: 2, // java.io.Serializable
    explanation:
      "Để làm cho đối tượng có thể tuần tự hóa, ta cần triển khai marker interface java.io.Serializable [99].",
  },
  {
    id: 200,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "OOP là mô hình lập trình tổ chức mã bằng cách mô hình hóa các thực thể hoặc khái niệm trong thế giới thực thành các gì?",
    options: ["Functions", "Objects", "Procedures", "Source Files"],
    answer: 1,
    explanation:
      "OOP là mô hình lập trình tổ chức mã bằng cách mô hình hóa các thực thể hoặc khái niệm trong thế giới thực thành các đối tượng (objects) [1].",
  },
  {
    id: 201,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Class (lớp) có thể được xem là gì đối với một Object (đối tượng)?",
    options: [
      "Một thể hiện (instance) của đối tượng.",
      "Thực thể thực tế trên bộ nhớ.",
      "Bản thiết kế (blueprint) định nghĩa đối tượng nên trông như thế nào.",
      "Một biến primitive.",
    ],
    answer: 2,
    explanation:
      "Class có thể được xem là bản thiết kế (blueprint) định nghĩa đối tượng nên trông như thế nào [2, 3].",
  },
  {
    id: 202,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Trong OOP, một Object (đối tượng) là gì?",
    options: [
      "Nơi bạn liệt kê tất cả các fields và methods.",
      "Một biến đại diện cho một kiểu dữ liệu.",
      "Thực thể thực tế được tạo ra từ Class (tức là một instance).",
      "Chỉ là một kiểu dữ liệu nâng cao (enhanced datatype).",
    ],
    answer: 2,
    explanation:
      "Object (đối tượng) là thực thể thực tế được tạo ra từ class [2].",
  },
  {
    id: 203,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Trong OOP, đối tượng đóng gói hai loại thành phần chính nào?",
    options: [
      "Inheritance và Polymorphism.",
      "Dữ liệu (attributes) và phương thức (behavior).",
      "Packages và Libraries.",
      "Compiler và JVM.",
    ],
    answer: 1,
    explanation:
      "Đối tượng là thể hiện của class, đóng gói cả dữ liệu (attributes) và phương thức (behavior) [1].",
  },
  {
    id: 204,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Các biến dữ liệu tạo nên một đối tượng (data variables that makes up that object) được gọi là gì trong Java?",
    options: ["Methods.", "Fields.", "Constructors.", "Primitives."],
    answer: 1,
    explanation:
      "Các biến dữ liệu tạo nên đối tượng được gọi là Fields, đôi khi được gọi là attributes hoặc member variables [4, 5].",
  },
  {
    id: 205,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Các hành động mà đối tượng có khả năng thực hiện (ví dụ: attack, dodge) được gọi là gì trong Java?",
    options: ["Functions.", "Fields.", "Methods.", "Statements."],
    answer: 2,
    explanation:
      "Các hành động này trong Java được gọi là methods (phương thức) [6, 7].",
  },
  {
    id: 206,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Lập trình hướng đối tượng (OOP) khác với lập trình thủ tục (procedural programming) ở điểm nào?",
    options: [
      "Chỉ tập trung vào cách máy tính xử lý dữ liệu.",
      "Thiết kế mã để mô phỏng các đối tượng trong thế giới thực và cách chúng hoạt động.",
      "Sử dụng ngôn ngữ cấp thấp hơn.",
      "Luôn luôn sử dụng cấu trúc `if-else`.",
    ],
    answer: 1,
    explanation:
      "OOP được thiết kế để mô phỏng các đối tượng trong thế giới thực và cách chúng hoạt động, chứ không chỉ tập trung vào cách máy tính xử lý dữ liệu [8, 9].",
  },
  {
    id: 207,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Trong Java, String được phân loại là gì?",
    options: [
      "Một kiểu dữ liệu nguyên thủy (primitive type).",
      "Một đối tượng/class.",
      "Một hằng số (constant).",
      "Một wrapper class.",
    ],
    answer: 1,
    explanation:
      "String không phải là một kiểu nguyên thủy, mà là một class [10].",
  },
  {
    id: 208,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Theo quy tắc, một class Java nên được tạo trong bao nhiêu tệp?",
    options: [
      "Một tệp duy nhất cho toàn bộ chương trình.",
      "Mỗi class nên được tạo trong tệp riêng của nó.",
      "Tùy thuộc vào package.",
      "Tối đa 10 class trong một tệp.",
    ],
    answer: 1,
    explanation:
      "Trong Java, mỗi class nên được tạo trong tệp riêng của nó [11].",
  },
  {
    id: 209,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Quy ước đặt tên (Naming convention) nào được sử dụng cho các Class trong Java?",
    options: [
      "camelCase (bắt đầu bằng chữ thường).",
      "CamelCase (bắt đầu bằng chữ hoa).",
      "Sử dụng tất cả chữ hoa (SCREAMING_SNAKE_CASE).",
      "snake_case.",
    ],
    answer: 1,
    explanation:
      "Quy ước đặt tên cho Class là CamelCase (bắt đầu bằng chữ hoa) [10].",
  },
  {
    id: 210,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Để truy cập một field (trường) trong một đối tượng (ví dụ: `book.title`), toán tử nào được sử dụng?",
    options: ["@", "&", ".", "->"],
    answer: 2,
    explanation:
      "Việc truy cập một trường trong một đối tượng được thực hiện bằng cách sử dụng toán tử dấu chấm “.” [7].",
  },
  {
    id: 211,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Đâu là một lợi ích của việc sử dụng các đối tượng?",
    options: [
      "Làm cho mã khó bảo trì hơn.",
      "Tăng cường sự phân mảnh mã (code fragmentation).",
      "Làm cho mã có tổ chức và dễ hiểu hơn.",
      "Giới hạn khả năng mở rộng trong tương lai.",
    ],
    answer: 2,
    explanation:
      "Objects làm cho mã trở nên có tổ chức và dễ hiểu hơn, đồng thời giúp việc bảo trì trở nên đơn giản hơn [4].",
  },
  {
    id: 212,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Phương thức nào là điểm khởi đầu cho một chương trình Java?",
    options: ["init()", "start()", "method main()", "Constructor"],
    answer: 2,
    explanation:
      "Điểm khởi đầu cho một chương trình là phương thức main() [12].",
  },
  {
    id: 213,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Nếu một đối tượng chỉ có các Fields (dữ liệu) mà không có Methods, mục đích chính của nó là gì?",
    options: [
      "Thực hiện các hành động đa hình.",
      "Cung cấp các phương thức tĩnh tiện ích.",
      "Đóng vai trò là cách để tổ chức lưu trữ dữ liệu.",
      "Là một Abstract Class.",
    ],
    answer: 2,
    explanation:
      "Một số đối tượng có thể chỉ có các fields, đóng vai trò là cách để tổ chức lưu trữ dữ liệu nhưng không bao gồm bất kỳ phương thức nào [13].",
  },
  {
    id: 214,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Thành phần nào mô tả 'hành vi' (behavior) của đối tượng?",
    options: ["Fields.", "Instance Variables.", "Attributes.", "Methods."],
    answer: 3,
    explanation:
      "Methods (phương thức) đại diện cho hành vi của một đối tượng [14].",
  },
  {
    id: 215,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Thành phần nào mô tả 'trạng thái' (state) của đối tượng?",
    options: [
      "Methods.",
      "Parameters.",
      "Instance Variables (Fields).",
      "Return Types.",
    ],
    answer: 2,
    explanation:
      "Những thứ mà một đối tượng tự biết về bản thân được gọi là instance variables (trường thể hiện), chúng đại diện cho trạng thái (state) của đối tượng [15, 16].",
  },
  {
    id: 216,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Trong Java, mỗi biến (reference) của kiểu class Object được lưu trữ ở đâu?",
    options: ["Static Memory.", "ROM.", "Stack Memory.", "Heap Memory."],
    answer: 3,
    explanation:
      "Tất cả các đối tượng (objects) sống trên Heap [17-19]. Biến reference cục bộ trỏ đến object đó được lưu trên Stack [18, 20].",
  },
  {
    id: 217,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Lập trình viên Java có thể thiết kế một Object giống như gì?",
    options: [
      "Một biến nguyên thủy (primitive variable).",
      "Một kiểu dữ liệu nâng cao (enhanced datatype) mà họ tự thiết kế.",
      "Một hàm `main()`.",
      "Một IDE.",
    ],
    answer: 1,
    explanation:
      "Một object không hơn gì một kiểu dữ liệu nâng cao (enhanced datatype) mà bạn tự thiết kế [6].",
  },
  {
    id: 218,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Khi thiết kế một Class, bạn nên tập trung vào những khía cạnh nào của Object sẽ được tạo ra?",
    options: [
      "Những thứ Object biết và những thứ Object làm.",
      "Chỉ những thứ Object biết (dữ liệu).",
      "Chỉ những thứ Object làm (hành vi).",
      "Kích thước tệp tin.",
    ],
    answer: 0,
    explanation:
      "Khi thiết kế một class, hãy nghĩ về những thứ đối tượng biết (instance variables/state) và những thứ đối tượng làm (methods/behavior) [21, 22].",
  },
  {
    id: 219,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Theo quy ước đặt tên trong Java, một biến đối tượng (Object variable) như `pikachu` nên được đặt tên như thế nào?",
    options: [
      "Bắt đầu bằng chữ hoa (PascalCase).",
      "Bắt đầu bằng chữ thường (camelCase).",
      "Sử dụng dấu gạch dưới (snake_case).",
      "Sử dụng tất cả chữ hoa (constants).",
    ],
    answer: 1,
    explanation:
      "Quy ước đặt tên cho biến đối tượng là camelCase (bắt đầu bằng chữ thường) [10].",
  },
  {
    id: 220,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Lập trình viên cần làm gì để 'thiết kế đối tượng'?",
    options: [
      "Viết hàm `main()`.",
      "Tạo các class.",
      "Sử dụng `Integer.parseInt()`.",
      "Biên dịch mã nguồn.",
    ],
    answer: 1,
    explanation: "Để thiết kế đối tượng, chúng ta cần tạo ra các class [2].",
  },
  {
    id: 221,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Tính Đóng gói (Encapsulation) được mô tả là gì?",
    options: [
      "Khả năng đối tượng có nhiều hình thức.",
      "Gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng).",
      "Truyền lại các đặc điểm từ lớp cha sang lớp con.",
      "Cơ chế tạo đối tượng bằng cách sao chép.",
    ],
    answer: 1,
    explanation:
      "Đóng gói (Encapsulation) là việc gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng) [23].",
  },
  {
    id: 222,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Để đạt được Encapsulation và Ẩn thông tin (Information Hiding), fields (trường) nên được khai báo với access modifier nào?",
    options: ["public", "protected", "private", "default"],
    answer: 2,
    explanation:
      "Thực hành tốt là luôn cố gắng khai báo tất cả các fields là private [24]. Fields private được sử dụng để che giấu thông tin [25, 26].",
  },
  {
    id: 223,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Các phương thức công khai (public methods) được tạo ra để trả về giá trị của trường private được gọi là gì?",
    options: ["Mutators.", "Setters.", "Getters.", "Mutators và Setters."],
    answer: 2,
    explanation:
      "Các phương thức công khai trả về trường private được gọi là getters [24].",
  },
  {
    id: 224,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Các phương thức công khai (public methods) được tạo ra để thiết lập hoặc thay đổi giá trị của trường private được gọi là gì?",
    options: ["Accessors.", "Getters.", "Setters.", "Helpers."],
    answer: 2,
    explanation:
      "Các phương thức công khai thiết lập trường private được gọi là setters [24].",
  },
  {
    id: 225,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Lợi ích chính của việc sử dụng Setter methods để thay đổi dữ liệu thay vì cho phép truy cập trực tiếp public vào fields là gì?",
    options: [
      "Giảm chi phí bộ nhớ.",
      "Cho phép Setter xác thực tham số (validate the parameter) trước khi thay đổi giá trị.",
      "Đảm bảo rằng giá trị không bao giờ thay đổi.",
      "Tăng tốc độ biên dịch.",
    ],
    answer: 1,
    explanation:
      "Setter method có thể xác thực tham số và quyết định xem việc thay đổi giá trị có hợp lệ hay không. Điều này không thể làm được nếu field là public [27].",
  },
  {
    id: 226,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Nếu một field được khai báo là public, lập trình viên có thể làm gì ở bất cứ đâu trong dự án?",
    options: [
      "Chỉ đọc giá trị.",
      "Chỉ thay đổi giá trị thông qua setter.",
      "Truy cập và thay đổi giá trị trực tiếp.",
      "Chỉ truy cập từ cùng một package.",
    ],
    answer: 2,
    explanation:
      "Field hoặc method public có thể được truy cập bởi các class khác [28]. Nếu field là public, ta có thể `book.isBorrowed = true` ở bất cứ đâu [29].",
  },
  {
    id: 227,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Encapsulation giúp bảo vệ instance variables khỏi điều gì?",
    options: [
      "Việc sao chép đối tượng (object cloning).",
      "Các ngoại lệ (exceptions).",
      "Bị đặt giá trị không phù hợp (inappropriate values).",
      "Bị Garbage Collector thu hồi.",
    ],
    answer: 2,
    explanation:
      "Encapsulation tạo ra một 'trường lực' xung quanh instance variables để ngăn chặn việc đặt các giá trị không phù hợp [27, 30].",
  },
  {
    id: 228,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Mục đích chính của Constructor trong Java là gì?",
    options: [
      "Thiết lập các hằng số (constants).",
      "Chỉ để trả về giá trị của đối tượng.",
      "Tạo và khởi tạo một đối tượng của class đó.",
      "Chạy phương thức `main()`.",
    ],
    answer: 2,
    explanation:
      "Constructors là các phương thức đặc biệt chịu trách nhiệm tạo và khởi tạo (creating & initializing) một đối tượng của class đó [31, 32].",
  },
  {
    id: 229,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Sự khác biệt cú pháp nào là chính yếu giữa Constructor và Method thông thường?",
    options: [
      "Constructor phải là `static`.",
      "Constructor không có kiểu trả về.",
      "Constructor không thể có tham số.",
      "Method không thể gọi `new`.",
    ],
    answer: 1,
    explanation: "Constructor không có kiểu trả về (return types) [31, 33].",
  },
  {
    id: 230,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Constructor phải có quy tắc đặt tên nào?",
    options: [
      "Bắt đầu bằng `new`.",
      "Có cùng tên với class.",
      "Bắt đầu bằng `init`.",
      "Luôn là `default`.",
    ],
    answer: 1,
    explanation: "Constructor phải có cùng tên với class [33, 34].",
  },
  {
    id: 231,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Constructor không có tham số đầu vào được gọi là gì?",
    options: [
      "Parameterized constructor.",
      "Copy constructor.",
      "Default constructor.",
      "Final constructor.",
    ],
    answer: 2,
    explanation:
      "Constructor không nhận tham số đầu vào được gọi là Default constructor (hoặc no-arg constructor) [33, 34].",
  },
  {
    id: 232,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn không định nghĩa bất kỳ constructor nào trong class?",
    options: [
      "Class sẽ không biên dịch.",
      "Compiler sẽ tự động tạo một constructor mặc định (empty constructor).",
      "Bạn chỉ có thể tạo object bằng cách sao chép.",
      "Tất cả các fields sẽ là `null`.",
    ],
    answer: 1,
    explanation:
      "Nếu bạn không tạo một constructor mặc định, Java sẽ tự động giả định có một constructor mặc định không làm gì cả (empty constructor) [33, 34].",
  },
  {
    id: 233,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Nếu một class chỉ có constructor có tham số (Parameterized constructor), điều gì xảy ra nếu lập trình viên cố gắng gọi constructor mặc định?",
    options: [
      "Code chạy bình thường, object được khởi tạo với giá trị mặc định.",
      "Chương trình bị crash tại runtime.",
      "Xảy ra lỗi biên dịch (compile error).",
      "Constructor có tham số sẽ được gọi thay thế.",
    ],
    answer: 2,
    explanation:
      "Nếu class có constructor có tham số, compiler sẽ không tạo constructor mặc định. Việc gọi constructor mặc định sẽ gây ra lỗi biên dịch [33, 35].",
  },
  {
    id: 234,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Làm thế nào để tạo một Object và gọi Constructor của nó?",
    options: [
      "Sử dụng toán tử `.` (dot operator).",
      "Sử dụng từ khóa `call`.",
      "Sử dụng từ khóa `new` theo sau là tên constructor.",
      "Constructor được gọi tự động khi khởi động chương trình.",
    ],
    answer: 2,
    explanation:
      "Để tạo một đối tượng, ta sử dụng từ khóa `new` theo sau là constructor muốn dùng [36].",
  },
  {
    id: 235,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Khái niệm Overloaded constructors (đa tải constructor) là gì?",
    options: [
      "Một constructor có thể kế thừa từ constructor lớp cha.",
      "Nhiều constructor trong cùng một class có tên khác nhau.",
      "Nhiều constructor trong cùng một class có danh sách tham số khác nhau.",
      "Constructor chỉ có thể có một tham số.",
    ],
    answer: 2,
    explanation:
      "Overloaded constructors nghĩa là bạn có nhiều constructor trong class, chúng phải có danh sách tham số khác nhau [37, 38].",
  },
  {
    id: 236,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Điều gì là một thực hành tốt khi sử dụng nhiều constructor?",
    options: [
      "Chỉ giữ lại constructor có tham số để tùy chỉnh tối đa.",
      "Luôn cung cấp một constructor mặc định để khởi tạo fields với giá trị điển hình.",
      "Không cần constructor nếu tất cả fields là private.",
      "Chỉ sử dụng `new` để khởi tạo object.",
    ],
    answer: 1,
    explanation:
      "Đó là thực hành tốt khi luôn bao gồm một constructor mặc định để khởi tạo tất cả các fields với các giá trị tương ứng với kịch bản điển hình [39].",
  },
  {
    id: 237,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Constructor nào được sử dụng để khởi tạo một đối tượng mới bằng cách sử dụng một đối tượng đã được tạo trước đó cùng loại?",
    options: [
      "Default constructor.",
      "Static constructor.",
      "Copy constructor.",
      "Private constructor.",
    ],
    answer: 2,
    explanation:
      "Object của class có thể được khởi tạo bằng một object đã được tạo trước đó cùng loại bằng Copy constructor [40].",
  },
  {
    id: 238,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Từ khóa `this()` bên trong một constructor được sử dụng để làm gì?",
    options: [
      "Gọi constructor lớp cha.",
      "Gọi một constructor khác của chính class hiện tại.",
      "Truy cập các biến static.",
      "Trả về đối tượng hiện tại.",
    ],
    answer: 1,
    explanation:
      "Sử dụng `this()` để gọi constructor của chính class hiện tại [41, 42].",
  },
  {
    id: 239,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Quy tắc nào sau đây là BẮT BUỘC khi sử dụng `this()` trong một constructor?",
    options: [
      "Phải là câu lệnh cuối cùng.",
      "Phải được khai báo là `public`.",
      "Phải là câu lệnh đầu tiên trong constructor.",
      "Chỉ có thể được sử dụng trong default constructor.",
    ],
    answer: 2,
    explanation:
      "Lệnh gọi constructor `this()` phải là câu lệnh đầu tiên trong constructor [41].",
  },
  {
    id: 240,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Từ khóa `this` là một biến tham chiếu dùng để chỉ đối tượng nào?",
    options: [
      "Đối tượng lớp cha.",
      "Đối tượng được tạo gần nhất.",
      "Đối tượng hiện tại (current object).",
      "Biến reference null.",
    ],
    answer: 2,
    explanation:
      "`this` là một biến tham chiếu đề cập đến đối tượng hiện tại [43, 44].",
  },
  {
    id: 241,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Mục đích phổ biến nhất của việc sử dụng từ khóa `this` trong constructor là gì?",
    options: [
      "Để ngăn chặn Garbage Collector.",
      "Để phân biệt giữa field và tham số có cùng tên.",
      "Để gọi method lớp cha.",
      "Để trả về object hiện tại.",
    ],
    answer: 1,
    explanation:
      "Lý do phổ biến nhất để sử dụng từ khóa `this` là vì một field có cùng tên với tham số trong method hoặc constructor [43, 45].",
  },
  {
    id: 242,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Nếu một biến object không được khởi tạo bằng `new`, giá trị của nó sẽ được đặt là gì?",
    options: ["Giá trị mặc định của class.", "0.", "false.", "null."],
    answer: 3,
    explanation:
      "Nếu bạn không khởi tạo một object bằng từ khóa `new`, giá trị của nó sẽ được đặt là `null` [39].",
  },
  {
    id: 243,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Trong bộ nhớ Java, các đối tượng được lưu trữ ở đâu?",
    options: ["Stack.", "Primitive Pool.", "Heap.", "Program Counter."],
    answer: 2,
    explanation:
      "Tất cả các đối tượng sống trên Heap (hay Garbage-Collectible Heap) [17-19].",
  },
  {
    id: 244,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Các biến cục bộ (Local variables) được khai báo bên trong một method được lưu trữ ở đâu?",
    options: ["Heap.", "Stack.", "Static Memory.", "Thread Pool."],
    answer: 1,
    explanation: "Các biến cục bộ sống trên Stack [19, 20, 46].",
  },
  {
    id: 245,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Khi bạn truyền một đối tượng/tham chiếu vào một phương thức (method), điều gì xảy ra?",
    options: [
      "Tham chiếu gốc được truyền và thay đổi bên trong method sẽ ảnh hưởng đến object gốc.",
      "Một bản sao hoàn chỉnh của object được tạo.",
      "Java chỉ truyền giá trị (pass-by-value) nên object gốc không bao giờ thay đổi.",
      "Lỗi biên dịch nếu không sử dụng từ khóa `clone`.",
    ],
    answer: 0,
    explanation:
      "Khi truyền object references, Java tạo một bản sao của reference và truyền cho method, nhưng chúng vẫn trỏ đến cùng một đối tượng trong bộ nhớ (Heap), do đó việc thay đổi object bên trong method sẽ được phản ánh trên object gốc [47-49].",
  },
  {
    id: 246,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Lập trình viên C/C++ có trách nhiệm quản lý việc tạo và hủy đối tượng. Trong Java, việc hủy các đối tượng vô dụng được thực hiện bởi cơ chế nào?",
    options: [
      "System.out.println()",
      "Finalize() method.",
      "Garbage Collector (GC).",
      "Manual Deallocation.",
    ],
    answer: 2,
    explanation:
      "Trong Java, lập trình viên không cần quan tâm đến việc hủy các đối tượng không cần thiết; Garbage Collector (GC) sẽ thực hiện việc này [50, 51].",
  },
  {
    id: 247,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Một object được coi là đủ điều kiện để Garbage Collection (GC) khi nào?",
    options: [
      "Sau khi constructor chạy xong.",
      "Khi nó không còn bất kỳ reference (tham chiếu) nào trỏ đến nó.",
      "Khi nó được khai báo là `null`.",
      "Khi nó được khởi tạo bằng default constructor.",
    ],
    answer: 1,
    explanation:
      "GC thu hồi bộ nhớ khi đối tượng bị bỏ rơi (abandoned), tức là không còn reference nào trỏ đến nó [51-53].",
  },
  {
    id: 248,
    topic: "OOP Fundamentals",
    type: "radio",
    question: "Fields của một object có thể chứa kiểu dữ liệu nào?",
    options: [
      "Chỉ kiểu nguyên thủy (int, double, boolean).",
      "Chỉ các đối tượng khác.",
      "Các kiểu nguyên thủy và các đối tượng khác (bao gồm cả đối tượng của chính class đó).",
      "Chỉ String và Array.",
    ],
    answer: 2,
    explanation:
      "Fields được tạo thành từ các kiểu nguyên thủy (primitive types) nhưng cũng có thể là các object khác [5].",
  },
  {
    id: 249,
    topic: "OOP Fundamentals",
    type: "radio",
    question:
      "Nếu một phương thức không cần truy cập bất kỳ field nào trong đối tượng (i.e., nó là một hàm độc lập), nó lý tưởng nên được khai báo với từ khóa nào?",
    options: ["final", "private", "static", "void"],
    answer: 2,
    explanation:
      "Phương thức static lý tưởng được sử dụng để tạo một phương thức không cần truy cập bất kỳ trường nào trong đối tượng [54-56].",
  },
  {
    id: 300,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, các đối tượng (objects) được phân bổ động và lưu trữ ở khu vực bộ nhớ nào?",
    options: ["Stack Memory", "Heap Memory", "Static Memory", "ROM"],
    answer: 1,
    explanation:
      "Tất cả các đối tượng được phân bổ động trên Heap (hoặc Garbage-Collectible Heap) [1-4].",
  },
  {
    id: 301,
    topic: "Java Core",
    type: "radio",
    question:
      "Các biến cục bộ (Local variables) được khai báo bên trong một phương thức (method) được lưu trữ ở đâu?",
    options: ["Heap Memory", "Stack Memory", "Static Memory", "String Pool"],
    answer: 1,
    explanation:
      "Các biến cục bộ và thông tin gọi phương thức (method call information) sống trên Stack Memory [1, 5, 6].",
  },
  {
    id: 302,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ Java, các biến thể hiện (Instance variables) của một đối tượng được lưu trữ ở đâu?",
    options: [
      "Trong Stack, cùng với tham chiếu cục bộ.",
      "Trong Heap, bên trong chính đối tượng đó.",
      "Trong Static Memory.",
      "Trong String Pool.",
    ],
    answer: 1,
    explanation:
      "Các biến thể hiện (Instance variables) sống bên trong đối tượng mà chúng thuộc về, trên Heap [3, 5, 7].",
  },
  {
    id: 303,
    topic: "Java Core",
    type: "radio",
    question:
      "Cơ chế nào chịu trách nhiệm hủy các đối tượng không còn được sử dụng và giải phóng bộ nhớ trên Heap?",
    options: [
      "Constructor",
      "System.finalize()",
      "Garbage Collector (GC)",
      "Destructor",
    ],
    answer: 2,
    explanation:
      "Trong Java, Garbage Collector (GC) chịu trách nhiệm hủy các đối tượng vô dụng và giải phóng bộ nhớ Heap [8-11].",
  },
  {
    id: 304,
    topic: "Java Core",
    type: "radio",
    question:
      "Một đối tượng được coi là đủ điều kiện để bị Garbage Collection (GC) khi nào?",
    options: [
      "Khi nó được khai báo là 'final'.",
      "Khi nó không còn bất kỳ tham chiếu nào trỏ đến nó (unreachable).",
      "Ngay sau khi constructor hoàn tất.",
      "Khi nó được truyền dưới dạng tham số.",
    ],
    answer: 1,
    explanation:
      "Một đối tượng được coi là không thể truy cập (unreachable) và đủ điều kiện để GC khi không còn bất kỳ tham chiếu nào trỏ đến nó [8, 9, 12].",
  },
  {
    id: 305,
    topic: "Java Core",
    type: "radio",
    question: "Trong Java, String được phân loại là gì?",
    options: [
      "Một kiểu dữ liệu nguyên thủy (primitive type).",
      "Một kiểu dữ liệu bán nguyên thủy (semi-primitive type).",
      "Một class/Object.",
      "Một hằng số (constant).",
    ],
    answer: 2,
    explanation:
      "String không phải là một kiểu nguyên thủy, mà là một class [13, 14].",
  },
  {
    id: 306,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nào trong Java có kích thước cố định 16 bit và biểu diễn một ký tự Unicode?",
    options: ["byte", "short", "char", "int"],
    answer: 2,
    explanation: "Kiểu `char` có kích thước 16 bit [15, 16].",
  },
  {
    id: 307,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào có kích thước 64 bit và được sử dụng để lưu trữ số thực (floating point numbers)?",
    options: ["long", "float", "double", "int"],
    answer: 2,
    explanation:
      "Kiểu `double` có kích thước 64 bit và được sử dụng cho số thực dấu chấm động [16, 17].",
  },
  {
    id: 308,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, tất cả các đối tượng được tạo ra bằng cách sử dụng từ khóa nào?",
    options: ["class", "new", "constructor", "this"],
    answer: 1,
    explanation:
      "Để cấp phát bộ nhớ cho một đối tượng (trên Heap), chúng ta phải sử dụng từ khóa `new` [18].",
  },
  {
    id: 309,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, giá trị mặc định của một biến tham chiếu (reference variable) chưa được khởi tạo là gì?",
    options: ["0", "false", "null", "Một tham chiếu đến Object class"],
    answer: 2,
    explanation:
      "Các biến tham chiếu chưa được khởi tạo (bao gồm cả biến thể hiện) sẽ có giá trị mặc định là `null` [19-21].",
  },
  {
    id: 310,
    topic: "Java Core",
    type: "radio",
    question:
      "Quá trình biên dịch mã nguồn Java (file .java) tạo ra loại tệp nào?",
    options: [
      "Executable (.exe)",
      "Source code (.src)",
      "Bytecode (.class)",
      "Machine code (.bin)",
    ],
    answer: 2,
    explanation:
      "Mã nguồn Java được biên dịch thành bytecode, được lưu trong các tệp .class [22, 23].",
  },
  {
    id: 311,
    topic: "Java Core",
    type: "radio",
    question:
      "Thành phần nào đảm bảo tính độc lập nền tảng (platform independent) cho chương trình Java?",
    options: [
      "Java Compiler (javac)",
      "Java Development Kit (JDK)",
      "Java Virtual Machine (JVM)",
      "Java Runtime Environment (JRE)",
    ],
    answer: 2,
    explanation:
      "Bytecode là độc lập nền tảng, và JVM (thành phần phụ thuộc nền tảng) đảm bảo bytecode có thể thực thi trên các nền tảng khác nhau [22-25].",
  },
  {
    id: 312,
    topic: "Java Core",
    type: "radio",
    question: "Sự khác biệt chính giữa Java reference và C++ pointer là gì?",
    options: [
      "Reference lưu địa chỉ bộ nhớ, Pointer thì không.",
      "Java reference có thể thực hiện phép toán số học, C++ pointer thì không.",
      "Pointer là một biến lưu trữ địa chỉ bộ nhớ, còn reference không phải là pointer.",
      "Java không có reference, chỉ có object.",
    ],
    answer: 2,
    explanation:
      "Java có reference, không có pointer. Pointer là biến lưu trữ địa chỉ bộ nhớ, reference không phải là pointer theo định nghĩa đó [1, 18, 26, 27].",
  },
  {
    id: 313,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra khi bạn gán một biến tham chiếu (ví dụ: `x = y;`) trong Java?",
    options: [
      "Dữ liệu của object mà x trỏ tới được sao chép vào object mà y trỏ tới.",
      "Object mà x trỏ tới bị xóa khỏi Heap.",
      "Tham chiếu của y được sao chép, làm cho cả x và y trỏ đến cùng một object.",
      "Phép gán này chỉ áp dụng cho kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Đối với một đối tượng, hai tham chiếu sẽ trỏ đến cùng một đối tượng sau phép gán [28, 29]. Các bit bên trong biến tham chiếu c được sao chép và đặt vào biến b [29].",
  },
  {
    id: 314,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, nguyên tắc truyền tham số (pass-by) nào luôn được áp dụng?",
    options: [
      "Pass-by-Reference",
      "Pass-by-Value (Pass-by-Copy)",
      "Pass-by-Object",
      "Pass-by-Pointer",
    ],
    answer: 1,
    explanation:
      "Java luôn sử dụng Pass-by-Value (truyền theo giá trị), còn được gọi là Pass-by-Copy [30-33]. Đối với object, nó truyền bản sao của reference (tham chiếu) [31].",
  },
  {
    id: 315,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các Lớp Wrapper (Wrapper Classes) như Integer, Double là gì?",
    options: [
      "Chỉ để thực hiện các phép toán phức tạp.",
      "Để lưu trữ dữ liệu nguyên thủy trong một object, cung cấp thêm phương thức.",
      "Để ngăn chặn Garbage Collector.",
      "Chúng là kiểu dữ liệu nguyên thủy chính xác hơn.",
    ],
    answer: 1,
    explanation:
      "Wrapper class gói gọn một kiểu dữ liệu, mang lại cho nó vẻ ngoài của một object, cho phép lưu trữ dữ liệu nguyên thủy trong một object và cung cấp các phương thức tiện ích [34-37].",
  },
  {
    id: 316,
    topic: "Java Core",
    type: "radio",
    question: "Tính năng Autoboxing trong Java là gì?",
    options: [
      "Tự động chuyển đổi String thành int.",
      "Tự động đóng gói kiểu nguyên thủy thành object Wrapper tương ứng.",
      "Tự động tạo constructor mặc định.",
      "Tự động ép kiểu (casting) từ lớp cha xuống lớp con.",
    ],
    answer: 1,
    explanation:
      "Autoboxing là việc tự động đóng gói (wrapping) kiểu nguyên thủy thành object Wrapper tương ứng (ví dụ: `int` thành `Integer`) [38].",
  },
  {
    id: 317,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến `int` (kiểu nguyên thủy) được truyền vào một phương thức và thay đổi bên trong phương thức đó, điều gì xảy ra với biến gốc bên ngoài?",
    options: [
      "Biến gốc thay đổi vì là pass-by-reference.",
      "Biến gốc không thay đổi vì là pass-by-value (truyền bản sao giá trị).",
      "Xảy ra lỗi biên dịch.",
      "Nó chỉ thay đổi nếu biến là `static`.",
    ],
    answer: 1,
    explanation:
      "Java tạo một bản sao của biến nguyên thủy được truyền vào (pass-by-copy), nên sự thay đổi bên trong method không ảnh hưởng đến biến gốc [31].",
  },
  {
    id: 318,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong `Object` class được Garbage Collector (GC) gọi trên một đối tượng, MỘT LẦN, trước khi nó bị hủy?",
    options: ["dispose()", "clear()", "finalize()", "destroy()"],
    answer: 2,
    explanation:
      "Phương thức `finalize()` được GC gọi trên đối tượng MỘT LẦN trước khi thu thập rác [11, 39].",
  },
  {
    id: 319,
    topic: "Java Core",
    type: "radio",
    question:
      "Mặc dù không có đảm bảo, nhưng phương thức nào có thể được gọi để yêu cầu JVM chạy Garbage Collector?",
    options: ["System.runGC()", "GC.collect()", "System.gc()", "JVM.start()"],
    answer: 2,
    explanation:
      "Lập trình viên có thể yêu cầu JVM chạy GC bằng cách gọi `System.gc()` hoặc `Runtime.getRuntime().gc()` [40, 41].",
  },
  {
    id: 320,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong quá trình truyền đối tượng (reference passing), nếu đối tượng được khởi tạo lại bên trong phương thức (ví dụ: `t = new Test();`), điều gì xảy ra với object gốc?",
    options: [
      "Object gốc bị hủy ngay lập tức.",
      "Object gốc không thay đổi và tham chiếu gốc vẫn trỏ đến nó.",
      "Object gốc bị thay đổi state.",
      "Cả hai object đều trỏ đến `null`.",
    ],
    answer: 1,
    explanation:
      "Nếu `t = new Test();` được gọi, tham chiếu cục bộ `t` trên Stack giờ trỏ đến một object mới. Object gốc vẫn còn tồn tại và tham chiếu gốc bên ngoài method vẫn trỏ đến nó [42, 43].",
  },
  {
    id: 321,
    topic: "Java Core",
    type: "radio",
    question:
      "JVM (Java Virtual Machine) được mô tả là thành phần như thế nào?",
    options: [
      "Độc lập nền tảng (Platform Independent).",
      "Phụ thuộc nền tảng (Platform Dependent).",
      "Là một phần của mã nguồn Java.",
      "Là một phần của hệ điều hành.",
    ],
    answer: 1,
    explanation:
      "JVM là thành phần phụ thuộc vào nền tảng (phần cứng, OS) và được sử dụng để thực thi bytecode, đảm bảo tính độc lập nền tảng cho chương trình Java [24].",
  },
  {
    id: 322,
    topic: "Java Core",
    type: "radio",
    question:
      "String Pool (String Intern Pool) được duy trì bởi class nào và nằm ở đâu?",
    options: [
      "Class Object, trên Stack.",
      "Class String, trên Heap.",
      "Class System, trong Static Memory.",
      "Class Math, trong ROM.",
    ],
    answer: 1,
    explanation:
      "String Pool được duy trì bởi String class và là một khu vực lưu trữ đặc biệt nằm trong Heap [44, 45].",
  },
  {
    id: 323,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi khai báo `String str = "Java"` (sử dụng literal), Java sẽ làm gì nếu chuỗi "Java" đã tồn tại trong String Pool?',
    options: [
      "Luôn tạo một đối tượng mới trên Heap.",
      "Trả về tham chiếu đến thể hiện hiện có trong String Pool.",
      "Tạo một đối tượng mới trong Stack.",
      "Ném ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Nếu literal đã tồn tại trong String Pool, JVM trả về một tham chiếu đến thể hiện đã được nhóm (pooled instance) [44, 45].",
  },
  {
    id: 324,
    topic: "Java Core",
    type: "radio",
    question:
      "Từ khóa `this` được sử dụng để làm gì khi tên biến instance trùng với tên tham số trong constructor?",
    options: [
      "Để gọi constructor lớp cha.",
      "Để truy cập biến static.",
      "Để phân biệt giữa biến instance và tham số cục bộ.",
      "Để chỉ object được tạo gần nhất.",
    ],
    answer: 2,
    explanation:
      "Mục đích phổ biến nhất của `this` là để phân biệt giữa field (instance variable) và tham số có cùng tên [46].",
  },
  {
    id: 325,
    topic: "Java Core",
    type: "radio",
    question: "Kiểu dữ liệu nguyên thủy `byte` có kích thước là bao nhiêu?",
    options: ["1 bit", "8 bit", "16 bit", "32 bit"],
    answer: 1,
    explanation: "Kiểu `byte` có kích thước 8 bit [15, 16].",
  },
  {
    id: 326,
    topic: "Java Core",
    type: "radio",
    question:
      "Thành phần nào sau đây là nơi chứa các hằng số (Constants) và biến static (Class-level data)?",
    options: [
      "Stack Memory",
      "Heap Memory",
      "Static Memory",
      "Program Counter",
    ],
    answer: 2,
    explanation:
      "Dữ liệu cấp độ class (Class-level data) và biến static được lưu trữ trong Static Memory [1].",
  },
  {
    id: 327,
    topic: "Java Core",
    type: "radio",
    question: "Các Array (Mảng) trong Java được xem là gì?",
    options: [
      "Kiểu dữ liệu nguyên thủy.",
      "Các object.",
      "Kiểu dữ liệu được lưu trên Stack.",
      "Kiểu dữ liệu bán nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Mảng (Array) là một object và phải được tạo bằng từ khóa `new` trước khi sử dụng [47, 48].",
  },
  {
    id: 328,
    topic: "Java Core",
    type: "radio",
    question:
      "Đâu là ví dụ của một kiểu tham chiếu (Reference type) trong Java?",
    options: ["int", "double", "boolean", "Array"],
    answer: 3,
    explanation: "Mảng (Array) là một object và do đó là kiểu tham chiếu [48].",
  },
  {
    id: 329,
    topic: "Java Core",
    type: "radio",
    question:
      "Mô-đun nào trong JVM xử lý việc thực thi bytecode và quản lý bộ nhớ Heap/Stack?",
    options: [
      "Compiler",
      "JRE",
      "Interpreter",
      "Tất cả các thành phần này cùng nhau.",
    ],
    answer: 3,
    explanation:
      "JVM là một phần mềm thực thi bytecode, bao gồm cả trình thông dịch (interpreter) và bộ quản lý bộ nhớ (Heap/Stack) [24, 25].",
  },
  {
    id: 330,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong các lớp Wrapper được sử dụng để chuyển đổi String thành kiểu nguyên thủy tương ứng (ví dụ: String '12' thành int 12)?",
    options: [
      "toString()",
      "valueOf(String s)",
      "parseType(String s) (ví dụ: Integer.parseInt())",
      "typeValue()",
    ],
    answer: 2,
    explanation:
      "Các phương thức static `parseType(String s)` (ví dụ: Integer.parseInt()) được sử dụng để chuyển đổi string thành giá trị kiểu nguyên thủy tương ứng [49-51].",
  },
  {
    id: 331,
    topic: "Java Core",
    type: "radio",
    question:
      "Mã nguồn Java (.java) được biên dịch thành bytecode (.class) bởi công cụ nào?",
    options: ["java interpreter", "javac compiler", "JDB debugger", "JVM"],
    answer: 1,
    explanation:
      "`javac` là trình biên dịch, chuyển đổi mã nguồn thành bytecode [52].",
  },
  {
    id: 332,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu bạn không khởi tạo một object bằng từ khóa `new`, giá trị của biến tham chiếu sẽ là gì?",
    options: ["0", "false", "null", "Một tham chiếu đến class Object"],
    answer: 2,
    explanation:
      "Nếu bạn không khởi tạo một object bằng từ khóa `new`, giá trị của nó sẽ được đặt là `null` [19, 53].",
  },
  {
    id: 333,
    topic: "Java Core",
    type: "radio",
    question: "Từ khóa `final` khi áp dụng cho một biến (field) có ý nghĩa gì?",
    options: [
      "Biến đó là hằng số, chỉ có thể được thiết lập một lần.",
      "Biến đó là static và được chia sẻ.",
      "Biến đó chỉ có thể được truy cập trong cùng package.",
      "Biến đó không thể là kiểu nguyên thủy.",
    ],
    answer: 0,
    explanation:
      "Một trường final là một biến hằng số, chỉ được thiết lập một lần và không được phép thay đổi [54, 55].",
  },
  {
    id: 334,
    topic: "Java Core",
    type: "radio",
    question:
      "Làm thế nào để phân biệt giữa hai object trỏ đến cùng một địa chỉ bộ nhớ (reference equality) trong Java?",
    options: [
      "Sử dụng phương thức `equals()`",
      "Sử dụng toán tử `==`",
      "Sử dụng phương thức `compareTo()`",
      "So sánh các fields của chúng.",
    ],
    answer: 1,
    explanation:
      "Toán tử `==` khi áp dụng cho các tham chiếu sẽ kiểm tra xem cả hai đối tượng có trỏ đến cùng một vị trí bộ nhớ hay không (reference comparison) [30, 56].",
  },
  {
    id: 335,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng gọi một phương thức trên một biến tham chiếu có giá trị là `null`?",
    options: [
      "Luôn trả về `false`.",
      "Tự động tạo một object mới.",
      "Ném ra ngoại lệ `NullPointerException` (Unchecked).",
      "Báo lỗi biên dịch.",
    ],
    answer: 2,
    explanation:
      "Việc cố gắng gọi phương thức trên một tham chiếu `null` sẽ dẫn đến `NullPointerException` [57-59].",
  },
  {
    id: 336,
    topic: "Java Core",
    type: "radio",
    question: "Các biến static (static variables) được khởi tạo khi nào?",
    options: [
      "Mỗi khi một object mới được tạo ra.",
      "Khi class được nạp (loaded) vào JVM.",
      "Mỗi khi phương thức `main()` được gọi.",
      "Khi Garbage Collector chạy.",
    ],
    answer: 1,
    explanation:
      "Biến static là biến cấp độ class [1] và được khởi tạo khi class được nạp vào JVM (Implicit knowledge based on Static Memory usage [1]).",
  },
  {
    id: 337,
    topic: "Java Core",
    type: "radio",
    question: "Lớp nào là lớp cha (superclass) của TẤT CẢ các lớp trong Java?",
    options: ["Class", "System", "Object", "Main"],
    answer: 2,
    explanation:
      "Mọi class trong Java đều là lớp con trực tiếp hoặc gián tiếp của class Object (java.lang.Object) [60].",
  },
  {
    id: 338,
    topic: "Java Core",
    type: "radio",
    question:
      "Khái niệm 'Variable Scope' (Phạm vi biến) liên quan mật thiết đến khu vực bộ nhớ nào?",
    options: [
      "Heap (vì objects sống ở đó).",
      "Stack (vì biến cục bộ và thông tin method sống ở đó).",
      "Static Memory.",
      "String Pool.",
    ],
    answer: 1,
    explanation:
      "Phạm vi biến cục bộ (Local variables) bị giới hạn và chúng chỉ sống chừng nào method còn trên Stack [61-63].",
  },
  {
    id: 339,
    topic: "Java Core",
    type: "radio",
    question: "Phần mở rộng tệp nào chứa bytecode độc lập nền tảng của Java?",
    options: [".java", ".class", ".jar", ".exe"],
    answer: 1,
    explanation: "Bytecode được lưu trong tệp có phần mở rộng .class [22, 23].",
  },
  {
    id: 340,
    topic: "Java Core",
    type: "radio",
    question: "Kiểu dữ liệu nguyên thủy `long` có kích thước là bao nhiêu?",
    options: ["8 bit", "16 bit", "32 bit", "64 bit"],
    answer: 3,
    explanation: "Kiểu `long` có kích thước 64 bit [16, 17, 64].",
  },
  {
    id: 341,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi sử dụng toán tử `==` để so sánh hai String literal (ví dụ: `"A" == "A"`), kết quả thường là gì?',
    options: ["true", "false", "Lỗi biên dịch", "NullPointerException"],
    answer: 0,
    explanation:
      "Vì các literal cùng trỏ đến cùng một object trong String Pool (trên Heap), nên so sánh tham chiếu trả về `true` [65, 66].",
  },
  {
    id: 342,
    topic: "Java Core",
    type: "radio",
    question: 'Khi nào một object được tạo ra bằng `new String("A")`?',
    options: [
      "Chỉ trong String Pool.",
      "Luôn luôn tạo một object mới trên Heap (ngoài String Pool).",
      "Chỉ trên Stack.",
      "Không bao giờ xảy ra.",
    ],
    answer: 1,
    explanation:
      "Sử dụng từ khóa `new` tạo ra một object mới trên Heap, ngay cả khi literal đó đã có trong String Pool [67-69].",
  },
  {
    id: 343,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong các lớp Wrapper được sử dụng để chuyển đổi ngược lại từ object Wrapper sang giá trị nguyên thủy?",
    options: [
      "parsePrimitive()",
      "unWrap()",
      "typeValue() (ví dụ: intValue())",
      "getPrimitive()",
    ],
    answer: 2,
    explanation:
      "Tất cả các lớp Wrapper đều có phương thức `typeValue()` (như `intValue()`) để trả về giá trị nguyên thủy của object [49, 70, 71].",
  },
  {
    id: 344,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra với các đối tượng trên Heap khi method chứa các biến tham chiếu cục bộ kết thúc?",
    options: [
      "Các object bị xóa ngay lập tức.",
      "Các object trở nên đủ điều kiện để GC nếu không còn tham chiếu nào khác trỏ đến chúng.",
      "Các object được chuyển sang Static Memory.",
      "Các object vẫn còn trên Heap vĩnh viễn.",
    ],
    answer: 1,
    explanation:
      "Khi method kết thúc, tham chiếu cục bộ trên Stack chết. Nếu đó là tham chiếu cuối cùng đến object trên Heap, object đó sẽ đủ điều kiện để GC [43, 72].",
  },
  {
    id: 345,
    topic: "Java Core",
    type: "radio",
    question: "Lớp nào sau đây không phải là một Lớp Wrapper?",
    options: ["Boolean", "String", "Character", "Float"],
    answer: 1,
    explanation:
      "String là một class, nhưng không phải là một Wrapper Class bọc kiểu nguyên thủy [73].",
  },
  {
    id: 346,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng từ khóa `this()` trong constructor là gì?",
    options: [
      "Tạo object mới.",
      "Gọi constructor của lớp cha.",
      "Gọi một constructor khác của chính class hiện tại.",
      "Thoát khỏi constructor.",
    ],
    answer: 2,
    explanation:
      "Sử dụng `this()` để gọi một constructor khác trong cùng class (constructor chaining) [74-76].",
  },
  {
    id: 347,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi nào thì lệnh gọi `this()` phải được đặt trong một constructor?",
    options: [
      "Phải là câu lệnh cuối cùng.",
      "Phải là câu lệnh đầu tiên.",
      "Nó có thể nằm ở bất cứ đâu.",
      "Chỉ được sử dụng trong default constructor.",
    ],
    answer: 1,
    explanation:
      "Lệnh gọi constructor `this()` phải là câu lệnh đầu tiên trong constructor [74].",
  },
  {
    id: 348,
    topic: "Java Core",
    type: "radio",
    question: "Kiểu dữ liệu nguyên thủy nào trong Java có kích thước 32 bit?",
    options: [
      "byte và short",
      "int và float",
      "long và double",
      "char và boolean",
    ],
    answer: 1,
    explanation: "Các kiểu `int` và `float` đều có kích thước 32 bit [15-17].",
  },
  {
    id: 349,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn không định nghĩa bất kỳ constructor nào trong class?",
    options: [
      "Lỗi biên dịch.",
      "Java tự động giả định có một constructor mặc định không tham số.",
      "Object không thể được tạo.",
      "Tất cả fields phải là static.",
    ],
    answer: 1,
    explanation:
      "Nếu không có constructor nào được định nghĩa, Java sẽ tự động cung cấp một default (empty) constructor [77-79].",
  },
  {
    id: 350,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ JVM, các đối tượng nào luôn được tạo trên Heap?",
    options: [
      "Các đối tượng được khai báo là static.",
      "Tất cả các đối tượng (objects).",
      "Chỉ các đối tượng được tạo trong phương thức `main()`.",
      "Chỉ các kiểu dữ liệu tham chiếu.",
    ],
    answer: 1,
    explanation:
      "Trong Java, tất cả các đối tượng (objects) được phân bổ động trên Heap [1, 3].",
  },
  {
    id: 351,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một mảng `int[] a` được tạo, các phần tử bên trong mảng này được lưu trữ dưới dạng gì?",
    options: [
      "Các tham chiếu trên Stack.",
      "Các giá trị nguyên thủy trên Stack.",
      "Các giá trị nguyên thủy trên Heap (vì mảng là object).",
      "Các đối tượng Wrapper trên Heap.",
    ],
    answer: 2,
    explanation:
      "Bản thân mảng là object trên Heap, và các giá trị nguyên thủy bên trong (int) được lưu trữ ngay trên Heap như một phần của cấu trúc mảng [24].",
  },
  {
    id: 352,
    topic: "Java Core",
    type: "radio",
    question: "JVM (Java Virtual Machine) được cài đặt như thế nào?",
    options: [
      "Chỉ dưới dạng phần cứng.",
      "Chỉ dưới dạng phần mềm.",
      "Thông thường được cài đặt dưới dạng phần mềm (JRE).",
      "Nó là một phần của hệ điều hành.",
    ],
    answer: 2,
    explanation:
      "JVM thường được triển khai dưới dạng phần mềm (JRE - Java Runtime Environment) [24, 25].",
  },
  {
    id: 353,
    topic: "Java Core",
    type: "radio",
    question: "Sử dụng từ khóa nào để ngăn một class bị kế thừa (inherited)?",
    options: ["abstract", "private", "final", "static"],
    answer: 2,
    explanation:
      "Class được khai báo là `final` không thể bị kế thừa [80, 81].",
  },
  {
    id: 354,
    topic: "Java Core",
    type: "radio",
    question:
      "Sử dụng từ khóa nào để ngăn một phương thức bị ghi đè (overridden) trong lớp con?",
    options: ["private", "protected", "final", "public"],
    answer: 2,
    explanation:
      "Phương thức được đánh dấu là `final` không thể bị ghi đè [81, 82].",
  },
  {
    id: 355,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu hai biến tham chiếu `String s1` và `String s2` được so sánh bằng `s1.equals(s2)`, điều này đang kiểm tra điều gì?",
    options: [
      "Chúng có trỏ đến cùng một địa chỉ bộ nhớ không.",
      "Nội dung của chuỗi có giống nhau không.",
      "Chúng có phải là hằng số không.",
      "Chúng có được tạo bằng literal không.",
    ],
    answer: 1,
    explanation:
      "Phương thức `equals()` được sử dụng để so sánh nội dung (content) của hai object, chứ không phải tham chiếu [13, 83].",
  },
  {
    id: 356,
    topic: "Java Core",
    type: "radio",
    question:
      "Loại dữ liệu nào KHÔNG phải là một kiểu nguyên thủy (primitive type) trong Java?",
    options: ["boolean", "char", "short", "String"],
    answer: 3,
    explanation: "String là một class, không phải primitive [13, 14].",
  },
  {
    id: 357,
    topic: "Java Core",
    type: "radio",
    question: "JVM tạo và khởi tạo đối tượng mới khi từ khóa nào được sử dụng?",
    options: ["class", "import", "new", "static"],
    answer: 2,
    explanation:
      "Toán tử `new` cấp phát bộ nhớ động (trên Heap) cho một đối tượng mới [18].",
  },
  {
    id: 358,
    topic: "Java Core",
    type: "radio",
    question: "JVM sử dụng cơ chế nào để tải và chạy các chương trình Java?",
    options: [
      "Phân tích cú pháp (Parsing).",
      "Trình dịch thuật (Translation).",
      "Nạp lớp (Class Loading) và thực thi phương thức `main()`.",
      "Biên dịch lại mã nguồn C++.",
    ],
    answer: 2,
    explanation:
      "Khi thực thi một chương trình Java, JVM nạp class và thực thi phương thức `main()` [52].",
  },
  {
    id: 359,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến được khai báo là `static final`, nó thường được gọi là gì?",
    options: [
      "Local Variable",
      "Instance Variable",
      "Hằng số (Constant)",
      "Object Reference",
    ],
    answer: 2,
    explanation: "Một biến `static final` là một hằng số (Constant) [84].",
  },
  {
    id: 360,
    topic: "Java Core",
    type: "radio",
    question: "Các tham số được truyền vào một phương thức được lưu trữ ở đâu?",
    options: [
      "Là biến cục bộ trên Stack.",
      "Là biến thể hiện trên Heap.",
      "Là biến static.",
      "Trong String Pool.",
    ],
    answer: 0,
    explanation:
      "Các tham số phương thức là biến cục bộ và sống trên Stack [5, 61, 85].",
  },
  {
    id: 361,
    topic: "Java Core",
    type: "radio",
    question: "Trong cấu trúc JVM, JRE (Java Runtime Environment) là gì?",
    options: [
      "Chỉ là trình biên dịch.",
      "Chỉ là JVM.",
      "JVM cộng với các thư viện API.",
      "Chỉ là mã nguồn.",
    ],
    answer: 2,
    explanation:
      "Java platform (thường được hiểu là JRE) là JVM cộng với các API (Application Programming Interfaces) [24].",
  },
  {
    id: 362,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào được sử dụng để lưu trữ giá trị true hoặc false?",
    options: ["char", "int", "boolean", "byte"],
    answer: 2,
    explanation:
      "Kiểu `boolean` chỉ có hai giá trị: true hoặc false [16, 17, 86].",
  },
  {
    id: 363,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng truy cập một phần tử mảng bằng một chỉ số không hợp lệ (ví dụ: chỉ số âm hoặc ngoài giới hạn)?",
    options: [
      "Giá trị `null` được trả về.",
      "Chương trình tự động tăng kích thước mảng.",
      "Java sinh ra ngoại lệ `ArrayIndexOutOfBoundsException`.",
      "Không có gì xảy ra.",
    ],
    answer: 2,
    explanation:
      "Sử dụng chỉ số mảng không hợp lệ (ngoài khoảng [0, a.length-1]) sẽ sinh ra ngoại lệ `ArrayIndexOutOfBoundsException` [87].",
  },
  {
    id: 364,
    topic: "Java Core",
    type: "radio",
    question:
      "Cơ chế nào trong Java giải quyết vấn đề quản lý bộ nhớ thủ công mà lập trình viên C/C++ phải đối mặt?",
    options: ["Serialization", "Garbage Collection", "Jini", "Networking"],
    answer: 1,
    explanation:
      "Garbage Collector giải phóng lập trình viên Java khỏi trách nhiệm hủy các đối tượng vô dụng [8, 88].",
  },
  {
    id: 365,
    topic: "Java Core",
    type: "radio",
    question:
      "Khu vực bộ nhớ nào trong JVM lưu trữ các tham chiếu đối tượng cục bộ (local object references)?",
    options: ["Heap", "Stack", "Static Memory", "String Pool"],
    answer: 1,
    explanation:
      "Nếu tham chiếu đối tượng được khai báo là biến cục bộ, bản thân tham chiếu (biến remote control) sẽ được lưu trữ trên Stack [6, 85].",
  },
  {
    id: 366,
    topic: "Java Core",
    type: "radio",
    question:
      "Làm thế nào để chuyển đổi một số thực `double` thành một số nguyên `int` trong Java, có khả năng mất thông tin?",
    options: [
      "Ép kiểu tự động (Automatic conversion).",
      "Ép kiểu rõ ràng (Explicit casting) `(int) variable`.",
      "Sử dụng Math.round() thôi.",
      "Sử dụng Integer.parseInt()",
      "Sử dụng `double.toInteger()`",
    ],
    answer: 1,
    explanation:
      "Java cung cấp ép kiểu rõ ràng (explicit casting) `(type) value` để chuyển đổi kiểu khi có khả năng mất thông tin, ví dụ như chuyển từ double sang int [89, 90].",
  },
  {
    id: 367,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, một hàm tạo (Constructor) có được phép có kiểu trả về không?",
    options: [
      "Có, kiểu trả về phải là `void`.",
      "Không, constructor không có kiểu trả về.",
      "Có, kiểu trả về phải là tên class.",
      "Chỉ khi nó là parameterized constructor.",
    ],
    answer: 1,
    explanation:
      "Constructor rất giống method, ngoại trừ việc chúng không có kiểu trả về (return types) [91].",
  },
  {
    id: 368,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích của việc sử dụng các phương thức `static` là gì?",
    options: [
      "Để truy cập các biến instance.",
      "Để tạo các method tiện ích không cần object (không cần state).",
      "Để thực hiện đa hình.",
      "Để đảm bảo phương thức không bị ghi đè.",
    ],
    answer: 1,
    explanation:
      "Phương thức static lý tưởng được sử dụng để tạo một phương thức không cần truy cập bất kỳ trường nào trong đối tượng (không có state) [92-94].",
  },
  {
    id: 369,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi sử dụng toán tử so sánh `==` giữa hai String được tạo bằng `new String("A")`, kết quả là gì?',
    options: ["true", "false", "Lỗi biên dịch", "NullPointerException"],
    answer: 1,
    explanation:
      "Vì `new` tạo ra hai object riêng biệt trên Heap, `==` so sánh tham chiếu và trả về `false` [56].",
  },
  {
    id: 370,
    topic: "Java Core",
    type: "radio",
    question:
      "Kỹ thuật nào chuyển đổi trạng thái của một object thành một byte stream để lưu vào tệp hoặc truyền qua mạng?",
    options: ["Encapsulation", "Polymorphism", "Serialization", "Inheritance"],
    answer: 2,
    explanation:
      "Serialization (Tuần tự hóa) được sử dụng để chuyển đổi trạng thái của một object thành một byte stream [95-97].",
  },
  {
    id: 371,
    topic: "Java Core",
    type: "radio",
    question:
      "Để làm cho một object có thể được tuần tự hóa, nó phải triển khai interface nào?",
    options: ["Runnable", "Comparable", "java.io.Serializable", "Cloneable"],
    answer: 2,
    explanation:
      "Object cần triển khai marker interface `java.io.Serializable` [95, 98].",
  },
  {
    id: 372,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong ngữ cảnh Garbage Collection, khi một tham chiếu đối tượng cục bộ chết (ví dụ: method kết thúc), điều gì xảy ra với bộ nhớ Stack liên quan đến method đó?",
    options: [
      "Nó được chuyển sang Heap.",
      "Nó được GC thu hồi.",
      "Khung ngăn xếp (stack frame) tương ứng của method đó bị bật ra khỏi Stack (popped off).",
      "Nó vẫn còn đó cho đến khi JVM tắt.",
    ],
    answer: 2,
    explanation:
      "Khi một method hoàn thành, khung ngăn xếp tương ứng của nó (chứa các biến cục bộ) bị bật ra khỏi Stack [99].",
  },
  {
    id: 373,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nào được sử dụng để lưu trữ các số nguyên có kích thước 8 bit (từ -128 đến 127)?",
    options: ["short", "int", "byte", "char"],
    answer: 2,
    explanation:
      "Kiểu `byte` có kích thước 8 bit và phạm vi từ -128 đến 127 [15, 16].",
  },
  {
    id: 374,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng từ khóa `transient` trong khai báo field (trường) là gì?",
    options: [
      "Để biến trường đó thành static.",
      "Để ngăn trường đó được tuần tự hóa (serialized).",
      "Để làm cho trường đó chỉ có thể truy cập bằng Getter.",
      "Để đảm bảo trường đó được lưu trên Stack.",
    ],
    answer: 1,
    explanation:
      "Từ khóa `transient` được sử dụng để loại trừ một trường khỏi quá trình tuần tự hóa [100].",
  },
  {
    id: 375,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi truyền một tham số kiểu nguyên thủy (ví dụ: `int`) vào một phương thức, điều gì được truyền đi?",
    options: [
      "Địa chỉ bộ nhớ của biến.",
      "Một bản sao của giá trị (bits).",
      "Toàn bộ object.",
      "Tham chiếu đến object Wrapper.",
    ],
    answer: 1,
    explanation:
      "Khi truyền kiểu nguyên thủy, Java truyền một bản sao của giá trị (pass-by-copy/pass-by-value) [30, 32, 101].",
  },
  {
    id: 376,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi truyền một tham số kiểu tham chiếu (ví dụ: `Object`) vào một phương thức, điều gì được truyền đi?",
    options: [
      "Một bản sao của toàn bộ object trên Heap.",
      "Địa chỉ vật lý của object.",
      "Một bản sao của tham chiếu (reference copy).",
      "Chỉ nội dung dữ liệu (fields).",
    ],
    answer: 2,
    explanation:
      "Khi truyền tham chiếu, Java tạo một bản sao của tham chiếu và truyền nó, nhưng bản sao này vẫn trỏ đến cùng object trên Heap [31, 102].",
  },
  {
    id: 377,
    topic: "Java Core",
    type: "radio",
    question: "Phạm vi của các biến cục bộ (Local variables) là gì?",
    options: [
      "Toàn bộ chương trình.",
      "Trong toàn bộ class.",
      "Chỉ tồn tại trong khối code hoặc method mà chúng được khai báo.",
      "Chỉ khi method đó là `static`.",
    ],
    answer: 2,
    explanation:
      "Biến cục bộ là tạm thời và chỉ sống chừng nào method/khối code còn trên Stack [61-63].",
  },
  {
    id: 378,
    topic: "Java Core",
    type: "radio",
    question:
      "Lớp nào trong Java API cung cấp các hằng số và phương thức toán học static như `PI` và `random()`?",
    options: ["System", "Object", "Math", "Console"],
    answer: 2,
    explanation:
      "Lớp `Math` cung cấp các phương thức và hằng số tĩnh (static) [66, 93, 103, 104].",
  },
  {
    id: 379,
    topic: "Java Core",
    type: "radio",
    question: "Sự khác biệt giữa `float` (32 bit) và `double` (64 bit) là gì?",
    options: [
      "Chỉ `double` có thể lưu số âm.",
      "Chỉ `float` là kiểu nguyên thủy.",
      "`double` có độ chính xác gấp đôi (double precision) so với `float`.",
      "`double` được lưu trên Stack, `float` trên Heap.",
    ],
    answer: 2,
    explanation:
      "Kiểu `double` được đưa vào với độ chính xác gấp đôi so với `float` [105, 106].",
  },
  {
    id: 380,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu hai class là `Dog` và `Animal`, và `Dog` kế thừa `Animal`, việc khai báo `Animal a = new Dog()` được gọi là gì?",
    options: ["Downcasting", "Unboxing", "Upcasting", "Polymorphism"],
    answer: 2,
    explanation:
      "Ép kiểu một đối tượng lớp con (Dog) thành kiểu lớp cha (Animal) được gọi là Upcasting, và nó được thực hiện tự động [107, 108].",
  },
  {
    id: 381,
    topic: "Java Core",
    type: "radio",
    question:
      "Việc sử dụng toán tử `==` trên hai tham chiếu object (không phải String literal) kiểm tra điều gì?",
    options: [
      "Trạng thái (state) của chúng.",
      "Hành vi (behavior) của chúng.",
      "Tham chiếu có cùng địa chỉ trên Heap không.",
      "Sự đa hình.",
    ],
    answer: 2,
    explanation:
      "Toán tử `==` dùng cho tham chiếu kiểm tra xem chúng có trỏ đến cùng một object trên Heap hay không [30, 56, 109].",
  },
  {
    id: 382,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích của việc sử dụng Lớp Wrapper `Integer` là gì?",
    options: [
      "Để tăng tốc độ tính toán số nguyên.",
      "Để lưu trữ các giá trị `int` trong các Collections (chỉ chứa object).",
      "Để ngăn `int` bị thay đổi.",
      "Để lưu trữ `int` trên Stack.",
    ],
    answer: 1,
    explanation:
      "Các Collection (như ArrayList) chỉ lưu trữ object, không phải primitives. Wrapper classes cho phép lưu trữ primitives như object để sử dụng trong Collection [34, 110, 111].",
  },
  {
    id: 383,
    topic: "Java Core",
    type: "radio",
    question:
      "Khu vực bộ nhớ nào bị ảnh hưởng khi một ngoại lệ (Exception) xảy ra và tạo ra một Stack Trace?",
    options: ["Heap", "String Pool", "Static Memory", "Stack"],
    answer: 3,
    explanation:
      "Stack Trace (dấu vết ngăn xếp) là danh sách các phương thức đã được gọi, được lưu trữ trên Stack [112, 113].",
  },
  {
    id: 384,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình OOP, khái niệm nào gói gọn dữ liệu (fields) và hành vi (methods) thành một đơn vị?",
    options: ["Polymorphism", "Encapsulation", "Inheritance", "Abstraction"],
    answer: 1,
    explanation:
      "Encapsulation (Đóng gói) là việc gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng) [114, 115].",
  },
  {
    id: 385,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi khai báo một String bằng literal (ví dụ: `String s = "Hello";`), String này được lưu trữ ở đâu?',
    options: [
      "Trên Stack.",
      "Trực tiếp trên Heap, ngoài String Pool.",
      "Trong String Pool (trên Heap).",
      "Trong Static Memory.",
    ],
    answer: 2,
    explanation:
      "String literals được lưu trữ trong String Pool (một khu vực đặc biệt trên Heap) [44, 45].",
  },
  {
    id: 386,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong ngôn ngữ Java, phép toán nào sau đây không được phép trên một biến tham chiếu object?",
    options: [
      "Gán tham chiếu mới (`ref = new Object();`)",
      "Gọi method (`ref.method();`)",
      "So sánh tham chiếu (`ref1 == ref2`)",
      "Thực hiện phép toán số học (`ref++`)",
    ],
    answer: 3,
    explanation:
      "Không thể thực hiện phép toán số học (arithmetic) trên biến tham chiếu object [26].",
  },
  {
    id: 387,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích chính của Java Development Kit (JDK) là gì?",
    options: [
      "Chỉ để chạy chương trình Java.",
      "Cung cấp môi trường phát triển ứng dụng Java (bao gồm Compiler, JVM, tools).",
      "Chỉ là một thư viện API.",
      "Chỉ để gỡ lỗi (debugging).",
    ],
    answer: 1,
    explanation:
      "JDK là môi trường phát triển ứng dụng Java, bao gồm compiler (`javac`), interpreter (`java`), debugger (`jdb`), v.v. [52].",
  },
  {
    id: 388,
    topic: "Java Core",
    type: "radio",
    question:
      "Khái niệm đa tải phương thức (Method Overloading) được xác định bởi yếu tố nào?",
    options: [
      "Kiểu trả về.",
      "Tên phương thức.",
      "Danh sách tham số (số lượng, kiểu, thứ tự).",
      "Access modifier.",
    ],
    answer: 2,
    explanation:
      "Method Overloading cho phép nhiều method có cùng tên, nhưng danh sách tham số của chúng phải khác nhau [20, 116].",
  },
  {
    id: 389,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong ngữ cảnh Garbage Collection, nếu bạn đặt tham chiếu object cục bộ thành `null`, điều gì xảy ra?",
    options: [
      "Object bị xóa ngay lập tức.",
      "Tham chiếu bị 'deprogrammed', và object trở nên eligible cho GC nếu không còn tham chiếu nào khác.",
      "Object được chuyển sang String Pool.",
      "Heap Memory tăng lên.",
    ],
    answer: 1,
    explanation:
      "Thiết lập tham chiếu thành `null` (de-programming) là một cách để làm cho object trở nên abandoned và đủ điều kiện để GC [8, 43].",
  },
  {
    id: 390,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về kiểu dữ liệu nguyên thủy `boolean`?",
    options: [
      "Nó được phép ép kiểu thành int.",
      "Nó là kiểu dữ liệu có thể chứa true hoặc false.",
      "Nó có kích thước 1 bit.",
      "Nó được lưu trên Heap.",
    ],
    answer: 1,
    explanation:
      "Boolean là một kiểu nguyên thủy [17, 117] và chỉ chứa `true` hoặc `false` [16, 86]. Tuy nhiên, trong Java, boolean và integer không tương thích [118].",
  },
  {
    id: 391,
    topic: "Java Core",
    type: "code",
    question: "Trong đoạn mã sau, biến `i` và `t` được lưu trữ ở đâu?",
    code: "public void myMethod() { int i = 5; Test t = new Test(); }",
    options: [
      "i trên Heap, t trên Stack.",
      "i và t đều trên Heap.",
      "i và t đều là biến cục bộ, lưu trên Stack.",
      "i trên Stack, t trên Heap.",
    ],
    answer: 2,
    explanation:
      "Cả `i` (primitive local variable) và `t` (reference local variable) đều là biến cục bộ được khai báo bên trong method, vì vậy chúng sống trên Stack. (Lưu ý: object `new Test()` mà `t` trỏ tới nằm trên Heap) [1, 5, 6, 61].",
  },
  {
    id: 392,
    topic: "Java Core",
    type: "radio",
    question:
      "Lớp nào là lớp phổ biến nhất triển khai giao diện `List` và sử dụng mảng nội bộ?",
    options: ["LinkedList", "HashMap", "ArrayList", "Stack"],
    answer: 2,
    explanation:
      "ArrayList là class phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ [119].",
  },
  {
    id: 393,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các tham số kiểu bị giới hạn (Bounded Type Parameters) trong Generics là gì?",
    options: [
      "Chỉ để hạn chế class được phép là interface.",
      "Để chỉ định rằng tham số kiểu phải là kiểu con của một kiểu BoundingType.",
      "Để cho phép mọi kiểu dữ liệu.",
      "Để ngăn ClassCastException.",
    ],
    answer: 1,
    explanation:
      "Cú pháp `<T extends BoundingType>` chỉ định rằng T phải là kiểu con của BoundingType [1, 120].",
  },
  {
    id: 394,
    topic: "Java Core",
    type: "radio",
    question:
      "JVM (Java Virtual Machine) làm gì với bytecode trước khi thực thi nó?",
    options: [
      "Biên dịch nó thành mã C++.",
      "Thông dịch (interpret) nó thành mã máy (machine code).",
      "Gửi nó đến trình biên dịch JIT (Just-In-Time Compiler).",
      "Lưu trữ nó trên Stack.",
    ],
    answer: 1,
    explanation:
      "JVM đọc và chạy bytecode (thông qua interpreter hoặc JIT) [24, 25].",
  },
  {
    id: 395,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi hai biến nguyên thủy (ví dụ: `int a = 5; int b = 5;`) được so sánh bằng `a == b`, điều gì đang được kiểm tra?",
    options: [
      "Tham chiếu bộ nhớ.",
      "Giá trị (content) của chúng.",
      "Tính đồng bộ.",
      "Ép kiểu lên.",
    ],
    answer: 1,
    explanation:
      "Toán tử `==` dùng cho kiểu nguyên thủy kiểm tra giá trị của chúng [30, 121].",
  },
  {
    id: 396,
    topic: "Java Core",
    type: "radio",
    question:
      "Các lỗi cú pháp (Syntax errors) thường được phát hiện bởi thành phần nào?",
    options: [
      "Garbage Collector.",
      "JVM tại runtime.",
      "Java Compiler tại compile time.",
      "Trình thông dịch (Interpreter) tại runtime.",
    ],
    answer: 2,
    explanation:
      "Các lỗi cú pháp là sự vi phạm các quy tắc ngữ pháp của Java và khiến code không thể biên dịch [122, 123].",
  },
  {
    id: 397,
    topic: "Java Core",
    type: "radio",
    question:
      "Đâu là đặc điểm của lập trình hướng đối tượng (OOP) so với lập trình thủ tục (Procedural Programming)?",
    options: [
      "Tập trung vào các function độc lập.",
      "Thiết kế code để mô phỏng các đối tượng thế giới thực.",
      "Tập trung vào luồng dữ liệu.",
      "Chỉ sử dụng các kiểu dữ liệu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "OOP được thiết kế để mô phỏng các đối tượng trong thế giới thực và cách chúng hoạt động [47, 124].",
  },
  {
    id: 398,
    topic: "Java Core",
    type: "radio",
    question: "Sự khác biệt giữa `String` và `StringBuffer` là gì?",
    options: [
      "`String` có thể sửa đổi, `StringBuffer` thì không.",
      "`String` là object, `StringBuffer` là primitive.",
      "`String` không thể sửa đổi, `StringBuffer` thì có thể sửa đổi.",
      "`StringBuffer` được lưu trên Stack.",
    ],
    answer: 2,
    explanation:
      "String là chuỗi ký tự không thể sửa đổi (unmodifiable), còn StringBuffer là chuỗi ký tự có thể sửa đổi (modifiable) [125-128].",
  },
  {
    id: 399,
    topic: "Java Core",
    type: "radio",
    question: "Trong I/O Stream, một 'stream' được định nghĩa là một chuỗi gì?",
    options: ["Ký tự.", "Dữ liệu.", "Files.", "References."],
    answer: 1,
    explanation: "Stream là một chuỗi dữ liệu (sequence of data) [129, 130].",
  },
  {
    id: 400,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy `char` có kích thước 16 bit vì nó sử dụng bảng mã nào?",
    options: ["ASCII", "UTF-8", "Unicode", "ISO-8859"],
    answer: 2,
    explanation: "Kiểu `char` 16 bit biểu diễn một ký tự Unicode [16, 131].",
  },
  {
    id: 401,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi bạn khai báo một biến `static` trong class, nó thuộc về cái gì?",
    options: [
      "Từng object riêng lẻ.",
      "Toàn bộ class.",
      "Chỉ phương thức `main()`.",
      "Chỉ constructor.",
    ],
    answer: 1,
    explanation:
      "Biến `static` được lưu trữ trong class và được chia sẻ bởi tất cả các object của class đó [132-134].",
  },
  {
    id: 402,
    topic: "Java Core",
    type: "radio",
    question:
      "Cơ chế nào được sử dụng để che giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết cho người dùng?",
    options: ["Inheritance", "Encapsulation", "Abstraction", "Polymorphism"],
    answer: 2,
    explanation:
      "Abstraction (Trừu tượng) là cơ chế ẩn giấu chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết [135, 136].",
  },
  {
    id: 403,
    topic: "Java Core",
    type: "radio",
    question:
      "Việc ghi đè phương thức (Method Overriding) liên quan đến tính chất nào của OOP?",
    options: ["Encapsulation", "Inheritance", "Abstraction", "Static context"],
    answer: 1,
    explanation:
      "Method Overriding là một khái niệm cơ bản của Inheritance, cho phép lớp con định nghĩa lại hành vi của lớp cha [137-139].",
  },
  {
    id: 404,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về kiểu dữ liệu nguyên thủy `int`?",
    options: [
      "Kích thước 8 bit.",
      "Kích thước 64 bit.",
      "Kích thước 32 bit.",
      "Không thể là số âm.",
    ],
    answer: 2,
    explanation: "Kiểu `int` có kích thước 32 bit [15, 16, 140].",
  },
  {
    id: 405,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến được khai báo bên trong khối `if` statement, phạm vi của biến đó là gì?",
    options: [
      "Toàn bộ method chứa khối `if`.",
      "Chỉ bên trong khối `if` đó (Block Scope).",
      "Toàn bộ class.",
      "Nó trở thành biến `static`.",
    ],
    answer: 1,
    explanation:
      "Biến chỉ tồn tại trong khối code (Block) mà nó được khai báo [63, 141].",
  },
  {
    id: 406,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong cơ chế GC, nếu một object bị mất tất cả các reference trỏ đến nó, nó được gọi là gì?",
    options: [
      "Garbage",
      "Dead Object",
      "Abandoned (Bị bỏ rơi) hoặc Unreachable",
      "Null Object",
    ],
    answer: 2,
    explanation:
      "Object không còn tham chiếu nào trỏ tới được gọi là Abandoned hoặc Unreachable, và trở nên đủ điều kiện để GC [8, 9, 43].",
  },
  {
    id: 407,
    topic: "Java Core",
    type: "radio",
    question:
      "Lớp nào được sử dụng để đọc primitive data types một cách tuần tự từ file (Sequential access text file)?",
    options: [
      "FileReader",
      "BufferedReader",
      "DataInputStream",
      "ObjectInputStream",
    ],
    answer: 2,
    explanation:
      "DataInputStream được sử dụng để đọc dữ liệu của các kiểu dữ liệu nguyên thủy một cách tuần tự [142].",
  },
  {
    id: 408,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là SAI về Constructor?",
    options: [
      "Phải có cùng tên với class.",
      "Không có kiểu trả về.",
      "Có thể có nhiều constructor (overloaded).",
      "Có thể được gọi bằng toán tử `.` (dot operator).",
    ],
    answer: 3,
    explanation: "Constructor không thể được gọi bằng toán tử `.` [143].",
  },
  {
    id: 409,
    topic: "Java Core",
    type: "radio",
    question:
      "Loại lỗi nào xảy ra khi chương trình chạy nhưng không cho kết quả như mong đợi (lỗi logic)?",
    options: [
      "Compile-time error",
      "Runtime error",
      "Syntax error",
      "Bug (Logical error)",
    ],
    answer: 3,
    explanation:
      "Lỗi logic (Bug) là khi chương trình không thực hiện những gì bạn mong đợi, thường là lỗi khó tìm [122, 123].",
  },
  {
    id: 410,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình Generics, điều gì giải quyết vấn đề cần phải ép kiểu (casting) liên tục khi sử dụng `Object`?",
    options: [
      "Sử dụng `static`.",
      "Generics loại bỏ nhu cầu ép kiểu.",
      "Sử dụng `final`.",
      "Autoboxing.",
    ],
    answer: 1,
    explanation:
      "Generics giúp loại bỏ nhu cầu ép kiểu và cung cấp cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch [144, 145].",
  },
  {
    id: 411,
    topic: "Java Core",
    type: "radio",
    question: "Toán tử `new` làm gì sau khi cấp phát bộ nhớ?",
    options: [
      "Trả về địa chỉ bộ nhớ.",
      "Gọi constructor để khởi tạo object mới.",
      "Gọi Garbage Collector.",
      "Tự động khai báo object là `public`.",
    ],
    answer: 1,
    explanation:
      "Theo sau toán tử `new` là constructor của class, chịu trách nhiệm khởi tạo object mới [28].",
  },
  {
    id: 412,
    topic: "Java Core",
    type: "radio",
    question:
      "Lớp nào là lớp gốc trong hệ thống phân cấp Ngoại lệ (Exception Hierarchy) trong Java?",
    options: ["Error", "Throwable", "RuntimeException", "Object"],
    answer: 1,
    explanation:
      "Throwable là lớp gốc cho toàn bộ hệ thống phân cấp ngoại lệ (Error và Exception) (Implicitly based on context and common knowledge of Java hierarchy that Throwable is top-level for errors/exceptions).",
  },
  {
    id: 413,
    topic: "Java Core",
    type: "radio",
    question: "Đâu là một ví dụ của Unchecked Exception (Runtime Exception)?",
    options: [
      "IOException",
      "FileNotFoundException",
      "NullPointerException",
      "SQLException",
    ],
    answer: 2,
    explanation:
      "NullPointerException, ArithmeticException là ví dụ điển hình của Unchecked Exceptions (Runtime Exception) [58, 59, 146].",
  },
  {
    id: 414,
    topic: "Java Core",
    type: "radio",
    question:
      "Ngoại lệ nào (Exception) được kiểm tra tại thời điểm biên dịch (compile time)?",
    options: [
      "Unchecked Exceptions.",
      "Checked Exceptions.",
      "Error.",
      "Runtime Exceptions.",
    ],
    answer: 1,
    explanation:
      "Checked Exceptions là các ngoại lệ được kiểm tra ở thời điểm biên dịch, buộc lập trình viên phải xử lý hoặc khai báo chúng [147, 148].",
  },
  {
    id: 415,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về khối lệnh `finally` trong xử lý ngoại lệ?",
    options: [
      "Nó chỉ chạy nếu không có ngoại lệ nào xảy ra.",
      "Nó chỉ chạy nếu ngoại lệ xảy ra.",
      "Nó luôn được thực thi sau `try`, bất kể có ngoại lệ hay không.",
      "Nó chỉ được sử dụng với Unchecked Exceptions.",
    ],
    answer: 2,
    explanation:
      "Khối `finally` luôn được thực thi sau khi khối `try` hoàn thành, bất kể có ngoại lệ xảy ra hay không [116, 148].",
  },
  {
    id: 416,
    topic: "Java Core",
    type: "radio",
    question:
      "Từ khóa `throws` trong khai báo phương thức được sử dụng để làm gì?",
    options: [
      "Định nghĩa lỗi logic.",
      "Ném ra một ngoại lệ mới.",
      "Thông báo rằng phương thức có thể ném ra một ngoại lệ Checked.",
      "Khởi tạo object.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `throws` được sử dụng để chỉ định ngoại lệ mà phương thức có thể ném ra (throw) [59, 149, 150].",
  },
  {
    id: 417,
    topic: "Java Core",
    type: "radio",
    question:
      "Để tạo ra một ngoại lệ do người dùng tự định nghĩa (User-defined exception), class mới phải kế thừa class nào?",
    options: ["RuntimeException", "Throwable", "Error", "Exception"],
    answer: 3,
    explanation:
      "Tất cả các ngoại lệ đều là lớp con của class Exception [151, 152].",
  },
  {
    id: 418,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn không xử lý (handle) hoặc khai báo (declare) một Checked Exception trong method?",
    options: [
      "Chương trình chạy bình thường.",
      "Lỗi biên dịch (Compile error).",
      "Lỗi runtime.",
      "JVM tự động chạy Garbage Collector.",
    ],
    answer: 1,
    explanation:
      "Nếu một phương thức ném ra checked exception, nó phải xử lý hoặc chỉ định ngoại lệ đó bằng từ khóa `throws`, nếu không sẽ bị lỗi biên dịch [147, 149].",
  },
  {
    id: 419,
    topic: "Java Core",
    type: "radio",
    question:
      "Loại I/O Stream nào được khuyên dùng khi tệp chứa dữ liệu ký tự?",
    options: [
      "Byte streams",
      "Character streams",
      "RandomAccessFile",
      "DataInputStream",
    ],
    answer: 1,
    explanation:
      "Khi tệp chứa dữ liệu ký tự, nên sử dụng character streams [153].",
  },
  {
    id: 420,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của Lớp Wrapper là chuyển đổi kiểu nguyên thủy sang Object. Ngược lại, phương thức nào được dùng để chuyển Object Wrapper sang String?",
    options: [
      "parseString()",
      "toString()",
      "getStringValue()",
      "ConvertToString()",
    ],
    answer: 1,
    explanation:
      "Phương thức `toString()` được kế thừa từ lớp `Object` và được các lớp Wrapper sử dụng để trả về biểu diễn văn bản của object [34].",
  },
  {
    id: 421,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ, phương thức `main()` được đặt ở đâu khi chương trình bắt đầu chạy?",
    options: [
      "Dưới đáy Heap.",
      "Trong String Pool.",
      "Dưới đáy Stack (main thread).",
      "Trong Static Memory.",
    ],
    answer: 2,
    explanation:
      "Mỗi ứng dụng Java bắt đầu một main thread, thread này đặt phương thức `main()` ở dưới đáy Stack [154].",
  },
  {
    id: 422,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về Java array length (chiều dài mảng)?",
    options: [
      "Nó là một method.",
      "Nó là một trường có thể thay đổi.",
      "Nó là một thuộc tính có thể truy cập (ví dụ: `a.length`) và cố định.",
      "Nó chỉ có thể được tìm thấy trong Array List.",
    ],
    answer: 2,
    explanation:
      "Kích thước (length) của mảng đã cố định khi tạo [155], và có thể truy xuất bằng `a.length` [73, 156].",
  },
  {
    id: 423,
    topic: "Java Core",
    type: "radio",
    question:
      "Khu vực bộ nhớ nào được cấp phát cho một object khi sử dụng từ khóa `new`?",
    options: ["Static Memory.", "Heap Memory.", "Stack Memory.", "ROM."],
    answer: 1,
    explanation: "Toán tử `new` cấp phát bộ nhớ động trên Heap [18].",
  },
  {
    id: 424,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu `MyDate d` được khai báo mà không sử dụng `new`, thì `d` được lưu trữ ở đâu?",
    options: ["Heap.", "Stack.", "Static Memory.", "String Pool."],
    answer: 1,
    explanation:
      "Nếu `d` là biến cục bộ, bản thân biến tham chiếu `d` (lúc này là `null`) sống trên Stack [6, 30].",
  },
  {
    id: 425,
    topic: "Java Core",
    type: "radio",
    question: "Khái niệm đa hình (Polymorphism) liên quan đến điều gì?",
    options: [
      "Khả năng đối tượng có nhiều hình thức (multiple shapes or forms).",
      "Khả năng gói gọn dữ liệu.",
      "Khả năng kế thừa.",
      "Khả năng không được khởi tạo.",
    ],
    answer: 0,
    explanation:
      "Polymorphism đề cập đến khả năng của một thực thể duy nhất có thể mang nhiều hình thức [157, 158].",
  },
  {
    id: 426,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Generics, kiểu Wildcard không giới hạn (`<?>`) có ý nghĩa gì khi dùng với List?",
    options: [
      "List chỉ chứa kiểu String.",
      "List chỉ chứa kiểu Object.",
      "List chứa các phần tử của bất kỳ kiểu nào (Unknown Type).",
      "List không thể chứa phần tử nào.",
    ],
    answer: 2,
    explanation:
      "Wildcard không giới hạn `List<?>` là một method chấp nhận một list thuộc bất kỳ kiểu nào [120, 159].",
  },
  {
    id: 427,
    topic: "Java Core",
    type: "radio",
    question:
      "Sử dụng từ khóa nào để chỉ rõ một tham số kiểu T trong Generics phải là kiểu con của một class hoặc interface?",
    options: ["implements", "extends", "super", "this"],
    answer: 1,
    explanation:
      "Cú pháp `<T extends BoundingType>` được dùng để chỉ định T là kiểu con [120, 125].",
  },
  {
    id: 428,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi Java thực hiện phép gán `a = b` cho hai mảng (a và b là tham chiếu mảng), điều gì xảy ra?",
    options: [
      "Tất cả các phần tử của b được sao chép vào a.",
      "Cả hai tham chiếu a và b trỏ đến object mảng gốc của b.",
      "Mảng gốc của a bị xóa.",
      "Mảng gốc của b bị xóa.",
    ],
    answer: 1,
    explanation:
      "Vì mảng là object, phép gán giữa các tham chiếu làm cho cả hai trỏ đến cùng một object [28, 29, 47].",
  },
  {
    id: 429,
    topic: "Java Core",
    type: "radio",
    question:
      "JVM tạo ra những gì khi một ngoại lệ xảy ra trong một phương thức?",
    options: [
      "Một Stack Trace rỗng.",
      "Một luồng mới (new thread).",
      "Một Object Ngoại lệ (Exception Object).",
      "Một file log.",
    ],
    answer: 2,
    explanation:
      "Khi một ngoại lệ xảy ra, method tạo ra một Object Ngoại lệ và chuyển nó cho hệ thống runtime (JVM) [160].",
  },
  {
    id: 430,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc khai báo `private` cho fields (trường) trong Encapsulation là gì?",
    options: [
      "Để ngăn class con kế thừa chúng.",
      "Để ẩn thông tin (Information Hiding) và bảo vệ dữ liệu khỏi truy cập trực tiếp/thay đổi không phù hợp.",
      "Để tối ưu hóa bộ nhớ.",
      "Để làm cho constructor là `final`.",
    ],
    answer: 1,
    explanation:
      "Khai báo fields là `private` là thực hành tốt để che giấu thông tin và kiểm soát truy cập dữ liệu [49, 161-163].",
  },
  {
    id: 431,
    topic: "Java Core",
    type: "radio",
    question: "Sự khác biệt giữa Error và Exception là gì?",
    options: [
      "Error là các vấn đề nghiêm trọng mà ứng dụng không nên xử lý, Exception là điều kiện có thể xử lý.",
      "Error là Checked, Exception là Unchecked.",
      "Error xảy ra ở Compile time, Exception xảy ra ở Runtime.",
      "Không có sự khác biệt.",
    ],
    answer: 0,
    explanation:
      "Error đại diện cho vấn đề nghiêm trọng mà ứng dụng không nên cố gắng xử lý. Exception là điều kiện mà ứng dụng có thể xử lý [164].",
  },
  {
    id: 432,
    topic: "Java Core",
    type: "radio",
    question:
      "Loại I/O Stream nào được sử dụng để đọc và ghi dữ liệu vào một tệp một cách ngẫu nhiên (randomly)?",
    options: [
      "FileInputStream",
      "BufferedReader",
      "RandomAccessFile",
      "ObjectInputStream",
    ],
    answer: 2,
    explanation:
      "RandomAccessFile là một class độc lập, hỗ trợ đọc và ghi dữ liệu vào tệp một cách ngẫu nhiên, yêu cầu kích thước bản ghi cố định [165].",
  },
  {
    id: 433,
    topic: "Java Core",
    type: "radio",
    question: "Mô tả nào sau đây về Generics là chính xác?",
    options: [
      "Các tham số method chấp nhận giá trị, các tham số kiểu (type parameters) chấp nhận kiểu (classes, interface).",
      "Generics chỉ áp dụng cho Collections.",
      "Generics thay thế hoàn toàn nhu cầu về Polymorphism.",
      "Generics được giới thiệu trong JDK 1.0.",
    ],
    answer: 0,
    explanation:
      "Tham số method chấp nhận giá trị, còn tham số kiểu chấp nhận kiểu (classes, interface) [166]. Generics được giới thiệu trong JDK 5.0 [166, 167].",
  },
  {
    id: 434,
    topic: "Java Core",
    type: "radio",
    question:
      "Thành phần nào là điểm khởi đầu thực tế khi chạy một chương trình Java?",
    options: ["Constructor", "main() method", "System.out.println()", "JVM"],
    answer: 1,
    explanation:
      "Điểm khởi đầu cho một chương trình là phương thức main() [14, 168, 169].",
  },
  {
    id: 435,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi JVM tìm kiếm một Exception Handler, nó duyệt qua Call Stack theo thứ tự nào?",
    options: [
      "Thứ tự các method được gọi.",
      "Thứ tự ngược lại (reverse order) với thứ tự các method được gọi.",
      "Ngẫu nhiên.",
      "Chỉ method `main()`.",
    ],
    answer: 1,
    explanation:
      "JVM bắt đầu tìm kiếm từ method xảy ra exception, tiến hành qua Call Stack theo thứ tự ngược lại với thứ tự các method được gọi [112].",
  },
  {
    id: 436,
    topic: "Java Core",
    type: "radio",
    question:
      "Java sử dụng tiêu chuẩn nào để biểu diễn các số thực (float, double)?",
    options: [
      "Phép bù 2 (Two's Complement).",
      "Chuẩn IEEE (IEEE standard).",
      "Hệ thập phân.",
      "Hệ thập lục phân.",
    ],
    answer: 1,
    explanation:
      "Java biểu diễn số thực `double` bằng cách sử dụng chuẩn IEEE [170].",
  },
  {
    id: 437,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các Lớp Wrapper (Wrapper Classes) là gì?",
    options: [
      "Chỉ để lưu trữ String.",
      "Gói gọn kiểu dữ liệu nguyên thủy để chúng hành động như Object.",
      "Để tạo ra các hằng số.",
      "Để thực hiện Inheritance.",
    ],
    answer: 1,
    explanation:
      "Wrapper class gói gọn kiểu dữ liệu nguyên thủy, mang lại vẻ ngoài của object để có thể sử dụng các tính năng object-oriented [34, 35, 37].",
  },
  {
    id: 438,
    topic: "Java Core",
    type: "radio",
    question: "Phép toán `Integer.parseInt(s)` thuộc về class nào?",
    options: ["String", "System", "int", "Integer"],
    answer: 3,
    explanation:
      "Phương thức `parseInt()` là một phương thức static của lớp Wrapper `Integer` [49-51].",
  },
  {
    id: 439,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu lớp `A` và lớp `B` đều có thể bắt cùng một loại ngoại lệ, lớp nào phải được bắt trước?",
    options: [
      "Lớp cha (Base class).",
      "Lớp con (Derived class).",
      "Thứ tự không quan trọng.",
      "Cả hai đều không thể bắt cùng một lúc.",
    ],
    answer: 1,
    explanation:
      "Nếu cả lớp cơ sở và lớp dẫn xuất đều được bắt, catch block của lớp dẫn xuất phải xuất hiện trước lớp cơ sở [171].",
  },
  {
    id: 440,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong cú pháp Generics, điều gì xảy ra nếu bạn cố gắng tạo mối quan hệ kế thừa giữa hai kiểu generic khác nhau, ví dụ: `Pair<Animal>` và `Pair<Cat>`?",
    options: [
      "Mối quan hệ kế thừa được thiết lập.",
      "Không có mối quan hệ kế thừa nào giữa hai kiểu này.",
      "Lỗi runtime.",
      "Cần sử dụng Wildcard.",
    ],
    answer: 1,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau, ngay cả khi các tham số kiểu có quan hệ kế thừa [172, 173].",
  },
  {
    id: 441,
    topic: "Java Core",
    type: "radio",
    question:
      "Cấu trúc dữ liệu nào trong Java Collections Framework được thiết kế để tăng tốc quá trình tìm kiếm bằng cách sử dụng key?",
    options: ["ArrayList", "Stack", "HashMap", "Queue"],
    answer: 2,
    explanation:
      "HashMap được giới thiệu để tăng tốc quá trình tìm kiếm bằng cách liên kết mỗi mục với một key duy nhất [174-176].",
  },
  {
    id: 442,
    topic: "Java Core",
    type: "radio",
    question:
      "Nguyên tắc LIFO (Last-In, First-Out) được áp dụng cho cấu trúc dữ liệu nào?",
    options: ["Queue", "List", "Stack", "Array"],
    answer: 2,
    explanation:
      "Collection Stack đại diện cho một stack đối tượng kiểu Last-in, first-out (LIFO) [177, 178].",
  },
  {
    id: 443,
    topic: "Java Core",
    type: "radio",
    question:
      "Nguyên tắc FIFO (First-In, First-Out) được áp dụng cho cấu trúc dữ liệu nào?",
    options: ["Stack", "Queue", "HashMap", "Set"],
    answer: 1,
    explanation: "Queue là cấu trúc dữ liệu First-In, First-Out (FIFO) [179].",
  },
  {
    id: 444,
    topic: "Java Core",
    type: "radio",
    question: "Phương thức nào được sử dụng để lấy và xóa phần tử ở đầu Queue?",
    options: ["push()", "pop()", "poll()", "get(0)"],
    answer: 2,
    explanation:
      "Phương thức `poll()` được Queue interface định nghĩa để lấy và xóa phần tử ở đầu queue [180].",
  },
  {
    id: 445,
    topic: "Java Core",
    type: "radio",
    question:
      "Giao diện nào cho phép bạn duyệt qua một collection và xóa các phần tử trong khi duyệt?",
    options: ["Comparable", "Serializable", "Iterator", "Cloneable"],
    answer: 2,
    explanation:
      "Iterator cho phép chương trình duyệt qua collection và xóa các phần tử trong khi lặp [181-183].",
  },
  {
    id: 446,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì là đúng về các trường (fields) trong một interface (trước JDK 8)?",
    options: [
      "Chúng có thể là private.",
      "Chúng ngầm định là public, static, và final.",
      "Chúng phải được khởi tạo bằng constructor.",
      "Chúng là biến instance.",
    ],
    answer: 1,
    explanation:
      "Tất cả các trường trong một interface đều ngầm định là public, static, final [184].",
  },
  {
    id: 447,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về các phương thức trong một Abstract Class?",
    options: [
      "Chúng chỉ có thể là abstract.",
      "Chúng có thể là abstract hoặc concrete (có thân hàm).",
      "Chúng không thể có access modifier.",
      "Chúng phải là static.",
    ],
    answer: 1,
    explanation:
      "Abstract Class có thể chứa các phương thức abstract hoặc các phương thức concrete [135].",
  },
  {
    id: 448,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì là bắt buộc đối với một phương thức được khai báo là `abstract`?",
    options: [
      "Nó phải được định nghĩa trong class cha.",
      "Nó phải được gọi bằng từ khóa `super`.",
      "Nó không có thân hàm (implementation) và phải được ghi đè bởi class con concrete.",
      "Nó phải là `private`.",
    ],
    answer: 2,
    explanation:
      "Phương thức abstract không có thân hàm, chỉ có chữ ký phương thức, và phải được triển khai (implement) trong class con concrete [135].",
  },
  {
    id: 449,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến không được khai báo với access modifier nào, nó có access modifier mặc định là gì?",
    options: ["private", "protected", "public", "default (package-private)"],
    answer: 3,
    explanation:
      "Access modifier mặc định (default/package-private) cho phép truy cập bởi tất cả các class trong cùng một package [185].",
  },
  {
    id: 450,
    topic: "Java Core",
    type: "radio",
    question:
      "Access modifier nào hạn chế truy cập thành viên CHỈ trong nội bộ class mà nó được định nghĩa?",
    options: ["public", "protected", "private", "default"],
    answer: 2,
    explanation:
      "`private` chỉ cho phép truy cập từ nội bộ class đó [42, 161].",
  },
  {
    id: 451,
    topic: "Java Core",
    type: "radio",
    question:
      "Access modifier nào cho phép truy cập không giới hạn từ mọi class, mọi package?",
    options: ["public", "protected", "private", "default"],
    answer: 0,
    explanation:
      "`public` cho phép truy cập bởi các class khác [42, 161, 186].",
  },
  {
    id: 452,
    topic: "Java Core",
    type: "radio",
    question:
      "Từ khóa nào được sử dụng để gọi constructor của lớp cha từ lớp con?",
    options: ["this()", "super()", "parent()", "new"],
    answer: 1,
    explanation:
      "Từ khóa `super()` được sử dụng để gọi constructor của lớp cha [21, 187].",
  },
  {
    id: 453,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu constructor của lớp con không gọi `super()` rõ ràng, điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Trình biên dịch tự động chèn lệnh gọi đến constructor mặc định của lớp cha.",
      "Lớp cha sẽ không được khởi tạo.",
      "Object đó sẽ không thể được GC.",
    ],
    answer: 1,
    explanation:
      "Nếu lớp con không gọi `super()` rõ ràng, trình biên dịch sẽ tự động chèn lệnh gọi đến constructor mặc định của lớp cha [21, 187].",
  },
  {
    id: 454,
    topic: "Java Core",
    type: "radio",
    question:
      "Cơ chế quản lý bộ nhớ của Java được thiết kế để giải phóng bộ nhớ từ khu vực nào?",
    options: ["Stack.", "Static Memory.", "Heap.", "ROM."],
    answer: 2,
    explanation:
      "Mục tiêu chính của Garbage Collector là giải phóng bộ nhớ Heap [8].",
  },
  {
    id: 455,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi một biến tham chiếu cục bộ được khai báo mà không khởi tạo object, bao nhiêu object được tạo ra trên Heap?",
    options: [
      "1 object.",
      "2 objects.",
      "Không object nào (0 objects).",
      "Tùy thuộc vào kiểu dữ liệu.",
    ],
    answer: 2,
    explanation:
      "Khai báo biến tham chiếu chỉ tạo ra biến trên Stack (hoặc Instance Variable trên Heap), không tạo ra object trên Heap cho đến khi dùng `new` [18].",
  },
  {
    id: 456,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong các lớp Wrapper được sử dụng để chuyển đổi String thành object Wrapper tương ứng (ví dụ: String '12' thành Integer 12)?",
    options: ["parseType()", "valueOf()", "typeValue()", "toObject()"],
    answer: 1,
    explanation:
      "Phương thức `valueOf(String s)` trả về một object của kiểu tương ứng giữ giá trị của String s [49, 70].",
  },
  {
    id: 457,
    topic: "Java Core",
    type: "radio",
    question:
      "Tại sao các biến instance được khởi tạo với giá trị mặc định (ví dụ: 0 cho int, null cho Object) nếu không được gán rõ ràng?",
    options: [
      "Vì chúng là final.",
      "Vì chúng được lưu trên Stack.",
      "Vì chúng sống trên Heap và cần một giá trị state ban đầu.",
      "Vì chúng là static.",
    ],
    answer: 2,
    explanation:
      "Các biến instance sống trên Heap bên trong object và được gán giá trị mặc định nếu không được gán rõ ràng [20, 21].",
  },
  {
    id: 458,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu bạn muốn lưu trữ một dãy các phần tử có cùng kiểu mà không cần biết chính xác kích thước trước, bạn nên sử dụng cấu trúc dữ liệu nào?",
    options: ["Array", "ArrayList", "Primitive type", "HashMap"],
    answer: 1,
    explanation:
      "Hạn chế của Array là phải biết chính xác kích thước [188]. ArrayList cho phép quản lý nhiều item cùng kiểu mà không cần biết trước kích thước cố định [82, 189].",
  },
  {
    id: 459,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Generics, điều gì xảy ra nếu bạn cố gắng thêm một object có kiểu sai vào một List được Generics hóa (ví dụ: `List<String>` và thêm `Integer`)?",
    options: [
      "Lỗi runtime.",
      "Lỗi biên dịch (Compile-time error).",
      "Object đó được chuyển đổi tự động.",
      "Object đó được lưu dưới dạng `Object`.",
    ],
    answer: 1,
    explanation:
      "Generics cung cấp kiểm tra kiểu (type-safety) tại thời điểm biên dịch, ngăn chặn việc thêm kiểu sai [190].",
  },
  {
    id: 460,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi hai class không tương thích cần giao tiếp, mẫu thiết kế cấu trúc (Structural Pattern) nào hoạt động như một cầu nối?",
    options: ["Singleton", "Factory", "Adapter", "Decorator"],
    answer: 2,
    explanation:
      "Adapter pattern hoạt động như một cầu nối giữa các object có giao diện không tương thích [191].",
  },
  {
    id: 461,
    topic: "Java Core",
    type: "radio",
    question:
      "Mẫu thiết kế nào (Design Pattern) đảm bảo rằng chỉ có một thể hiện (instance) của một class tồn tại trong hệ thống?",
    options: ["Factory Method", "Prototype", "Singleton", "Builder"],
    answer: 2,
    explanation:
      "Singleton là Creational pattern, đảm bảo chỉ có một thể hiện của class tồn tại [192].",
  },
  {
    id: 462,
    topic: "Java Core",
    type: "radio",
    question:
      "Mẫu thiết kế nào (Design Pattern) định nghĩa một nhóm các thuật toán và làm cho chúng có thể hoán đổi cho nhau tại thời điểm chạy?",
    options: ["Strategy", "Composite", "Adapter", "Decorator"],
    answer: 0,
    explanation:
      "Strategy pattern định nghĩa một nhóm các thuật toán, đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi cho nhau [193, 194].",
  },
  {
    id: 463,
    topic: "Java Core",
    type: "radio",
    question:
      "Mẫu thiết kế nào cho phép bạn thêm chức năng mới một cách linh hoạt (dynamically) vào một đối tượng bằng cách 'gói' (wrapping) đối tượng đó?",
    options: ["Factory", "Decorator", "Singleton", "Strategy"],
    answer: 1,
    explanation:
      "Decorator pattern cho phép thêm chức năng mới một cách linh hoạt bằng cách gói object đó [195].",
  },
  {
    id: 464,
    topic: "Java Core",
    type: "radio",
    question:
      "Mẫu thiết kế nào được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có (prototype)?",
    options: ["Singleton", "Factory", "Builder", "Prototype"],
    answer: 3,
    explanation:
      "Prototype pattern được sử dụng để tạo object mới bằng cách sao chép một object hiện có [196].",
  },
  {
    id: 465,
    topic: "Java Core",
    type: "radio",
    question:
      "Các mô hình thiết kế (Design Patterns) thường được phân loại thành 3 nhóm chính nào?",
    options: [
      "Procedural, Logic, Functional",
      "Client, Server, API",
      "Creational, Structural, Behavioral",
      "I/O, Memory, Exception",
    ],
    answer: 2,
    explanation:
      "Các mẫu thiết kế được phân thành Creational, Structural, và Behavioral [197, 198].",
  },
  {
    id: 466,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong `Object` class được sử dụng để so sánh nội dung của hai đối tượng?",
    options: ["==", "hashCode()", "equals(Object)", "getClass()"],
    answer: 2,
    explanation:
      "Phương thức `equals(Object)` được sử dụng để so sánh các đối tượng [34, 83].",
  },
  {
    id: 467,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ, nơi nào lưu trữ các biến `static` của một class?",
    options: [
      "Heap Memory.",
      "Stack Memory.",
      "Static Memory.",
      "Local Variable Table.",
    ],
    answer: 2,
    explanation: "Biến static và hằng số được lưu trữ trong Static Memory [1].",
  },
  {
    id: 468,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi sử dụng toán tử `+` để nối một String với một kiểu nguyên thủy (ví dụ: `"Count: " + 10`), điều gì xảy ra với kiểu nguyên thủy?',
    options: [
      "Kiểu nguyên thủy bị ép kiểu thành `int`.",
      "Kiểu nguyên thủy bị bỏ qua.",
      "Kiểu nguyên thủy được chuyển đổi tự động thành String.",
      "Phép toán không được phép.",
    ],
    answer: 2,
    explanation:
      "Kiểu String tuân thủ luật đặc biệt, cho phép chuyển đổi bất kỳ kiểu dữ liệu nào thành String bằng toán tử `+` (nối xâu) [90].",
  },
  {
    id: 469,
    topic: "Java Core",
    type: "radio",
    question: "Lỗi `StackOverflowError` thuộc loại lỗi nào?",
    options: [
      "Checked Exception.",
      "Runtime Exception (Unchecked).",
      "Error (không nên xử lý).",
      "Logic Error.",
    ],
    answer: 2,
    explanation:
      "StackOverflowError là một ví dụ của Error, đại diện cho vấn đề nghiêm trọng với môi trường runtime mà ứng dụng không nên cố gắng xử lý [160, 164].",
  },
  {
    id: 470,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi bạn khai báo `final` cho một class, điều này ảnh hưởng đến khả năng nào của class đó?",
    options: [
      "Khởi tạo object.",
      "Kế thừa (inheritance).",
      "Đa hình.",
      "Đóng gói.",
    ],
    answer: 1,
    explanation: "Final class không thể được kế thừa [80, 81].",
  },
  {
    id: 471,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về Interface trong Java?",
    options: [
      "Interface có thể chứa các constructor.",
      "Interface không thể chứa các phương thức có thân hàm (trước JDK 8).",
      "Interface được sử dụng để thực hiện đa kế thừa bị cấm đối với class.",
      "Interface có thể chứa các biến instance non-static.",
    ],
    answer: 2,
    explanation:
      "Interface được Java giới thiệu để giải quyết vấn đề đa kế thừa [184, 199]. Tất cả methods trong interface là abstract (trừ default/static từ JDK 8), và fields là public static final [200].",
  },
  {
    id: 472,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong Iterator được sử dụng để kiểm tra xem collection còn phần tử tiếp theo không?",
    options: ["hasNext()", "next()", "isEmpty()", "size()"],
    answer: 0,
    explanation: "Iterator interface có phương thức `hasNext()` [181, 183].",
  },
  {
    id: 473,
    topic: "Java Core",
    type: "radio",
    question:
      "Các biến instance được khởi tạo với giá trị mặc định nào cho kiểu `int`?",
    options: ["1", "null", "0", "false"],
    answer: 2,
    explanation: "Giá trị mặc định cho primitives số (int) là 0 [20, 21].",
  },
  {
    id: 474,
    topic: "Java Core",
    type: "radio",
    question:
      "Loại I/O Stream nào được sử dụng để đọc primitive data types một cách tuần tự từ file?",
    options: [
      "DataInputStream",
      "FileReader",
      "RandomAccessFile",
      "PrintStream",
    ],
    answer: 0,
    explanation:
      "DataInputStream được dùng để đọc các kiểu dữ liệu nguyên thủy (readInt, readDouble, v.v.) [142].",
  },
  {
    id: 475,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Generics, tại sao `ArrayList<Dog>` không có mối quan hệ kế thừa với `ArrayList<Animal>`?",
    options: [
      "Vì Dog không kế thừa Animal.",
      "Vì Generics không hỗ trợ type-safety.",
      "Vì không có mối quan hệ kế thừa giữa các kiểu generic khác nhau.",
      "Vì ArrayList không phải là class cha.",
    ],
    answer: 2,
    explanation:
      "Mặc dù Dog kế thừa Animal, Generics không duy trì mối quan hệ kế thừa giữa các kiểu tham số hóa khác nhau (`ArrayList<Dog>` và `ArrayList<Animal>`) [172, 173].",
  },
  {
    id: 476,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì là đúng khi nói về từ khóa `static` được áp dụng cho một method?",
    options: [
      "Nó có thể gọi các biến instance non-static.",
      "Nó không thể bị ghi đè.",
      "Nó thuộc về class, không thuộc về object cụ thể.",
      "Nó phải có kiểu trả về là `void`.",
    ],
    answer: 2,
    explanation:
      "Phương thức static thuộc về class [93] và không cần object để chạy [201].",
  },
  {
    id: 477,
    topic: "Java Core",
    type: "radio",
    question:
      "JVM tạo ra một Object Ngoại lệ (Exception Object) và thực hiện hành động nào tiếp theo?",
    options: [
      "Chạy `System.gc()`.",
      "Chuyển Object Ngoại lệ cho hệ thống runtime (throwing an exception).",
      "Ghi log vào file.",
      "Gọi constructor.",
    ],
    answer: 1,
    explanation:
      "Tạo Object Ngoại lệ và chuyển nó cho JVM được gọi là throwing an Exception [160].",
  },
  {
    id: 478,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi khởi tạo một object bằng Copy Constructor, object mới được tạo ra ở đâu?",
    options: [
      "Trên Stack.",
      "Trong Static Memory.",
      "Trên Heap, là một object độc lập với object gốc.",
      "Trong String Pool.",
    ],
    answer: 2,
    explanation:
      "Sử dụng constructor luôn tạo object trên Heap. Copy Constructor khởi tạo object mới bằng cách sao chép trạng thái của object cùng loại đã có [56, 68].",
  },
  {
    id: 479,
    topic: "Java Core",
    type: "radio",
    question: "Trong Generics, `Pair<? extends Animal>` có ý nghĩa gì?",
    options: [
      "Pair chỉ chứa chính xác kiểu Animal.",
      "Pair chứa các kiểu là Supertype của Animal.",
      "Pair chứa các kiểu là Subtype của Animal (Upper Bound Wildcard).",
      "Pair chứa các kiểu không giới hạn.",
    ],
    answer: 2,
    explanation:
      "Wildcard `? extends Animal` (Upper Bound) cho phép Pair làm việc với một kiểu con (subtype) của Animal [172].",
  },
  {
    id: 480,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng sử dụng biến tham chiếu cục bộ `Dog d` sau khi method chứa nó kết thúc?",
    options: [
      "Biến vẫn có thể truy cập được.",
      "Biến không còn tồn tại do phạm vi kết thúc (scope ends).",
      "Biến trở thành biến instance.",
      "Biến được chuyển sang Heap.",
    ],
    answer: 1,
    explanation:
      "Biến cục bộ chỉ tồn tại khi method còn trên Stack. Sau khi method kết thúc, biến đó không còn tồn tại [61, 72].",
  },
  {
    id: 481,
    topic: "Java Core",
    type: "radio",
    question: "Phương thức `String.intern()` được sử dụng để làm gì?",
    options: [
      "Khởi tạo String bằng literal.",
      "Buộc String được tạo bằng `new` vào String Pool hoặc tham chiếu đến thể hiện hiện có.",
      "Tách String thành nhiều phần.",
      "So sánh String không phân biệt chữ hoa/thường.",
    ],
    answer: 1,
    explanation:
      "Phương thức `intern()` đặt một string vào String Pool hoặc tham chiếu đến object hiện có trong pool [65].",
  },
  {
    id: 482,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi nào một đối tượng được tạo ra thông qua Copy Constructor trở nên đủ điều kiện để Garbage Collection?",
    options: [
      "Ngay lập tức.",
      "Khi object gốc bị GC.",
      "Khi nó không còn bất kỳ tham chiếu nào trỏ đến nó.",
      "Khi method chứa nó kết thúc.",
    ],
    answer: 2,
    explanation:
      "Giống như bất kỳ object nào, nó chỉ đủ điều kiện cho GC khi nó không còn tham chiếu nào trỏ đến nó [8].",
  },
  {
    id: 483,
    topic: "Java Core",
    type: "radio",
    question:
      "Loại stream nào trong Java I/O được sử dụng để đọc và ghi dữ liệu kiểu object?",
    options: [
      "FileInputStream/FileOutputStream",
      "DataInputStream/DataOutputStream",
      "ObjectInputStream/ObjectOutputStream",
      "BufferedReader/PrintWriter",
    ],
    answer: 2,
    explanation:
      "ObjectInputStream và ObjectOutputStream được sử dụng để đọc/ghi các object (cần serialization) [142].",
  },
  {
    id: 484,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Generics, điều gì xảy ra nếu bạn cố gắng khai báo `ArrayList<int>`?",
    options: [
      "Nó hoạt động bình thường.",
      "Nó bị lỗi biên dịch vì Generics chỉ chấp nhận kiểu tham chiếu (Object).",
      "JVM tự động chuyển đổi thành `ArrayList<Integer>`.",
      "Nó bị lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Generics chỉ hoạt động với kiểu tham chiếu (classes/interfaces), không phải kiểu nguyên thủy (primitives) [202, 203].",
  },
  {
    id: 485,
    topic: "Java Core",
    type: "radio",
    question:
      "Tính chất nào của OOP giúp làm cho code có tổ chức và dễ hiểu hơn, đồng thời đơn giản hóa việc bảo trì?",
    options: [
      "Encapsulation",
      "Polymorphism",
      "Sử dụng Objects",
      "Inheritance",
    ],
    answer: 2,
    explanation:
      "Sử dụng Objects giúp tổ chức code bằng cách kết hợp variables và methods, làm code có tổ chức và dễ hiểu hơn [204, 205].",
  },
  {
    id: 486,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong quản lý bộ nhớ, việc chuyển đổi một kiểu nguyên thủy (primitive) thành object Wrapper tương ứng được gọi là gì?",
    options: ["Boxing", "Unboxing", "Casting", "Serialization"],
    answer: 0,
    explanation:
      "Quá trình đóng gói kiểu nguyên thủy thành object Wrapper được gọi là Boxing. (Autoboxing là tự động hóa quá trình này) [38].",
  },
  {
    id: 487,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi bạn sử dụng toán tử `new` để tạo một mảng (ví dụ: `new int[206]`), bộ nhớ được cấp phát ở đâu?",
    options: [
      "Chỉ trên Stack.",
      "Trên Heap.",
      "Trong Static Memory.",
      "Được cấp phát động trên Stack.",
    ],
    answer: 1,
    explanation: "Mảng là object và được cấp phát trên Heap [3, 47, 48].",
  },
  {
    id: 488,
    topic: "Java Core",
    type: "radio",
    question: "Khi khai báo một biến `boolean` cục bộ, nó được lưu trữ ở đâu?",
    options: ["Heap.", "Stack.", "Static Memory.", "String Pool."],
    answer: 1,
    explanation:
      "Biến nguyên thủy cục bộ (boolean) được lưu trữ trên Stack [1, 61, 85].",
  },
  {
    id: 489,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các Lớp Wrapper để chuyển đổi String thành số là gì?",
    options: [
      "Để tránh lỗi logic.",
      "Để ngăn chặn GC.",
      "Để chuyển đổi chuỗi số (ascii values) thành giá trị số nguyên thủy tương ứng.",
      "Để áp dụng phép toán số học.",
    ],
    answer: 2,
    explanation:
      "Các phương thức như `Integer.parseInt()` được sử dụng để chuyển đổi String biểu diễn các ký tự số thành giá trị nguyên thủy [49-51].",
  },
  {
    id: 490,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình luồng I/O, sự khác biệt giữa I/O có đệm (buffered) và không đệm (unbuffered) là gì?",
    options: [
      "I/O không đệm hiệu quả hơn.",
      "I/O có đệm sử dụng bộ nhớ tạm thời để giảm tương tác HĐH, làm cho chương trình hiệu quả hơn.",
      "I/O không đệm chỉ dùng cho byte stream.",
      "I/O có đệm chỉ dùng cho character stream.",
    ],
    answer: 1,
    explanation:
      "I/O không đệm kém hiệu quả hơn vì mỗi yêu cầu đọc/ghi được xử lý trực tiếp bởi HĐH. I/O có đệm cải thiện hiệu suất [96, 153].",
  },
  {
    id: 491,
    topic: "Java Core",
    type: "radio",
    question: "Đâu là một ví dụ của Checked Exception?",
    options: [
      "NullPointerException",
      "ArithmeticException",
      "StackOverflowError",
      "FileNotFoundException",
    ],
    answer: 3,
    explanation:
      "FileNotFoundException là một ví dụ của Checked Exception, thường là lớp con của IOException [58, 207].",
  },
  {
    id: 492,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức `typeValue()` (ví dụ: `intValue()`) của Wrapper Class được sử dụng để làm gì?",
    options: [
      "Kiểm tra kiểu dữ liệu.",
      "Trả về giá trị của object dưới dạng kiểu nguyên thủy của nó.",
      "Thực hiện Autoboxing.",
      "Ép kiểu object sang String.",
    ],
    answer: 1,
    explanation:
      "Phương thức `typeValue()` trả về giá trị của object dưới dạng kiểu nguyên thủy của nó [70, 71].",
  },
  {
    id: 493,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều kiện nào làm cho một object bị abandoned (bị bỏ rơi) và đủ điều kiện cho GC?",
    options: [
      "Khi nó không còn được sử dụng trong vòng lặp.",
      "Khi nó không còn tham chiếu nào trỏ tới nó.",
      "Khi nó được khai báo là `private`.",
      "Khi class chứa nó là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Object bị abandoned/unreachable khi không còn tham chiếu nào trỏ tới nó [8, 43].",
  },
  {
    id: 494,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Generics, nếu bạn có `List<Animal>`, bạn có thể thêm đối tượng nào vào List đó?",
    options: [
      "Chỉ đối tượng kiểu `Animal`.",
      "Đối tượng kiểu `Animal` hoặc bất kỳ Subtype nào của `Animal`.",
      "Chỉ đối tượng kiểu `Object`.",
      "Bất kỳ đối tượng nào.",
    ],
    answer: 1,
    explanation:
      "Polymorphism cho phép bạn sử dụng một tham chiếu kiểu cha để trỏ đến object kiểu con. Vì vậy, `List<Animal>` có thể chứa cả `Animal` và các subtype của nó [107].",
  },
  {
    id: 495,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là SAI về các biến được khai báo là `static`?",
    options: [
      "Chúng có thể được truy cập trực tiếp từ tên class.",
      "Chúng được chia sẻ bởi tất cả các instance của class.",
      "Chúng được lưu trữ trên Stack.",
      "Chúng được khởi tạo khi class được nạp.",
    ],
    answer: 2,
    explanation:
      "Các biến static được lưu trữ trong Static Memory (hoặc Heap/Metaspace trong các JVM hiện đại) nhưng KHÔNG phải trên Stack [1].",
  },
  {
    id: 496,
    topic: "Java Core",
    type: "radio",
    question: "Kiểu dữ liệu nguyên thủy nào có phạm vi giá trị lớn nhất?",
    options: ["int", "long", "float", "double"],
    answer: 1,
    explanation:
      "Kiểu `long` (64 bit) có thể biểu diễn số nguyên trong khoảng lớn hơn nhiều so với `int` (32 bit) [17, 64].",
  },
  {
    id: 497,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích của việc sử dụng Lớp `Math` là gì?",
    options: [
      "Để cung cấp các hằng số và hàm toán học mà không cần tạo object (do static).",
      "Để tạo ra các số nguyên ngẫu nhiên.",
      "Để quản lý bộ nhớ.",
      "Để thực hiện I/O Stream.",
    ],
    answer: 0,
    explanation:
      "Lớp `Math` có các phương thức static như `random()` [66, 92, 93].",
  },
  {
    id: 498,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi nào thì một constructor có tham số (Parameterized constructor) được sử dụng?",
    options: [
      "Chỉ để gọi constructor mặc định.",
      "Để khởi tạo object với các giá trị tùy chỉnh từ bên ngoài.",
      "Để gọi phương thức `main()`.",
      "Để làm cho object là `static`.",
    ],
    answer: 1,
    explanation:
      "Parameterized constructor cho phép khởi tạo object bằng cách sử dụng input để thiết lập giá trị ban đầu cho các field [143].",
  },
  {
    id: 499,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `super()` trong constructor của lớp con là gì?",
    options: [
      "Để ghi đè phương thức lớp cha.",
      "Để đảm bảo rằng các constructor trong toàn bộ cây kế thừa (inheritance tree) được chạy, khởi tạo object đúng cách.",
      "Để tham chiếu object hiện tại.",
      "Để trả về object lớp cha.",
    ],
    answer: 1,
    explanation:
      "Tất cả các constructor trong cây kế thừa phải chạy khi tạo object mới. `super()` đảm bảo điều này (Constructor chaining) [208].",
  },
  {
    id: 510,
    topic: "I/O Stream",
    type: "radio",
    question:
      "Trong Java I/O, một 'stream' được định nghĩa là một chuỗi (sequence) gì?",
    options: ["Files", "Methods", "Data", "References"],
    answer: 2,
    explanation: "Stream là một chuỗi dữ liệu (sequence of data) [1].",
  },
  {
    id: 511,
    topic: "I/O Stream",
    type: "radio",
    question:
      "Khi làm việc với dữ liệu ký tự (character data) trong Java I/O, nên sử dụng loại stream nào?",
    options: [
      "Byte streams",
      "Character streams",
      "Input streams",
      "Print streams",
    ],
    answer: 1,
    explanation:
      "Khi tệp chứa dữ liệu ký tự, cách tiếp cận tốt nhất là sử dụng character streams [2].",
  },
  {
    id: 512,
    topic: "I/O Stream",
    type: "radio",
    question: "Điều gì xảy ra nếu sử dụng I/O không đệm (unbuffered I/O)?",
    options: [
      "Tốc độ thực thi được cải thiện đáng kể.",
      "Mỗi yêu cầu đọc/ghi được xử lý trực tiếp bởi HĐH, làm cho chương trình kém hiệu quả hơn.",
      "Chỉ có thể đọc dữ liệu byte.",
      "Dữ liệu được lưu trữ trong bộ đệm tạm thời.",
    ],
    answer: 1,
    explanation:
      "I/O không đệm làm cho chương trình kém hiệu quả hơn vì mỗi yêu cầu đọc hoặc ghi được xử lý trực tiếp bởi HĐH [3].",
  },
  {
    id: 513,
    topic: "I/O Stream",
    type: "text",
    question:
      "Để chuyển đổi trạng thái của một đối tượng thành một byte stream để lưu trữ hoặc truyền qua mạng, kỹ thuật nào được sử dụng?",
    answer: "Serialization",
    explanation:
      "Để lưu một đối tượng Java, ta cần chuyển đổi trạng thái của đối tượng thành một byte stream bằng cách sử dụng Serialization [3].",
  },
  {
    id: 514,
    topic: "I/O Stream",
    type: "radio",
    question:
      "Để làm cho một đối tượng có thể được tuần tự hóa (serializable), nó cần triển khai interface nào?",
    options: ["Comparable", "Cloneable", "java.io.Serializable", "Runnable"],
    answer: 2,
    explanation:
      "Để làm cho đối tượng có thể tuần tự hóa, ta cần triển khai marker interface java.io.Serializable [4].",
  },
  {
    id: 515,
    topic: "I/O Stream",
    type: "text",
    question:
      "Trong Java I/O, các luồng chuẩn (Standard streams) như `System.in` là loại stream gì (byte hay character)?",
    answer: "Byte stream",
    explanation:
      "Các luồng chuẩn (Standard streams) là byte streams (chứ không phải character streams) [5].",
  },
  {
    id: 516,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Lỗi nào xảy ra trong khi chương trình đang chạy và có thể khiến chương trình bị crash?",
    options: [
      "Syntax errors",
      "Compile-time errors",
      "Bugs (Logic errors)",
      "Runtime errors",
    ],
    answer: 3,
    explanation:
      "Runtime errors (lỗi thời gian chạy) xảy ra khi chương trình đang chạy và có thể gây ra crash [6].",
  },
  {
    id: 517,
    topic: "Exception Handling",
    type: "radio",
    question: "Sự khác biệt chính giữa Error và Exception là gì?",
    options: [
      "Error là vấn đề nghiêm trọng mà ứng dụng KHÔNG nên cố gắng xử lý, trong khi Exception là điều kiện mà ứng dụng CÓ THỂ cố gắng xử lý.",
      "Error có thể được bắt bằng khối 'catch', Exception thì không.",
      "Error chỉ xảy ra ở thời điểm biên dịch.",
      "Error là Checked, Exception là Unchecked.",
    ],
    answer: 0,
    explanation:
      "Error đại diện cho vấn đề nghiêm trọng mà ứng dụng hợp lý không nên cố gắng xử lý. Exception đại diện cho điều kiện mà ứng dụng hợp lý có thể cố gắng xử lý [7].",
  },
  {
    id: 518,
    topic: "Exception Handling",
    type: "text",
    question:
      "Khối code nào được sử dụng để chứa các câu lệnh có khả năng ném ra ngoại lệ (throw exceptions)?",
    answer: "try",
    explanation:
      "Các câu lệnh có thể ném ra ngoại lệ được chứa trong một khối try [8].",
  },
  {
    id: 519,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối lệnh nào (nếu có) luôn được thực thi sau khi khối 'try' kết thúc, bất kể có ngoại lệ xảy ra hay không?",
    options: ["catch", "throw", "finally", "assert"],
    answer: 2,
    explanation:
      "Khối `finally` luôn được thực thi sau khi khối try hoàn thành, bất kể có ngoại lệ xảy ra hay không [9, 10].",
  },
  {
    id: 520,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Loại ngoại lệ nào được kiểm tra ở thời điểm biên dịch (compile time)?",
    options: [
      "Unchecked Exceptions",
      "Checked Exceptions",
      "Runtime Exceptions",
      "Errors",
    ],
    answer: 1,
    explanation:
      "Checked Exceptions là các ngoại lệ được kiểm tra ở thời điểm biên dịch [11, 12].",
  },
  {
    id: 521,
    topic: "Exception Handling",
    type: "text",
    question:
      "Ngoại lệ `NullPointerException` thuộc loại Checked hay Unchecked?",
    answer: "Unchecked",
    explanation:
      "NullPointerException là một ví dụ của ngoại lệ Unchecked (Runtime Exception) [13].",
  },
  {
    id: 522,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức ném ra một Checked Exception, nó phải làm gì nếu không muốn xử lý nó bằng `try-catch`?",
    options: [
      "Khai báo ngoại lệ đó bằng từ khóa `throws`.",
      "Khai báo nó là `final`.",
      "Ép kiểu thành RuntimeException.",
      "Không cần làm gì.",
    ],
    answer: 0,
    explanation:
      "Nếu một phương thức ném ra checked exception, nó phải xử lý hoặc chỉ định ngoại lệ đó bằng từ khóa `throws` [11, 12].",
  },
  {
    id: 523,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu cả lớp cơ sở (Base) và lớp dẫn xuất (Derived) đều được bắt làm ngoại lệ (catch), catch block nào phải xuất hiện trước?",
    options: [
      "Catch block của lớp Base.",
      "Catch block của lớp Derived.",
      "Thứ tự không quan trọng.",
      "Nó sẽ gây ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Catch block của lớp dẫn xuất (Derived class) phải xuất hiện trước lớp cơ sở [13].",
  },
  {
    id: 524,
    topic: "Exception Handling",
    type: "text",
    question:
      "Để tự tạo ngoại lệ (User-defined exception), class mới phải là lớp con của class nào?",
    answer: "Exception",
    explanation: "Tất cả các ngoại lệ đều là lớp con của class Exception [14].",
  },
  {
    id: 525,
    topic: "Exception Handling",
    type: "code",
    question: "Đoạn mã sau in ra gì?",
    code: 'public class ExceptionTest { public static void main(String[] args) { try { int result = 10 / 0; } catch (ArithmeticException e) { System.out.print("A"); } finally { System.out.print("B"); } } }',
    options: ["A", "B", "AB", "Lỗi runtime không thể bắt"],
    answer: 2,
    explanation:
      "Ngoại lệ `ArithmeticException` được ném ra và bắt (in ra A), sau đó khối `finally` luôn được thực thi (in ra B) [15].",
  },
  {
    id: 526,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics (Kiểu chung) giúp giải quyết vấn đề gì khi làm việc với Collections (trước JDK 5.0)?",
    options: [
      "Tăng tốc độ Garbage Collection.",
      "Giúp loại bỏ nhu cầu ép kiểu liên tục và cung cấp kiểm tra lỗi kiểu ở thời điểm biên dịch.",
      "Buộc tất cả các fields phải là `private`.",
      "Ngăn chặn Inheritance.",
    ],
    answer: 1,
    explanation:
      "Generics giúp loại bỏ nhu cầu ép kiểu và không có cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch khi sử dụng kiểu `Object` [16, 17].",
  },
  {
    id: 527,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Cú pháp cho tham số kiểu bị giới hạn (Bounded type parameters) sử dụng từ khóa nào để chỉ định rằng tham số kiểu phải là kiểu con (subtype) của một kiểu đã cho?",
    answer: "extends",
    explanation:
      "Cú pháp cho tham số kiểu bị giới hạn là `<T extends BoundingType>`. T phải là kiểu con của BoundingType [18, 19].",
  },
  {
    id: 528,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là đúng về mối quan hệ kế thừa giữa các kiểu Generic, ví dụ giữa `List<Dog>` và `List<Animal>` (nếu Dog kế thừa Animal)?",
    options: [
      "`List<Dog>` kế thừa `List<Animal>`.",
      "Không có mối quan hệ kế thừa nào giữa hai kiểu generic khác nhau.",
      "Chỉ xảy ra nếu sử dụng `extends`.",
      "Chỉ xảy ra nếu chúng nằm trong cùng một package.",
    ],
    answer: 1,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: `Pair<Dog>` và `Pair<Animal>`) [18, 20].",
  },
  {
    id: 529,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cấu trúc dữ liệu Stack trong Java đại diện cho nguyên tắc nào?",
    options: [
      "First-In, First-Out (FIFO)",
      "Last-In, First-Out (LIFO)",
      "Random Access",
      "Ordered Sequence",
    ],
    answer: 1,
    explanation:
      "Collection Stack đại diện cho một stack đối tượng kiểu Last-in, first-out (LIFO) [21, 22].",
  },
  {
    id: 530,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cấu trúc dữ liệu Queue trong Java đại diện cho nguyên tắc nào?",
    options: [
      "Last-In, First-Out (LIFO)",
      "First-In, First-Out (FIFO)",
      "Random Access",
      "Unordered Collection",
    ],
    answer: 1,
    explanation:
      "Queue là cấu trúc dữ liệu First-In, First-Out (FIFO) [23, 24].",
  },
  {
    id: 531,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích chính của HashMap là gì?",
    options: [
      "Đảm bảo các phần tử được sắp xếp theo thứ tự chèn.",
      "Tăng tốc quá trình tìm kiếm so với ArrayList bằng cách sử dụng key.",
      "Chỉ lưu trữ các kiểu dữ liệu nguyên thủy.",
      "Thực hiện nguyên tắc LIFO.",
    ],
    answer: 1,
    explanation:
      "HashMap được giới thiệu để tăng tốc quá trình tìm kiếm so với ArrayList, bằng cách liên kết mỗi mục với một key [25, 26].",
  },
  {
    id: 532,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Trong HashMap, mỗi mục bạn muốn thêm phải được liên kết với một cái gì đó duy nhất để truy cập nhanh chóng?",
    answer: "key",
    explanation:
      "HashMap cho phép bạn liên kết một key với mỗi mục bạn muốn thêm [26, 27].",
  },
  {
    id: 533,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giao diện nào có các phương thức `hasNext()`, `next()`, và `remove()` để duyệt qua một collection?",
    options: ["Comparable", "Serializable", "Iterator", "Cloneable"],
    answer: 2,
    explanation:
      "Giao diện Iterator của Java có các phương thức hasNext(), next(), remove() [28, 29].",
  },
  {
    id: 534,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Interface phổ biến nào bao gồm một phương thức duy nhất là `compareTo()`, được sử dụng để so sánh hai đối tượng của cùng một kiểu?",
    options: ["Serializable", "Runnable", "Comparable", "Cloneable"],
    answer: 2,
    explanation:
      "Comparable là một interface phổ biến trong Java, bao gồm một phương thức duy nhất là CompareTo() [30].",
  },
  {
    id: 535,
    topic: "Generics & Collections",
    type: "text",
    question:
      "Lớp nào là lớp phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ (internally)?",
    answer: "ArrayList",
    explanation:
      "ArrayList là class phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ [31, 32].",
  },
  {
    id: 536,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế (Design Pattern) được định nghĩa là gì?",
    options: [
      "Các class và object cụ thể để sử dụng lại.",
      "Các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm.",
      "Các cú pháp bắt buộc trong ngôn ngữ lập trình.",
      "Các thuật toán phức tạp.",
    ],
    answer: 1,
    explanation:
      "Design patterns là các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm [33, 34].",
  },
  {
    id: 537,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả?",
    options: ["Creational", "Structural", "Behavioral", "Utility"],
    answer: 1,
    explanation:
      "Structural patterns (Mẫu cấu trúc) tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả [35, 36].",
  },
  {
    id: 538,
    topic: "Design Patterns",
    type: "text",
    question:
      "Mẫu thiết kế khởi tạo nào (Creational pattern) đảm bảo rằng chỉ có một thể hiện (instance) của một class tồn tại trong hệ thống?",
    answer: "Singleton",
    explanation:
      "Singleton là mẫu khởi tạo, đảm bảo rằng chỉ có một thể hiện của class tồn tại [37, 38].",
  },
  {
    id: 539,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích chính của Factory Method Pattern là gì?",
    options: [
      "Tạo đối tượng mới bằng cách sao chép một đối tượng hiện có.",
      "Định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo.",
      "Thêm chức năng mới vào đối tượng mà không thay đổi cấu trúc của nó.",
      "Tổ chức đối tượng trong cấu trúc phân cấp.",
    ],
    answer: 1,
    explanation:
      "Mục đích của Factory method pattern là định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo [39, 40].",
  },
  {
    id: 540,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế khởi tạo nào (Creational pattern) được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có?",
    options: ["Factory Method", "Abstract Factory", "Prototype", "Builder"],
    answer: 2,
    explanation:
      "Prototype được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có (prototype) [41, 42].",
  },
  {
    id: 541,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào (Structural pattern) hoạt động như một cầu nối giữa các đối tượng có giao diện không tương thích?",
    options: ["Decorator", "Composite", "Adapter", "Strategy"],
    answer: 2,
    explanation:
      "Adapter pattern giúp các đối tượng có giao diện không tương thích cộng tác bằng cách hoạt động như một cầu nối giữa chúng [43, 44].",
  },
  {
    id: 542,
    topic: "Design Patterns",
    type: "text",
    question:
      "Mẫu thiết kế nào (Structural pattern) cho phép bạn thêm chức năng mới một cách linh hoạt (dynamically) vào một đối tượng bằng cách 'gói' (wrapping) đối tượng đó?",
    answer: "Decorator",
    explanation:
      "Decorator là một structural design pattern cho phép bạn thêm chức năng mới một cách linh hoạt vào một đối tượng mà không làm thay đổi cấu trúc của nó [45, 46].",
  },
  {
    id: 543,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào định nghĩa một nhóm các thuật toán, đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi cho nhau tại thời điểm chạy?",
    options: ["Strategy", "Strategy Interface", "Context Class", "Factory"],
    answer: 0,
    explanation:
      "Strategy design pattern định nghĩa một nhóm các thuật toán, đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi cho nhau [47, 48].",
  },
  {
    id: 544,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, class nào duy trì một tham chiếu đến đối tượng Strategy và sử dụng nó để thực thi thuật toán?",
    options: [
      "Strategy Interface",
      "Concrete Strategy",
      "Context Class",
      "Factory",
    ],
    answer: 2,
    explanation:
      "Context class duy trì một tham chiếu đến đối tượng Strategy và sử dụng nó để thực thi thuật toán [49, 50].",
  },
  {
    id: 545,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế nào sau đây thuộc Creational Pattern?",
    options: ["Adapter", "Decorator", "Singleton", "Iterator"],
    answer: 2,
    explanation: "Singleton là Creational Pattern [1, 36].",
  },
  {
    id: 546,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào được đưa vào với độ chính xác gấp đôi (double precision)?",
    options: ["float", "double", "long", "int"],
    answer: 1,
    explanation:
      "Kiểu `double` được đưa vào với độ chính xác gấp đôi (double precision) so với `float` [51].",
  },
  {
    id: 547,
    topic: "Java Core",
    type: "radio",
    question: "Một trường (field) được mô tả bằng từ khóa 'final' là gì?",
    options: [
      "Một biến có thể thay đổi.",
      "Một biến chỉ có thể được thiết lập một lần.",
      "Một biến chỉ có thể được truy cập trong class.",
      "Một biến được chia sẻ bởi tất cả các đối tượng.",
    ],
    answer: 1,
    explanation:
      "Một trường final đơn giản là một hằng số (constant variable), tức là một biến chỉ được thiết lập một lần và không được phép thay đổi [52-54].",
  },
  {
    id: 548,
    topic: "Java Core",
    type: "radio",
    question: "Một class được khai báo là 'final' sẽ bị hạn chế điều gì?",
    options: [
      "Không thể tạo đối tượng từ class đó.",
      "Nó không thể được kế thừa (inherited).",
      "Các phương thức của nó không thể được gọi.",
      "Các trường của nó phải là 'static'.",
    ],
    answer: 1,
    explanation: "Final class không thể được kế thừa [55, 56].",
  },
  {
    id: 549,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì xảy ra nếu một phương thức được đánh dấu là 'final'?",
    options: [
      "Nó phải được khai báo là static.",
      "Nó không thể bị ghi đè (overridden) trong lớp con.",
      "Nó phải trả về kiểu void.",
      "Nó chỉ có thể được gọi từ bên trong class.",
    ],
    answer: 1,
    explanation: "Phương thức final không thể bị ghi đè [55-57].",
  },
  {
    id: 550,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi khai báo biến, Java phân biệt bao nhiêu kiểu dữ liệu nguyên thủy (primitive types)?",
    options: ["4", "6", "8", "10"],
    answer: 2,
    explanation:
      "Có tám kiểu dữ liệu được dựng sẵn (build-in) trong Java [58, 59].",
  },
  {
    id: 551,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì là đúng về việc ép kiểu (casting) từ `double` sang `int` (ví dụ: `(int) variable`)?",
    options: [
      "Nó được thực hiện tự động.",
      "Nó là chuyển kiểu rõ ràng (explicit casting) và có thể dẫn đến mất thông tin.",
      "Chỉ xảy ra ở runtime.",
      "Nó chỉ hoạt động với các biến `final`.",
    ],
    answer: 1,
    explanation:
      "Chuyển đổi rõ ràng: Java cung cấp một số hàm chuyển đổi các kiểu khi ta biết rõ việc chuyển kiểu sẽ dẫn đến mất thông tin, ví dụ `(int) (r * N)` [60].",
  },
  {
    id: 552,
    topic: "Java Core",
    type: "code",
    question:
      "Đoạn mã sau in ra gì? (Biết rằng toán tử `+` được ưu tiên thực hiện từ trái sang phải)",
    code: 'System.out.println("bc" + 2 + 3);',
    options: ["bc5", "bc23", "5bc", "Lỗi biên dịch"],
    answer: 1,
    explanation:
      'Do toán tử `+` được dùng để nối xâu, `"bc" + 2` tạo ra `"bc2"`, sau đó nối với `3` tạo ra `"bc23"`. Kiểu String tuân thủ luật đặc biệt, có thể chuyển đổi bất kỳ loại dữ liệu nào thành một String bằng cách sử dụng toán tử `+` [60, 61].',
  },
  {
    id: 553,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các Lớp Wrapper (Wrapper Classes) như Integer, Double là gì?",
    options: [
      "Cung cấp các phương thức tiện ích cho các đối tượng và gói gọn kiểu dữ liệu nguyên thủy.",
      "Chỉ để thực hiện các phép toán phức tạp.",
      "Chúng là kiểu dữ liệu nguyên thủy chính xác hơn.",
      "Để ngăn chặn Garbage Collector.",
    ],
    answer: 0,
    explanation:
      "Lớp Wrapper gói gọn một kiểu dữ liệu, mang lại cho nó vẻ ngoài của một đối tượng [62, 63].",
  },
  {
    id: 554,
    topic: "Java Core",
    type: "text",
    question:
      "Phương thức nào trong các lớp Wrapper được sử dụng để chuyển đổi String thành kiểu nguyên thủy tương ứng (ví dụ: String '12' thành int 12)?",
    answer: "Integer.parseInt()",
    explanation:
      "Sử dụng Integer.parseInt() để chuyển đổi một String thành int [64-66].",
  },
  {
    id: 555,
    topic: "Java Core",
    type: "text",
    question:
      "Trong mô hình bộ nhớ, các biến cục bộ (Local variables) và thông tin gọi phương thức (method call information) sống ở đâu?",
    answer: "Stack",
    explanation:
      "Các biến cục bộ (Local variables) được lưu trữ trên Stack memory [35, 67]. Methods on the stack [49].",
  },
  {
    id: 556,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi gán một biến tham chiếu object cho biến tham chiếu khác (ví dụ: `hq[68] = hq[69];`), điều gì xảy ra?",
    options: [
      "Object gốc được sao chép.",
      "Tham chiếu của object nguồn được sao chép, làm cho cả hai trỏ đến cùng một object trên Heap.",
      "Object gốc bị xóa khỏi Heap.",
      "Xảy ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Tham chiếu được sao chép, làm cho cả hai trỏ đến cùng một object. Ví dụ trong HeapQuiz, `hq[68] = hq[69]` làm cho cả `hq[68]` và `hq[69]` trỏ đến object ID 1 [70].",
  },
  {
    id: 557,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ, một object được coi là đủ điều kiện để Garbage Collection (GC) khi nào?",
    options: [
      "Khi nó được khai báo là `null`.",
      "Khi nó không còn bất kỳ tham chiếu nào trỏ đến nó (abandoned/unreachable).",
      "Khi nó được tạo bằng `new`.",
      "Sau khi phương thức `main()` kết thúc.",
    ],
    answer: 1,
    explanation:
      "Garbage Collection (GC) xảy ra khi đối tượng bị bỏ rơi (abandoned objects), tức là không còn reference nào trỏ đến nó [71, 72].",
  },
  {
    id: 558,
    topic: "Java Core",
    type: "radio",
    question:
      "Việc chuyển đổi từ kiểu nguyên thủy sang Object Wrapper tương ứng được gọi là gì?",
    options: ["Unboxing", "Boxing", "Downcasting", "Autocasting"],
    answer: 1,
    explanation:
      "Boxing là quá trình đóng gói kiểu nguyên thủy thành object Wrapper  (Autoboxing là tự động hóa quá trình này [61]).",
  },
  {
    id: 559,
    topic: "Java Core",
    type: "radio",
    question: "Phương thức `String.equalsIgnoreCase()` được sử dụng để làm gì?",
    options: [
      "Kiểm tra xem hai chuỗi có trỏ đến cùng một object không.",
      "So sánh chuỗi không phân biệt chữ hoa, chữ thường.",
      "Tách chuỗi thành nhiều phần.",
      "Chỉ so sánh các String literal.",
    ],
    answer: 1,
    explanation:
      "Phương thức boolean equalsIgnoreCase(String) được sử dụng để so sánh chuỗi mà không phân biệt chữ hoa, chữ thường [28, 73].",
  },
  {
    id: 560,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi hai String literal được so sánh bằng `==` (ví dụ: `"Java" == "Java"`), kết quả là `true`. Điều này là do đâu?',
    options: [
      "Kiểu String là kiểu nguyên thủy.",
      "JVM tạo ra các object mới trên Heap.",
      "Cả hai đều trỏ đến cùng một thể hiện trong String Pool (trên Heap).",
      "Phép toán `==` luôn so sánh nội dung cho String.",
    ],
    answer: 2,
    explanation:
      "Vì cả hai đều là literal, chúng cùng trỏ đến cùng một thể hiện trong String Pool. `==` so sánh tham chiếu nên trả về true [74, 75].",
  },
  {
    id: 561,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của toán tử `&` hoặc `&&` trong boolean expressions là gì?",
    options: ["OR (Hoặc)", "NOT (Nghịch đảo)", "AND (Và)", "Phép gán"],
    answer: 2,
    explanation: "Các toán tử `&` và `&&` là toán tử logic AND (Và) [76, 77].",
  },
  {
    id: 562,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong lệnh `for (int i = 0; i < N; i++)`, phần `i < N` được gọi là gì?",
    options: [
      "Initialization",
      "Iteration expression",
      "Boolean test",
      "Loop block",
    ],
    answer: 2,
    explanation:
      "Phần giữa hai dấu chấm phẩy là boolean test (điều kiện dừng vòng lặp) [78].",
  },
  {
    id: 563,
    topic: "Java Core",
    type: "code",
    question: "Dự đoán kết quả của đoạn mã sau:",
    code: 'int x = 2; if (x == 3) { System.out.print("x must be 3"); } else { System.out.print("x is NOT 3"); } System.out.print("\\nThis runs no matter what");',
    options: [
      "x must be 3",
      "x is NOT 3\nThis runs no matter what",
      "x must be 3\nThis runs no matter what",
      "Lỗi biên dịch",
    ],
    answer: 1,
    explanation:
      "Vì `x=2`, điều kiện `if` sai, khối `else` chạy (`x is NOT 3`). Câu lệnh cuối cùng chạy ngoài khối `if/else` (`This runs no matter what`) [79].",
  },
  {
    id: 564,
    topic: "Java Core",
    type: "radio",
    question: "Trong Java, phép toán nào sau đây tương đương với `i = i + 1`?",
    options: ["`i = i + 2`", "`i += 2`", "`i++`", "`i = 1`"],
    answer: 2,
    explanation:
      "Phép toán `i++` tương đương với phép toán `i += 1` hoặc `i = i + 1` [80-82].",
  },
  {
    id: 565,
    topic: "Java Core",
    type: "radio",
    question:
      "Phép toán lựa chọn (Conditional operator) `? :` có bao nhiêu toán hạng?",
    options: ["1", "2", "3", "4"],
    answer: 2,
    explanation:
      "Phép toán lựa chọn (ternary operator) có 3 toán hạng phân cách bởi dấu `?` và dấu `:` [83].",
  },
  {
    id: 566,
    topic: "Java Core",
    type: "radio",
    question: "Lệnh `break` trong vòng lặp được sử dụng để làm gì?",
    options: [
      "Nhảy sang lần lặp tiếp theo (next iteration).",
      "Thoát khỏi vòng lặp ngay lập tức.",
      "Bắt đầu vòng lặp mới.",
      "Kiểm tra điều kiện dừng.",
    ],
    answer: 1,
    explanation:
      "Lệnh `break` sử dụng khi ta muốn thoát khỏi vòng lặp ngay lập tức [81, 84].",
  },
  {
    id: 567,
    topic: "Java Core",
    type: "radio",
    question: "Lệnh `continue` trong vòng lặp được sử dụng để làm gì?",
    options: [
      "Thoát khỏi vòng lặp ngay lập tức.",
      "Bỏ qua các lệnh phía sau trong vòng lặp và nhảy sang lần lặp tiếp theo.",
      "Báo lỗi biên dịch.",
      "Chỉ được dùng với `do-while`.",
    ],
    answer: 1,
    explanation:
      "Lệnh `continue` bỏ qua các lệnh phía sau trong vòng lặp để nhảy sang lần lặp tiếp theo [83].",
  },
  {
    id: 568,
    topic: "Java Core",
    type: "code",
    question: "Dự đoán kết quả in ra của đoạn mã sau:",
    code: 'class Shuffle1 { public static void main(String [] args) { int x = 3; while (x > 0) { if (x > 2) { System.out.print("a"); } x = x - 1; System.out.print("-"); if (x == 2) { System.out.print("b c"); } if (x == 1) { System.out.print("d"); x = x - 1; } } } }',
    options: ["a-b c-d", "a-d", "a-b c-d-", "a-b c-d a-"],
    answer: 0,
    explanation:
      "Lần 1 (x=3): in 'a', x=2, in '-', in 'b c'. Output: a-b c. Lần 2 (x=2): x=1, in '-', in 'd', x=0. Output: a-b c-d. Lần 3 (x=0): Vòng lặp dừng [85, 86].",
  },
  {
    id: 569,
    topic: "Java Core",
    type: "code",
    question: "Dự đoán kết quả in ra của đoạn mã sau:",
    code: 'class Output { public static void main(String [] args) { Output o = new Output(); o.go(); } void go() { int y = 7; for(int x = 1; x < 8; x++) { y++; if (x > 4) { System.out.print(++y + " "); } if (y > 14) { System.out.println(" x = " + x); break; } } } }',
    options: ["12 14", "13 15 x = 6", "12 13 14 15 x = 6", "15 x = 7"],
    answer: 1,
    explanation:
      "x=1, y=8. x=2, y=9. x=3, y=10. x=4, y=11. x=5: y=12, x>4 nên ++y (13), in '13 '. x=6: y=14, x>4 nên ++y (15), in '15 '. `y` giờ là 15, `y > 14` nên in ' x = 6' và `break`. Output: 13 15 x = 6 [87].",
  },
  {
    id: 570,
    topic: "Java Core",
    type: "code",
    question: "Dự đoán kết quả in ra của đoạn mã sau (Pool Puzzle MixFor5):",
    code: 'class MixFor5 { public static void main(String [] args) { int x = 0; int y = 30; for (int outer = 0; outer < 3; outer++) { for(int inner = 4; inner > 1; inner--) { y = y - 2; if (x == 6) { break; } x = x + 3; } y = y - 2; } System.out.println(x + " " + y); } }',
    options: ["6 14", "45 6", "18 6", "36 6"],
    answer: 0,
    explanation:
      "Outer=0 (3 lần inner chạy): y=28, x=3; y=26, x=6 (break). Outer loop: y=24. Outer=1 (inner không chạy vì x=6): y=22. Outer=2 (inner không chạy vì x=6): y=20. (Lưu ý: Phân tích dựa trên các nguồn có thể có lỗi logic. Dựa trên đáp án Pool Puzzle: Output là 6 14. Phân tích chính xác hơn: Outer=0: x=3, y=28; x=6, y=26 (break). Outer loop: y=24. Outer=1: x=9, y=22; x=12, y=20; x=15, y=18. Outer loop: y=16. Outer=2: x=18, y=14; x=21, y=12; x=24, y=10. Outer loop: y=8. Output: 24 8. *Tuy nhiên, dựa trên đáp án chính thức của nguồn [88], kết quả là 6 14.* Nếu đoạn `if (x==6) break; x = x + 3;` được thay bằng `x = x + 3; if (x==6) break;`, logic sẽ khác. Sử dụng đáp án đã cung cấp: `6 14`.",
  },
  {
    id: 571,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng sử dụng biến `x` được khai báo trong vòng lặp `for (int x = 0; x < 10; x++)` bên ngoài vòng lặp đó?",
    options: [
      "Biến được chuyển thành biến instance.",
      "Biến vẫn có thể truy cập được vì nó là `int`.",
      "Xảy ra lỗi biên dịch vì biến `x` nằm ngoài phạm vi (scope).",
      "Biến được lưu trữ trên Heap.",
    ],
    answer: 2,
    explanation:
      "Phạm vi (scope) của biến `i` trong `for (int i = 0; i <= N; i++)` chỉ có nghĩa bên trong vòng lặp `for` [80]. Biến cục bộ chỉ tồn tại trong khối code mà chúng được khai báo [89].",
  },
  {
    id: 572,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích của `System.out.printf()` là gì?",
    options: [
      "Đọc dữ liệu có định dạng từ đầu vào chuẩn.",
      "Chuyển hướng đầu ra chuẩn sang tệp.",
      "Điều khiển định dạng khi in ra đầu ra chuẩn.",
      "Thực hiện phép toán số học.",
    ],
    answer: 2,
    explanation:
      "Lệnh `printf()` cho phép chúng ta điều khiển định dạng khi in ra đầu ra chuẩn [90].",
  },
  {
    id: 573,
    topic: "Java Core",
    type: "text",
    question:
      'Để in một dấu ngoặc kép `"` trong một chuỗi Java, ký tự thoát (escape character) nào phải được sử dụng?',
    answer: '\\"',
    explanation:
      'Để in một dấu ngoặc kép, sử dụng `"` trong dấu ngoặc kép [72, 91].',
  },
  {
    id: 574,
    topic: "Java Core",
    type: "radio",
    question:
      "Lệnh nào sau đây được sử dụng để chuyển hướng đầu ra chuẩn của một chương trình vào một tập tin?",
    options: ["`<`", "`>`", "`|`", "`>>`"],
    answer: 1,
    explanation:
      "Dấu `>` chỉ thị rằng đầu ra chuẩn không phải là cửa sổ terminal mà là tập tin [92].",
  },
  {
    id: 575,
    topic: "Java Core",
    type: "radio",
    question:
      "Cơ chế nào được gọi là 'đường ống' (pipeline), kết nối đầu ra chuẩn của một chương trình với đầu vào chuẩn của chương trình khác?",
    options: ["`<`", "`>`", "`|`", "`=`"],
    answer: 2,
    explanation:
      "Cơ chế đường ống (pipeline) sử dụng ký hiệu `|` để kết nối đầu ra chuẩn của chương trình này với đầu vào chuẩn của chương trình khác [93].",
  },
  {
    id: 576,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong cú pháp constructor, khi gọi một constructor khác của cùng một class, lệnh `this()` phải là câu lệnh ở vị trí nào?",
    options: [
      "Câu lệnh cuối cùng trong constructor.",
      "Câu lệnh đầu tiên trong constructor.",
      "Bất cứ đâu trong constructor.",
      "Chỉ sau khi gọi `super()`.",
    ],
    answer: 1,
    explanation:
      "Lệnh gọi constructor `this()` phải là câu lệnh đầu tiên trong constructor [94, 95].",
  },
  {
    id: 577,
    topic: "Java Core",
    type: "radio",
    question:
      "Lệnh gọi `super()` trong constructor của lớp con dùng để làm gì?",
    options: [
      "Truy cập trường `private` của lớp cha.",
      "Đảm bảo constructor của lớp cha được chạy để khởi tạo đối tượng đúng cách.",
      "Tham chiếu đến đối tượng hiện tại.",
      "Ghi đè constructor của lớp cha.",
    ],
    answer: 1,
    explanation:
      "Lệnh gọi constructor `super()` đảm bảo rằng các constructor trong toàn bộ cây kế thừa được chạy, khởi tạo object đúng cách (constructor chaining) [85, 96, 97].",
  },
  {
    id: 578,
    topic: "Java Core",
    type: "radio",
    question: "Nếu lớp con không gọi `super()` rõ ràng, điều gì xảy ra?",
    options: [
      "Lớp con không thể được khởi tạo.",
      "Trình biên dịch tự động chèn một lệnh gọi đến constructor mặc định (không tham số) của lớp cha.",
      "Lớp con chỉ có thể truy cập các trường `public` của lớp cha.",
      "JVM ném ra `NullPointerException`.",
    ],
    answer: 1,
    explanation:
      "Nếu constructor của lớp con không gọi rõ ràng constructor của lớp cha bằng `super`, trình biên dịch Java tự động chèn một lệnh gọi đến constructor mặc định của lớp cha [85, 97].",
  },
  {
    id: 579,
    topic: "Java Core",
    type: "radio",
    question: "Từ khóa `this` được mô tả là gì?",
    options: [
      "Một biến tĩnh lưu trữ địa chỉ của class.",
      "Một biến tham chiếu (reference variable) đề cập đến đối tượng hiện tại (current object).",
      "Một hằng số (constant).",
      "Kiểu trả về của constructor.",
    ],
    answer: 1,
    explanation:
      "Từ khóa `this` là một biến tham chiếu đề cập đến đối tượng hiện tại [98, 99].",
  },
  {
    id: 580,
    topic: "Java Core",
    type: "code",
    question:
      "Đoạn mã sau in ra gì? (Biết `go` là `int go(int arg) { arg = arg * 2; return arg; }`)",
    code: 'class XCopy { public static void main(String [] args) { int orig = 42; XCopy x = new XCopy(); int y = x.go(orig); System.out.println(orig + " " + y); } }',
    options: ["42 42", "42 84", "84 84", "84 42"],
    answer: 1,
    explanation:
      "Java luôn sử dụng Pass-by-Value (truyền bản sao giá trị). Biến `orig` (primitive) được truyền bản sao giá trị 42. `arg` thay đổi thành 84 nhưng không ảnh hưởng đến `orig` gốc. `y` nhận giá trị 84. Output là 42 84 [100, 101].",
  },
  {
    id: 581,
    topic: "Java Core",
    type: "code",
    question:
      "Nếu `a = 2147483647` (Integer.MAX_VALUE), đoạn mã `System.out.println(a + 1);` sẽ in ra gì?",
    options: ["2147483648", "Lỗi biên dịch", "-2147483648 (tràn số)", "0"],
    answer: 2,
    explanation:
      "Đây là hiện tượng tràn số nguyên (integer overflow). Khi cộng 1 vào giá trị lớn nhất của `int`, nó sẽ quay vòng về giá trị nhỏ nhất của `int` (trừ 2 mũ 31) [102].",
  },
  {
    id: 582,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, các biến nào sau đây không được Java tự động khởi tạo giá trị mặc định và phải được khởi tạo rõ ràng?",
    options: [
      "Static variables",
      "Instance variables",
      "Array elements",
      "Local variables",
    ],
    answer: 3,
    explanation:
      "Biến cục bộ (Local variables) không được Java tự động khởi tạo [103]. Nếu biến cục bộ không được gán giá trị, compiler sẽ báo lỗi nếu cố gắng sử dụng nó.",
  },
  {
    id: 583,
    topic: "Java Core",
    type: "code",
    question: "Dự đoán kết quả in ra của đoạn mã sau:",
    code: 'System.out.println(2 + 3 + "bc");',
    options: ["23bc", "5bc", "bc5", "Lỗi biên dịch"],
    answer: 1,
    explanation:
      'Phép toán được thực hiện từ trái sang phải. `2 + 3` được tính trước vì cả hai đều là số nguyên, cho kết quả 5, sau đó nối với "bc" thành "5bc" [61].',
  },
  {
    id: 584,
    topic: "Java Core",
    type: "radio",
    question: "Sự khác biệt giữa `String` và `StringBuffer` là gì?",
    options: [
      "`String` được lưu trên Stack, `StringBuffer` trên Heap.",
      "`String` là chuỗi ký tự có thể sửa đổi, `StringBuffer` thì không.",
      "`String` là chuỗi ký tự không thể sửa đổi, `StringBuffer` thì có thể sửa đổi.",
      "Không có sự khác biệt.",
    ],
    answer: 2,
    explanation:
      "`String` là chuỗi ký tự không thể sửa đổi (unmodifiable sequence of characters). `StringBuffer` là chuỗi ký tự có thể sửa đổi (modifiable sequence of characters) [59, 104, 105].",
  },
  {
    id: 585,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức `typeValue()` (ví dụ: `intValue()`) của Wrapper Class được sử dụng để làm gì?",
    options: [
      "Kiểm tra kiểu dữ liệu.",
      "Thực hiện Boxing.",
      "Trả về giá trị của object dưới dạng kiểu nguyên thủy của nó.",
      "Ép kiểu object sang String.",
    ],
    answer: 2,
    explanation:
      "Tất cả các lớp Wrapper đều có phương thức `typeValue()`. Phương thức này trả về giá trị của đối tượng dưới dạng kiểu nguyên thủy của nó [5, 106].",
  },
  {
    id: 586,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào được sử dụng để biểu diễn một ký tự Unicode?",
    options: ["byte", "int", "char", "String"],
    answer: 2,
    explanation: "Một `char` là một kí tự hoặc biểu tượng [107].",
  },
  {
    id: 587,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào có phạm vi giá trị lớn nhất cho số nguyên?",
    options: ["byte", "short", "int", "long"],
    answer: 3,
    explanation:
      "Kiểu `long` tương tự như kiểu `int` nhưng nó có thể biểu diễn các số nguyên trong một khoảng lớn hơn nhiều (từ −2⁶³ đến 2⁶³−1) [108].",
  },
  {
    id: 588,
    topic: "Java Core",
    type: "radio",
    question: "Trong Java, các mảng (Arrays) được xem là gì?",
    options: ["Kiểu nguyên thủy.", "Object.", "Biến static.", "Wrapper Class."],
    answer: 1,
    explanation: "Mảng (Array) là một object [109].",
  },
  {
    id: 589,
    topic: "Java Core",
    type: "radio",
    question: "Hạn chế chính của việc sử dụng Mảng (Arrays) trong Java là gì?",
    options: [
      "Chỉ có thể lưu trữ kiểu dữ liệu nguyên thủy.",
      "Kích thước phải được biết chính xác khi khởi tạo và không thể thay đổi sau đó.",
      "Không thể sử dụng mảng 2 chiều.",
      "Các mảng không phải là đối tượng.",
    ],
    answer: 1,
    explanation:
      "Bạn cần biết chính xác số lượng mục bạn sẽ sử dụng khi khởi tạo mảng, và một khi đã khởi tạo mảng với kích thước cụ thể, bạn không được phép thêm hoặc xóa phần tử [100, 110].",
  },
  {
    id: 590,
    topic: "Java Core",
    type: "code",
    question: "Đoạn mã sau in ra gì? (Biết `a` và `b` là các mảng tham chiếu)",
    code: "int[] a = { 1, 2, 3 }; int[] b = { 1, 2, 3 }; System.out.println(a == b);",
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 1,
    explanation:
      "Các mảng là object. Toán tử `==` khi so sánh các tham chiếu object sẽ kiểm tra xem chúng có trỏ đến cùng một object trên Heap hay không. `a` và `b` trỏ đến hai object khác nhau, do đó trả về `false` [111].",
  },
  {
    id: 591,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình OOP, khái niệm nào gói gọn dữ liệu (fields) và hành vi (methods) thành một đơn vị?",
    options: ["Polymorphism", "Encapsulation", "Inheritance", "Abstraction"],
    answer: 1,
    explanation:
      "Encapsulation (Đóng gói) là việc gói gọn dữ liệu và các thao tác trên dữ liệu vào một thực thể thống nhất (lớp đối tượng) [112, 113].",
  },
  {
    id: 592,
    topic: "Java Core",
    type: "radio",
    question:
      "Tính chất nào của OOP cho phép một thực thể duy nhất có khả năng mang nhiều hình thức (multiple forms)?",
    options: ["Inheritance", "Encapsulation", "Polymorphism", "Abstraction"],
    answer: 2,
    explanation:
      "Polymorphism (Đa hình) đề cập đến khả năng của một thực thể duy nhất có thể mang nhiều hình thức [68, 114].",
  },
  {
    id: 593,
    topic: "Java Core",
    type: "radio",
    question:
      "Khái niệm Trừu tượng (Abstraction) trong OOP có cơ chế chính là gì?",
    options: [
      "Che giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết.",
      "Đảm bảo chỉ có một thể hiện của class tồn tại.",
      "Cho phép truy cập trực tiếp vào tất cả các trường dữ liệu.",
      "Định nghĩa các thuật toán độc lập với kiểu dữ liệu.",
    ],
    answer: 0,
    explanation:
      "Trừu tượng (Abstraction) là cơ chế ẩn giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết cho người dùng [98, 115].",
  },
  {
    id: 594,
    topic: "Java Core",
    type: "radio",
    question:
      "Để truy cập một trường (field) hoặc gọi một phương thức (method) trong một đối tượng Java, người ta sử dụng toán tử nào?",
    options: ["->", "@", ".", "#"],
    answer: 2,
    explanation:
      "Việc truy cập một trường hoặc gọi một phương thức trong một đối tượng được thực hiện bằng cách sử dụng toán tử dấu chấm “.” [116, 117].",
  },
  {
    id: 595,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc khai báo các trường (fields) là 'private' và cung cấp các phương thức 'public getter/setter' là gì?",
    options: [
      "Giảm chi phí bộ nhớ.",
      "Thực hiện Encapsulation và kiểm soát việc thay đổi dữ liệu.",
      "Giảm thiểu sự phức tạp của mã.",
      "Đảm bảo tính đa hình.",
    ],
    answer: 1,
    explanation:
      "Khai báo tất cả các trường là private và tạo các phương thức getter/setter công khai là một thực hành tốt để kiểm soát khi nào và bằng cách nào một trường được thay đổi, hỗ trợ Đóng gói [118, 119].",
  },
  {
    id: 596,
    topic: "Java Core",
    type: "radio",
    question:
      "Một phương thức được khai báo là 'private' thường được gọi là gì?",
    options: [
      "Utility method",
      "Helper method",
      "Public API",
      "Callback function",
    ],
    answer: 1,
    explanation:
      "Các phương thức private thường được gọi là helper methods (phương thức trợ giúp) [120, 121].",
  },
  {
    id: 597,
    topic: "Java Core",
    type: "text",
    question:
      "Access modifier nào cho phép truy cập thành viên từ cùng một package HOẶC từ các lớp con (subclasses) trong các package khác?",
    answer: "protected",
    explanation:
      "Các phương thức và thành viên dữ liệu được khai báo là protected có thể truy cập được trong cùng một package hoặc trong các lớp con của các package khác [122, 123].",
  },
  {
    id: 598,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra khi một trường (field) được khai báo là 'static'?",
    options: [
      "Giá trị của nó được lưu trữ trong đối tượng (object).",
      "Giá trị của nó được lưu trữ trong class và chia sẻ bởi tất cả các đối tượng của class đó.",
      "Nó trở thành một hằng số và không thể thay đổi.",
      "Nó được phân bổ trên Stack memory.",
    ],
    answer: 1,
    explanation:
      "Khai báo một trường là static có nghĩa là giá trị của nó không còn nằm trong đối tượng nữa mà nằm trong class, và tất cả các đối tượng của class sẽ chia sẻ cùng một giá trị [124, 125].",
  },
  {
    id: 599,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức 'static' có thể truy cập các trường (fields) 'non-static' không?",
    options: [
      "Có, luôn luôn.",
      "Không, vì các trường non-static phụ thuộc vào sự tồn tại của một thể hiện (instance) của class.",
      "Chỉ khi được định nghĩa là public.",
      "Chỉ thông qua từ khóa 'this'.",
    ],
    answer: 1,
    explanation:
      "Không thể truy cập một biến non-static trong ngữ cảnh static, vì các biến non-static phụ thuộc vào sự tồn tại của một thể hiện của class [55, 126].",
  },
  {
    id: 600,
    topic: "Java Core",
    type: "radio",
    question: "Upcasting (Ép kiểu lên) là quá trình nào?",
    options: [
      "Ép kiểu một đối tượng lớp cha thành lớp con, cần làm thủ công.",
      "Ép kiểu một đối tượng lớp con thành kiểu lớp cha, được thực hiện tự động.",
      "Chuyển đổi từ kiểu dữ liệu nguyên thủy sang đối tượng Wrapper.",
      "Ép kiểu giữa các lớp không liên quan.",
    ],
    answer: 1,
    explanation:
      "Upcasting là khi một đối tượng của lớp con được đối xử như một đối tượng của bất kỳ lớp siêu lớp nào. Upcasting được thực hiện tự động [127, 128].",
  },
  {
    id: 601,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, việc kế thừa nhiều lớp (multiple inheritance) có được cho phép không?",
    options: [
      "Có, sử dụng từ khóa `implements`.",
      "Không, một class chỉ có thể mở rộng tối đa một class.",
      "Chỉ khi các lớp cha đều là `abstract`.",
      "Chỉ khi các lớp cha nằm trong cùng một package.",
    ],
    answer: 1,
    explanation:
      "Một hạn chế lớn trong Java là một class không thể mở rộng nhiều hơn một class (multiple inheritance is not allowed in Java) [86, 129].",
  },
  {
    id: 602,
    topic: "Java Core",
    type: "text",
    question:
      "Toán tử nào được sử dụng để kiểm tra xem một đối tượng có phải là một thể hiện (instance) của một class nào đó (hoặc lớp con) không?",
    answer: "instanceof",
    explanation:
      "Toán tử `instanceof` được sử dụng để kiểm tra xem một đối tượng có phải là một thể hiện của một class nào đó (hoặc lớp con) không [130, 131].",
  },
  {
    id: 603,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu cố gắng downcast một đối tượng Mammal thành Cat (ví dụ: `Mammal m = new Mammal(); Cat c = (Cat)m;`) nhưng `m` không phải là `Cat`?",
    options: [
      "Lỗi biên dịch.",
      "Nó ném ra `java.lang.ClassCastException` khi chạy.",
      "Nó chạy bình thường.",
      "Nó được thực hiện tự động.",
    ],
    answer: 1,
    explanation:
      "Mã này vượt qua quá trình biên dịch, nhưng ném ra ngoại lệ `ClassCastException` khi chạy vì Mammal không phải là Cat [130, 132].",
  },
  {
    id: 604,
    topic: "Java Core",
    type: "radio",
    question:
      "Lớp Trừu tượng (Abstract Class) có thể làm được điều gì mà Interface (trước JDK 8) không thể?",
    options: [
      "Triển khai đa kế thừa.",
      "Chứa các trường ngầm định là `public static final`.",
      "Chứa các phương thức có thân hàm (concrete methods) và các biến instance non-static.",
      "Ngầm định tất cả các phương thức là `public abstract`.",
    ],
    answer: 2,
    explanation:
      "Abstract Class có thể chứa các phương thức có thân hàm (concrete methods) [62]. Interface trước JDK 8 chỉ chứa các phương thức ngầm định `public abstract` [133].",
  },
  {
    id: 605,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì đúng về Lớp Trừu tượng (Abstract Class) trong Java?",
    options: [
      "Nó phải chứa ít nhất một phương thức trừu tượng.",
      "Không thể tạo đối tượng (instance) trực tiếp từ lớp trừu tượng.",
      "Constructor của nó không thể được gọi.",
      "Nó không thể kế thừa bất kỳ class nào khác.",
    ],
    answer: 1,
    explanation: "Không thể tạo đối tượng của một lớp trừu tượng [5, 62, 134].",
  },
  {
    id: 606,
    topic: "Java Core",
    type: "text",
    question:
      "Tất cả các trường (fields) trong một interface đều ngầm định (implicitly) là public, static, và gì?",
    answer: "final",
    explanation:
      "Tất cả các trường trong một interface đều ngầm định là public, static, final [135, 136].",
  },
  {
    id: 607,
    topic: "Java Core",
    type: "radio",
    question: "Trong `while (x > 0)` của vòng lặp, `x > 0` là gì?",
    options: [
      "Initialization",
      "Iteration expression",
      "Boolean test",
      "Loop block",
    ],
    answer: 2,
    explanation:
      "Vòng lặp `while` thực hiện một khối lệnh nhiều lần miễn là một điều kiện (boolean test) nào đó còn đúng [119, 137, 138].",
  },
  {
    id: 608,
    topic: "Java Core",
    type: "radio",
    question:
      "Sử dụng `Integer.parseInt()` có thể gây ra loại lỗi nào nếu chuỗi đầu vào không phải là số?",
    options: [
      "Syntax error",
      "Logic error (Bug)",
      "Runtime error (Ngoại lệ)",
      "Compile error",
    ],
    answer: 2,
    explanation:
      "Nếu bạn cố gắng parse một cái gì đó không phải là số, code sẽ 'blow up at runtime' (ném ra ngoại lệ) [139, 140].",
  },
  {
    id: 609,
    topic: "Java Core",
    type: "radio",
    question:
      "Các lỗi logic (Logical errors / Bugs) thường được phát hiện bởi ai?",
    options: [
      "Trình biên dịch (Compiler).",
      "Hệ điều hành.",
      "Chính các lập trình viên (vì chương trình cho kết quả không như mong đợi).",
      "Trình thông dịch (Interpreter).",
    ],
    answer: 2,
    explanation:
      "Lỗi logic xảy ra khi chương trình chạy và cho kết quả không như mong đợi, thường rất khó tìm và chỉ có thể phát hiện bởi chính các lập trình viên [95, 117].",
  },
  {
    id: 610,
    topic: "Java Core",
    type: "code",
    question:
      "Dự đoán kết quả của đoạn mã sau (Pool Puzzle PoolPuzzleOne - dựa trên đáp án đã cho [141]):",
    code: 'class PoolPuzzleOne { public static void main(String [] args) { int x = 0; while ( x < 4 ) { System.out.print("a"); if ( x < 1 ) { System.out.print(" "); } System.out.print("n"); if ( x > 1 ) { System.out.print(" oyster"); x = x + 2; } if ( x == 1 ) { System.out.print("noys"); } if ( x < 1 ) { System.out.print("oise"); } System.out.println(""); x = x + 1; } } }',
    options: [
      "a noise\nannoys\nan oyster",
      "a noise annoys an oyster",
      "an\nannoys\noyster",
      "a noise annoys an oyster\n",
    ],
    answer: 1,
    explanation:
      "Vòng lặp chạy 4 lần (x=0, 1, 2, 3). x=0: 'a n' + 'oise' + '\n'. Output: a noise. x=1: 'an' + 'noys' + '\n'. Output: annoys. x=2: 'an' + ' oyster' + '\n' (x=4). Output: an oyster. x=4: Lặp dừng. Tổng hợp các dòng in (không có newline do `System.out.println(\"\")` chỉ in xuống dòng cuối cùng trong vòng lặp) [141].",
  },
  {
    id: 611,
    topic: "Java Core",
    type: "radio",
    question: "Lệnh `javac HelloWorld.java` thực hiện công việc gì?",
    options: [
      "Chạy chương trình Java.",
      "Thông dịch bytecode.",
      "Biên dịch mã nguồn (.java) thành bytecode (.class).",
      "Gỡ lỗi chương trình.",
    ],
    answer: 2,
    explanation:
      "Javac compiler, converts source code into Java bytecode [69, 142].",
  },
  {
    id: 612,
    topic: "Java Core",
    type: "radio",
    question: "Lệnh `java HelloWorld` thực hiện công việc gì?",
    options: [
      "Tạo tệp .class.",
      "Chạy bytecode (.class) bằng Java interpreter và application loader.",
      "Kiểm tra lỗi cú pháp.",
      "Tạo documentation.",
    ],
    answer: 1,
    explanation:
      "`java interpreter and application loader` được sử dụng để chạy class, bắt đầu từ phương thức `main()` [69, 142].",
  },
  {
    id: 613,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi bạn khai báo một biến `int a, b, c;`, điều này được gọi là gì?",
    options: ["Gán giá trị.", "Khởi tạo.", "Khai báo biến.", "Tính biểu thức."],
    answer: 2,
    explanation:
      "Lệnh `int a, b, c;` khai báo ba biến với các định a, b, và c là kiểu int [143].",
  },
  {
    id: 614,
    topic: "Java Core",
    type: "radio",
    question: "Trong các toán tử logic, `a || b` trả về `true` khi nào?",
    options: [
      "Cả a và b đều là true.",
      "Chỉ a là true.",
      "Ít nhất một trong hai a hoặc b là true.",
      "Cả a và b đều là false.",
    ],
    answer: 2,
    explanation:
      "OR: `a || b` bằng true nếu ít nhất một trong hai a và b là true [77].",
  },
  {
    id: 615,
    topic: "Java Core",
    type: "radio",
    question: "Trong các toán tử so sánh, toán tử `!=` có ý nghĩa gì?",
    options: ["Bằng.", "Không lớn hơn.", "Không bằng.", "Lớn hơn."],
    answer: 2,
    explanation: "Toán tử `!=` có nghĩa là không bằng [144].",
  },
  {
    id: 616,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến `double` được gán cho một biến `int` (ví dụ: `int a = 3.14159`), điều gì xảy ra?",
    options: [
      "Biến `int` tự động nhận giá trị.",
      "Xảy ra lỗi biên dịch (Java không tự động chuyển kiểu từ lớn sang nhỏ).",
      "Giá trị được làm tròn.",
      "Giá trị `null` được gán.",
    ],
    answer: 1,
    explanation:
      "Java tự động thực hiện việc chuyển kiểu (chuyển kiểu tự động) khi gán các giá trị có phạm vi kiểu lớn hơn kiểu của biến được gán. Tuy nhiên, chuyển từ `double` sang `int` cần ép kiểu rõ ràng vì có khả năng mất thông tin [145, 146].",
  },
  {
    id: 617,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong toán học Java, kết quả của phép chia số nguyên `-47 / 5` là gì?",
    options: ["9", "-9", "-10", "-9.4"],
    answer: 1,
    explanation:
      "Thương các số nguyên luôn làm tròn hướng về số 0. `-47 / 5 = -9` [147].",
  },
  {
    id: 618,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong toán học Java, kết quả của phép lấy số dư số nguyên `-47 % 5` là gì?",
    options: ["2", "-2", "0", "1"],
    answer: 1,
    explanation:
      "Để đảm bảo tính chất Euclide $b \times (a / b) + (a % b) = a$, kết quả của phép lấy số dư có thể âm. $-47 = 5 \times (-9) + (-2)$. Kết quả là $-2$ [147].",
  },
  {
    id: 619,
    topic: "Java Core",
    type: "radio",
    question:
      "Tại sao cần khai báo kiểu của biến trong Java (ví dụ: `int` hay `String`)?",
    options: [
      "Để tiết kiệm bộ nhớ Heap.",
      "Để trình biên dịch có thể cảnh báo bạn những lỗi tiềm tàng có thể xảy ra (kiểm tra kiểu).",
      "Để đảm bảo tính đa hình.",
      "Để sử dụng `this` keyword.",
    ],
    answer: 1,
    explanation:
      "Bằng cách xác định kiểu, trình biên dịch có thể cảnh báo bạn những lỗi tiềm tàng có thể xảy ra, ví dụ như khi bạn cố gắng để nhân số nguyên với xâu kí tự [146].",
  },
  {
    id: 620,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong lập trình, lỗi nào xảy ra khi chương trình chạy nhưng không cho kết quả như mong đợi (ví dụ: tính toán sai)?",
    options: [
      "Lỗi biên dịch (Compile-time error).",
      "Lỗi khi chạy (Run-time error).",
      "Lỗi logic (Logical error/Bug).",
      "Lỗi cú pháp (Syntax error).",
    ],
    answer: 2,
    explanation:
      "Lỗi logic xảy ra khi chúng ta chạy chương trình và nó cho kết quả không như mong đợi. Đây là lý do chúng ta có việc làm [95].",
  },
  {
    id: 621,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong `for (int i = 1; i <= N; i++)`, phần `int i = 1` được gọi là gì?",
    options: [
      "Boolean test",
      "Initialization",
      "Iteration expression",
      "Method call",
    ],
    answer: 1,
    explanation:
      "Khởi tạo một biến chỉ số bằng một giá trị nào đó là bước đầu tiên trong vòng lặp `for` [78, 138].",
  },
  {
    id: 622,
    topic: "Java Core",
    type: "radio",
    question:
      "Vòng lặp nào sau đây giống cấu trúc `while` nhưng bỏ qua việc kiểm tra điều kiện trước vòng lặp đầu tiên?",
    options: [
      "`for` loop",
      "`if-else` statement",
      "`do-while` loop",
      "`switch` statement",
    ],
    answer: 2,
    explanation:
      "Cấu trúc `do-while` giống cấu trúc `while` chỉ có điều nó bỏ qua việc kiểm tra điều kiện trước vòng lặp đầu tiên [84].",
  },
  {
    id: 623,
    topic: "Java Core",
    type: "radio",
    question: "Lệnh `javadoc` trong JDK có mục đích gì?",
    options: [
      "Biên dịch mã nguồn.",
      "Tạo documentation tự động từ source code comments.",
      "Chạy ứng dụng Java.",
      "Gỡ lỗi (debugging).",
    ],
    answer: 1,
    explanation:
      "Javadoc documentation generator, automatically generates documentation from source code comments [69].",
  },
  {
    id: 624,
    topic: "Java Core",
    type: "code",
    question:
      "Trong đoạn code sau, sau khi vòng lặp kết thúc, giá trị của `m` là gì?",
    code: "int n = 123456789; int m = 0; while (n != 0) { m = (10 * m) + (n % 10); n = n / 10; }",
    options: ["123456789", "987654321", "0", "1"],
    answer: 1,
    explanation:
      "Đoạn mã này đảo ngược các chữ số của n. Sau khi vòng lặp kết thúc, `m` sẽ là 987654321 [148].",
  },
  {
    id: 625,
    topic: "Java Core",
    type: "radio",
    question: "Trong một chương trình Java, mọi thứ phải nằm trong một cái gì?",
    options: ["Function", "Method", "Class", "Variable"],
    answer: 2,
    explanation: "Trong Java, mọi thứ phải nằm trong một class [69].",
  },
  {
    id: 626,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi gọi một chương trình Java (ví dụ: `java Hi Bob`), `Bob` được truyền vào class dưới dạng gì?",
    options: [
      "Biến `int`.",
      "Tham số của mảng `String[] args` trong `main()`.",
      "Biến `double`.",
      "Một đối tượng `Math`.",
    ],
    answer: 1,
    explanation:
      "Chương trình đọc các đối số trên dòng lệnh mà bạn gõ vào sau tên chương trình, chúng được cung cấp cho Java dưới dạng mảng `String[] args` [149, 150].",
  },
  {
    id: 627,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức `Math.random()` trả về một giá trị trong khoảng nào?",
    options: [
      "[0.0, 1.0]",
      "(0.0, 1.0]",
      "[0.0, 1.0)",
      "Chỉ số nguyên từ 0 đến 1.",
    ],
    answer: 2,
    explanation:
      "Hàm `Math.random()` trả về một số thực ngẫu nhiên trong khoảng [0.0, 1.0) (a pseudo-random real between 0.0 and 1.0) [60, 137].",
  },
  {
    id: 628,
    topic: "Java Core",
    type: "radio",
    question: "Cấu trúc `if (a <= b <= c)` có chạy hợp lệ trong Java không?",
    options: [
      "Có, nếu a, b, c là số nguyên.",
      "Không, cần sử dụng `if (a <= b && b <= c)`.",
      "Chỉ khi sử dụng `instanceof`.",
      "Chỉ khi khai báo `final`.",
    ],
    answer: 1,
    explanation:
      "Không thể dùng `if (a <= b <= c)`. Hãy dùng `if (a <= b && b <= c)` [151].",
  },
  {
    id: 629,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong vòng lặp `while`, điều gì xảy ra nếu điều kiện boolean test luôn đúng?",
    options: [
      "Vòng lặp dừng ngay lập tức.",
      "Vòng lặp trở thành `for` loop.",
      "Chương trình mắc kẹt trong vòng lặp vô hạn.",
      "JVM tự động chạy GC.",
    ],
    answer: 2,
    explanation:
      "Nếu chương trình mắc kẹt trong vòng lặp vô hạn, ta phải thoát khỏi nó bằng cách nhấn Ctrl + C [151].",
  },
  {
    id: 630,
    topic: "Java Core",
    type: "code",
    question:
      "Dự đoán giá trị của `j` sau khi đoạn mã sau kết thúc (i và j là int):",
    code: "for (i = 0, j = 1; i < 10; i++) j += j;",
    options: ["10", "1024", "512", "1"],
    answer: 1,
    explanation:
      "Vòng lặp chạy 10 lần (từ i=0 đến i=9). Mỗi lần, `j` được nhân đôi (j += j là j = 2 * j). Khởi tạo j=1. Kết quả là $1 \times 2^{10} = 1024$ [152].",
  },
  {
    id: 631,
    topic: "Java Core",
    type: "code",
    question:
      'Nếu `String s = "Java"` và `s.equals("java")` được gọi, kết quả là gì?',
    options: [
      "true (Vì String là case-insensitive).",
      "false (Vì String là case-sensitive).",
      "Lỗi biên dịch.",
      "NullPointerException.",
    ],
    answer: 1,
    explanation:
      "Phương thức `equals()` so sánh nội dung chuỗi (case-sensitive). 'Java' khác 'java', nên trả về false.",
  },
  {
    id: 632,
    topic: "Java Core",
    type: "radio",
    question:
      "Lớp nào là lớp phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ (internally)?",
    options: ["LinkedList", "Vector", "ArrayList", "HashMap"],
    answer: 2,
    explanation:
      "ArrayList là class phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ [31, 32].",
  },
  {
    id: 633,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng hằng số (constants) trong chương trình (ví dụ: `final int SUITS = 4;`) là gì?",
    options: [
      "Làm cho mã khó bảo trì hơn.",
      "Làm cho mã nguồn khó hiểu hơn.",
      "Tránh việc sử dụng các 'hardwired constants' rải khắp chương trình, giúp chương trình dễ bảo trì hơn.",
      "Buộc các biến phải là `private`.",
    ],
    answer: 2,
    explanation:
      "Các giá trị như 4, 13 và 52 nên được đưa vào các biến hằng số vì các giá trị này có xu hướng rải khắp chương trình của bạn, làm cho chương trình khó bảo trí [153].",
  },
  {
    id: 634,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong lập trình mảng, các chỉ số mảng được đánh số bắt đầu từ đâu?",
    options: [
      "1",
      "0",
      "Tùy thuộc vào hệ điều hành.",
      "Tùy thuộc vào kích thước mảng.",
    ],
    answer: 1,
    explanation: "Trong Java, các chỉ số mảng được đánh số từ 0 [154, 155].",
  },
  {
    id: 635,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu chương trình Java cố gắng sử dụng chỉ số mảng không nằm giữa 0 và chiều dài mảng trừ đi một?",
    options: [
      "Lỗi biên dịch.",
      "Java sẽ sinh ngoại lệ `ArrayIndexOutOfBoundsException` và chấm dứt chương trình.",
      "Chỉ số đó tự động được làm tròn.",
      "Mảng tự động tăng kích thước.",
    ],
    answer: 1,
    explanation:
      "Bất cứ khi nào chương trình dùng chỉ số mảng không nằm giữa 0 và chiều dài mảng trừ đi một, Java sẽ sinh ngoại lệ `ArrayIndexOutOfBoundsException` và chấm dứt chương trình [156].",
  },
  {
    id: 636,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi gán `String[] months = { "Jan", "Feb", ... };`, kiểu khởi tạo mảng này là gì?',
    options: [
      "Khởi tạo tại runtime.",
      "Khởi tạo tại thời gian biên dịch (compile time).",
      "Khởi tạo động.",
      "Không hợp lệ.",
    ],
    answer: 1,
    explanation:
      "Khi chúng ta có một số lượng nhỏ các giá trị lưu trữ trong mảng, chúng ta có thể khởi tạo mảng bằng cách liệt kê các giá trị trong dấu ngoặc nhọn (Đặt giá trị mảng tại thời gian biên dịch) [157].",
  },
  {
    id: 637,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi Java in địa chỉ bộ nhớ của một mảng (ví dụ: `System.out.println(a)`), nó in ra dưới dạng gì?",
    options: [
      "Địa chỉ vật lý.",
      "Một số nguyên hệ thập lục phân (ví dụ: @f62373).",
      "Các phần tử của mảng.",
      "Địa chỉ Stack.",
    ],
    answer: 1,
    explanation:
      "Java in địa chỉ trong bộ nhớ của mảng dưới dạng một số nguyên hệ thập lục phân [156].",
  },
  {
    id: 638,
    topic: "Java Core",
    type: "radio",
    question:
      "Sử dụng mảng để lưu trữ các giá trị đã tính toán trước (ví dụ: chuỗi Harmonic) là một ví dụ về việc đánh đổi yếu tố nào?",
    options: [
      "Tính linh hoạt lấy tính kế thừa.",
      "Thời gian biên dịch lấy thời gian chạy.",
      "Không gian (bộ nhớ) lấy thời gian tính toán.",
      "Tính trừu tượng lấy tính đóng gói.",
    ],
    answer: 2,
    explanation:
      "Tính toán trước giá trị theo cách trên là một ví dụ về việc đánh đổi không gian lấy thời gian tính toán: bằng cách đầu tư không gian (mảng để lưu các giá trị), chúng ta tiết kiệm thời gian [158].",
  },
  {
    id: 639,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mảng hai chiều, cách truy xuất số phần tử của dòng thứ `i` (độ dài dòng) là gì?",
    options: ["`a.length`", "`a[i].length`", "`a.size()`", "`a[i].size()`"],
    answer: 1,
    explanation:
      "Mảng nhiều chiều có độ dài các dòng khác nhau, khi đó ta sử dụng `a[i].length` để truy xuất số phần tử của dòng thứ i [159].",
  },
  {
    id: 640,
    topic: "Java Core",
    type: "code",
    question:
      "Trong phép nhân ma trận (c[i][j] = tích vô hướng của dòng i của a[][] với cột j của b[][]), số cột của ma trận đầu (a) phải bằng cái gì của ma trận thứ hai (b) để phép nhân có nghĩa?",
    code: "double[][] c = new double[N][N]; for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { for (int k = 0; k < N; k++) { c[i][j] += a[i][k]*b[k][j]; } } }",
    options: [
      "Số dòng.",
      "Số cột.",
      "Kích thước của `c`.",
      "Số lượng phần tử.",
    ],
    answer: 0,
    explanation:
      "Để phép nhân có nghĩa, số cột của ma trận đầu phải bằng số dòng của ma trận thứ hai để các phép tính tích vô hướng hợp lệ [160].",
  },
  {
    id: 641,
    topic: "Java Core",
    type: "radio",
    question:
      "Để tạo ra hiệu ứng chuyển động (hoạt hình) trên màn hình bằng thư viện `StdDraw`, phương thức nào cho phép kiểm soát các lệnh vẽ trên màn hình và tạm dừng?",
    options: ["`paint()`", "`draw()`", "`show()`", "`animate()`"],
    answer: 2,
    explanation:
      "Thư viện `StdDraw` có thêm lệnh `show()` để tạo hiệu ứng chuyển động [161, 162].",
  },
  {
    id: 642,
    topic: "Java Core",
    type: "radio",
    question: "Trong hệ tọa độ `StdDraw`, vị trí `(0, 0)` mặc định nằm ở đâu?",
    options: [
      "Phía trên bên trái (Top-left).",
      "Phía dưới bên trái (Bottom-left).",
      "Chính giữa.",
      "Phía dưới bên phải.",
    ],
    answer: 1,
    explanation:
      "StdDraw sắp xếp các trục tọa độ Descartes với `(0, 0)` ở phía dưới bên trái [163].",
  },
  {
    id: 643,
    topic: "Java Core",
    type: "radio",
    question: "Các lệnh vẽ `StdDraw` mặc định sẽ vẽ với màu sắc nào?",
    options: [
      "Màu trắng trên nền đen.",
      "Màu đen trên nền trắng.",
      "Màu xanh dương.",
      "Màu đỏ.",
    ],
    answer: 1,
    explanation:
      "Các đoạn thẳng và điểm mặc định sẽ có màu đen trên nền trắng [164].",
  },
  {
    id: 644,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong lập trình đồ họa, để tạo cảm giác chuyển động, cần thực hiện các bước nào sau khi tính toán vị trí mới?",
    options: [
      "Chỉ vẽ vật thể ở vị trí mới.",
      "Xóa phông vẽ, vẽ vật thể ở vị trí mới, và dừng hình trong khoảng thời gian ngắn.",
      "Gọi `System.gc()`.",
      "Chỉ cần gọi `new` cho object.",
    ],
    answer: 1,
    explanation:
      "Các bước tạo cảm giác chuyển động là: Tính vị trí mới, Xóa phông vẽ, Vẽ quả bóng ở vị trí mới, Dừng hình trong khoảng thời gian ngắn [162].",
  },
  {
    id: 645,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong xử lý âm thanh, tần số 440 hertz tương ứng với nốt nhạc nào?",
    options: ["Nốt C.", "Nốt La (A).", "Nốt G.", "Nốt D."],
    answer: 1,
    explanation:
      "Nốt La (ký hiệu A) chỉ đơn giản là một sóng hình sin, dao động ở tần số 440 lần mỗi giây [165].",
  },
  {
    id: 646,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì xảy ra nếu bạn tăng gấp đôi tần số của một nốt nhạc?",
    options: [
      "Âm lượng tăng gấp đôi.",
      "Tần số giảm một quãng tám.",
      "Tần số di chuyển lên một quãng tám.",
      "Âm thanh biến mất.",
    ],
    answer: 2,
    explanation:
      "Khi bạn tăng gấp đôi hoặc giảm một nửa tần số, bạn di chuyển lên hoặc xuống một quãng tám trên phổ nhạc [165].",
  },
  {
    id: 647,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong I/O chuẩn, điều gì xảy ra nếu chương trình cố gắng đọc dữ liệu từ đầu vào chuẩn sau khi nó đã hết dữ liệu?",
    options: [
      "Chương trình chạy bình thường.",
      "Bạn sẽ nhận được lỗi `java.lang.RuntimeException: Tried to read from empty stdin`.",
      "Nó đọc giá trị `null`.",
      "Nó đọc giá trị 0.",
    ],
    answer: 1,
    explanation:
      "Nếu chương trình cố gắng đọc dữ liệu từ đầu vào chuẩn sau khi nó đã hết dữ liệu, bạn sẽ nhận được lỗi `java.lang.RuntimeException: Tried to read from empty stdin` [166].",
  },
  {
    id: 648,
    topic: "Java Core",
    type: "code",
    question:
      "Dự đoán giá trị của `y` sau khi đoạn mã sau kết thúc (biến `x` và `y` là `int`):",
    code: 'int x = 0; int y = 0; while ( x < 5 ) { System.out.print(x + "" + y +" "); x = x + 1; y = x - y; }',
    options: [
      "00 11 21 32 42",
      "00 11 23 36 410",
      "11 21 32 42 53",
      "Lỗi logic",
    ],
    answer: 0,
    explanation:
      "Lần lặp: (x, y) bắt đầu từ (0, 0). (0, 0) -> x=1, y=1. (1, 1) -> x=2, y=2-1=1. (2, 1) -> x=3, y=3-1=2. (3, 2) -> x=4, y=4-2=2. (4, 2) -> x=5, y=5-2=3. Kết quả in ra: 00 11 21 32 42 [131].",
  },
  {
    id: 649,
    topic: "Java Core",
    type: "code",
    question:
      "Dự đoán giá trị của `y` sau khi đoạn mã sau kết thúc (biến `x` và `y` là `int`):",
    code: 'int x = 0; int y = 0; while ( x < 5 ) { System.out.print(x + "" + y +" "); x = x + 1; y = y + x; }',
    options: [
      "00 11 23 36 410",
      "00 11 21 32 42",
      "02 14 26 38",
      "11 21 32 42 53",
    ],
    answer: 0,
    explanation:
      "Lần lặp: (x, y) bắt đầu từ (0, 0). (0, 0) -> x=1, y=0+1=1. (1, 1) -> x=2, y=1+2=3. (2, 3) -> x=3, y=3+3=6. (3, 6) -> x=4, y=6+4=10. (4, 10) -> x=5, y=10+5=15. Kết quả in ra: 00 11 23 36 410 [167].",
  },
  {
    id: 650,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong lập trình hướng đối tượng, việc chuyển từ thế giới thủ tục (procedural world) sang thế giới đối tượng (object-oriented world) được thực hiện bằng cách nào?",
    options: [
      "Viết tất cả code trong `main()`.",
      "Sử dụng các kiểu dữ liệu nguyên thủy.",
      "Rời khỏi `main()` và bắt đầu tạo các object của riêng mình.",
      "Chỉ sử dụng các vòng lặp `while`.",
    ],
    answer: 2,
    explanation:
      "Chúng ta phải rời khỏi thế giới thủ tục, thoát khỏi `main()`, và bắt đầu tạo ra các object của riêng mình [132].",
  },
  {
    id: 651,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về `instance variable` (biến thể hiện)?",
    options: [
      "Chúng luôn là `public`.",
      "Chúng có giá trị khác nhau giữa các object khác nhau (nếu không phải `static`).",
      "Chúng sống trên Stack.",
      "Chúng không thể được thay đổi tại runtime.",
    ],
    answer: 1,
    explanation:
      "Giá trị của biến thể hiện có thể khác nhau giữa các object khác nhau [168]. Biến thể hiện đại diện cho 'state' (trạng thái) [168].",
  },
  {
    id: 652,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào là cần thiết để chuyển đổi String thành int khi đọc input từ command-line (ví dụ: trong `main`)?",
    options: [
      "System.out.println()",
      "Integer.parseInt()",
      "Math.random()",
      "String.valueOf()",
    ],
    answer: 1,
    explanation:
      "Theo quy ước, cả Java và các hệ điều hành dùng các đối số dòng lệnh như các xâu, vì vậy nếu chúng ta có ý định coi đối số là một con số, chúng tôi sử dụng một lệnh như `Integer.parseInt()` để chuyển đổi nó từ String sang kiểu thích hợp [150].",
  },
  {
    id: 653,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về `abstract class`?",
    options: [
      "Nó có thể được khởi tạo (instantiated).",
      "Nó không thể được khởi tạo (can’t be instantiated).",
      "Nó không thể chứa các phương thức concrete.",
      "Nó phải kế thừa một interface.",
    ],
    answer: 1,
    explanation:
      "Abstract classes (lớp trừu tượng) không thể được khởi tạo [5, 169].",
  },
  {
    id: 654,
    topic: "Java Core",
    type: "code",
    question: "Dự đoán kết quả in ra của đoạn mã sau (với `x` là 3):",
    code: 'int x = 3; if (x > 2) { System.out.print("a"); } x = x - 1; System.out.print("-"); if (x == 2) { System.out.print("b c"); }',
    options: ["a-b c", "a-", "b c", "a-b"],
    answer: 0,
    explanation:
      "x=3: `if (x > 2)` đúng, in 'a'. x=2. in '-'. `if (x == 2)` đúng, in 'b c'. Output: a-b c [85].",
  },
  {
    id: 655,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong ngữ cảnh xử lý ngoại lệ, việc ném ngoại lệ (throwing an exception) có nghĩa là gì?",
    options: [
      "Compiler báo lỗi cú pháp.",
      "JVM tạo ra một Object Ngoại lệ và chuyển nó cho hệ thống runtime.",
      "GC thu hồi bộ nhớ.",
      "Sử dụng từ khóa `finally`.",
    ],
    answer: 1,
    explanation:
      "Exceptions say 'something bad may have happened...'. Throwing an exception là khi JVM tạo ra một Object Ngoại lệ và chuyển nó cho hệ thống runtime [148, 170].",
  },
  {
    id: 656,
    topic: "Java Core",
    type: "radio",
    question:
      "Nguyên tắc 'handle or declare law' (xử lý hoặc khai báo luật) áp dụng cho loại ngoại lệ nào?",
    options: [
      "Unchecked Exceptions (Runtime Exceptions).",
      "Errors.",
      "Checked Exceptions.",
      "Lỗi Logic (Bugs).",
    ],
    answer: 2,
    explanation:
      "The compiler guarantees (it checks) that you’re aware of the risks [171]. Checked Exceptions buộc bạn phải xử lý hoặc khai báo (`handle or declare law`) [172].",
  },
  {
    id: 657,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng gọi một phương thức trên một biến tham chiếu có giá trị là `null`?",
    options: [
      "Lỗi biên dịch.",
      "Ném ra ngoại lệ `NullPointerException`.",
      "Trả về giá trị 0.",
      "Object đó tự động được khởi tạo.",
    ],
    answer: 1,
    explanation:
      "Việc cố gắng gọi phương thức trên một tham chiếu `null` sẽ dẫn đến `NullPointerException` (Implicit knowledge based on Runtime Error context) [13].",
  },
  {
    id: 658,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong JDK, công cụ nào tự động tạo documentation từ source code comments?",
    options: ["javac", "java", "jdb", "javadoc"],
    answer: 3,
    explanation:
      "javadoc documentation generator, automatically generates documentation from source code comments [69].",
  },
  {
    id: 659,
    topic: "Java Core",
    type: "radio",
    question: "Trong Java, các biến nào được lưu trữ trên Heap?",
    options: [
      "Biến cục bộ (Local variables).",
      "Tham chiếu cục bộ.",
      "Tất cả các object.",
      "Tham số method.",
    ],
    answer: 2,
    explanation:
      "Tất cả các object được tạo trong Java đều nằm trong khu vực bộ nhớ được gọi là The Heap [100, 109].",
  },
  {
    id: 660,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu bạn muốn gọi một method mà không cần tạo object của class đó, bạn nên sử dụng từ khóa nào cho method?",
    options: ["private", "final", "static", "abstract"],
    answer: 2,
    explanation:
      "Phương thức static lý tưởng được sử dụng để tạo một phương thức không cần truy cập bất kỳ trường nào trong đối tượng [126, 173]. Ví dụ điển hình là `Math.random()` [174].",
  },
  {
    id: 661,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, phép toán `a = a + b` có thể gây ra lỗi biên dịch nếu `a` và `b` có kiểu khác nhau. Tuy nhiên, phép toán nào sau đây hợp lệ ngay cả khi `a` là `int` và `b` là `double`?",
    options: ["`a = a + b;`", "`a = (int) b;`", "`a += b;`", "`a = b;`"],
    answer: 2,
    explanation:
      "Câu lệnh gán `a += b` tương đương với `a = (int) (a + b)` nếu a có kiểu int. Như vậy nếu b là double thì `a += b` hợp lệ trong khi `a = a + b` gây lỗi biên dịch [175].",
  },
  {
    id: 662,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là SAI về các biến `private`?",
    options: [
      "Chúng giúp tạo ra tính đóng gói (encapsulation).",
      "Chúng có thể được truy cập trực tiếp từ bên ngoài class.",
      "Chỉ setters mới nên cập nhật chúng.",
      "Tôi luôn giữ các biến của mình là `private` [176].",
    ],
    answer: 1,
    explanation:
      "Biến private không thể được truy cập trực tiếp từ bên ngoài class [176]. Nếu bạn muốn xem chúng, bạn phải nói chuyện với các methods của class [176].",
  },
  {
    id: 663,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi mô phỏng quả bóng nảy ra khỏi tường trong `DeluxeBouncingBall`, hiệu ứng này được thực hiện bằng cách nào?",
    options: [
      "Tăng cường bán kính của bóng.",
      "Thay đổi tọa độ `rx` và `ry` thành 0.",
      "Thay đổi vận tốc hướng x từ `vx` sang `-vx` (hoặc y từ `vy` sang `-vy`).",
      "Gọi phương thức `sound()`.",
    ],
    answer: 2,
    explanation:
      "Khi bóng chạm bức tường thẳng đứng (chiều y), chúng ta chỉ cần thay đổi vận tốc hướng x từ `vx` sang `-vx` và ngược lại [162].",
  },
  {
    id: 664,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình luồng I/O, điều gì làm cho chương trình kém hiệu quả hơn vì mỗi yêu cầu đọc hoặc ghi được xử lý trực tiếp bởi hệ điều hành?",
    options: [
      "Sử dụng Byte streams.",
      "Sử dụng Character streams.",
      "I/O có đệm (buffered I/O).",
      "I/O không đệm (unbuffered I/O).",
    ],
    answer: 3,
    explanation:
      "I/O không đệm làm cho chương trình kém hiệu quả hơn vì mỗi yêu cầu đọc hoặc ghi được xử lý trực tiếp bởi HĐH [3, 177].",
  },
  {
    id: 665,
    topic: "Java Core",
    type: "radio",
    question: "Đâu là ví dụ về Lỗi Logic (Bug)?",
    options: [
      "Thiếu dấu chấm phẩy.",
      "Sử dụng chỉ số mảng không hợp lệ.",
      "Phép chia cho 0.",
      "Chương trình chạy nhưng tính toán sai công thức.",
    ],
    answer: 3,
    explanation:
      "Lỗi logic: Chương trình chỉ không thực hiện những gì bạn mong đợi [117].",
  },
  {
    id: 666,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào không thể được ép kiểu thành `int`?",
    options: ["char", "byte", "boolean", "short"],
    answer: 2,
    explanation:
      "Boolean không thể được ép kiểu thành các kiểu số nguyên. (Implicit knowledge: Java does not allow implicit or explicit casting between boolean and numerical types).",
  },
  {
    id: 667,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là đúng về việc ghi đè phương thức (Method Overriding)?",
    options: [
      "Nó xảy ra trong cùng một class.",
      "Nó là việc định nghĩa lại một phương thức đã được kế thừa từ lớp cha với cùng chữ ký phương thức.",
      "Nó được thực hiện bằng cách thay đổi access modifier thành `private`.",
      "Nó không thể xảy ra nếu phương thức lớp cha là `static`.",
    ],
    answer: 1,
    explanation:
      "Ghi đè (Overriding) về cơ bản có nghĩa là khai báo lại phương thức đó trong lớp con và định nghĩa lại những gì chúng nên làm, với cùng một chữ ký phương thức [178, 179].",
  },
  {
    id: 668,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi nào thì một constructor mặc định (default constructor) được tự động tạo bởi Java?",
    options: [
      "Khi class không có bất kỳ constructor nào khác được định nghĩa.",
      "Luôn luôn.",
      "Khi class được khai báo là 'abstract'.",
      "Không bao giờ.",
    ],
    answer: 0,
    explanation:
      "Nếu bạn không tạo một constructor mặc định, Java sẽ tự động giả định có một constructor mặc định không làm gì cả [9, 99].",
  },
  {
    id: 669,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến được khai báo mà không có access modifier (như `public`, `private`), nó có access modifier mặc định là gì?",
    options: ["public", "protected", "default (package-private)", "private"],
    answer: 2,
    explanation:
      "Nếu không chỉ định một access modifier, class/method/variable sẽ có thể truy cập được bởi tất cả các class khác trong cùng một package (default/package-private) [122, 180].",
  },
  {
    id: 670,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong `Object` class được Garbage Collector gọi trên đối tượng MỘT LẦN trước khi thu thập rác?",
    options: ["`gc()`", "`delete()`", "`finalize()`", "`dispose()`"],
    answer: 2,
    explanation:
      "Trước khi hủy một đối tượng, Garbage Collector gọi phương thức `finalize()` trên đối tượng đó để thực hiện các hoạt động dọn dẹp [178, 181].",
  },
  {
    id: 671,
    topic: "Java Core",
    type: "radio",
    question:
      "Để truy cập các biến instance có cùng tên với tham số trong constructor, từ khóa nào được sử dụng?",
    options: ["`super`", "`this`", "`new`", "`static`"],
    answer: 1,
    explanation:
      "Sử dụng `this` keyword để tham chiếu current class instance variables khi tên trùng với tham số [98, 99].",
  },
  {
    id: 672,
    topic: "Java Core",
    type: "radio",
    question:
      "Việc sử dụng toán tử `+` để nối một String với một kiểu nguyên thủy được gọi là gì?",
    options: [
      "Ép kiểu rõ ràng.",
      "Chuyển đổi kiểu tự động (Automatic conversion) thành String.",
      "Unboxing.",
      "Serialization.",
    ],
    answer: 1,
    explanation:
      "Kiểu String tuân thủ một số luật đặc biệt. Một trong số đó là bạn có thể chuyển đổi bất kỳ loại dữ liệu nào thành một String bằng cách sử dụng toán tử `+` [60].",
  },
  {
    id: 673,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong xử lý ngoại lệ, nếu bạn có nhiều `catch` blocks, block nào nên được đặt trước?",
    options: [
      "Exception chung nhất (ví dụ: `Exception`).",
      "Lớp con của Exception (ví dụ: `FileNotFoundException`).",
      "Thứ tự không quan trọng.",
      "Chỉ cần `finally` block.",
    ],
    answer: 1,
    explanation:
      "Nếu cả lớp cơ sở và lớp dẫn xuất đều được bắt, catch block của lớp dẫn xuất phải xuất hiện trước lớp cơ sở [13].",
  },
  {
    id: 674,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì là đúng về `System.out.println()` và `StdOut.println()`?",
    options: [
      "Chúng hoàn toàn giống nhau.",
      "`System.out.println()` hoạt động với Unicode, còn `StdOut.println()` thì không.",
      "`StdOut.println()` bắt buộc định dạng địa phương theo Locale.US để thống nhất với `StdIn`.",
      "`StdOut` chỉ dùng cho byte stream.",
    ],
    answer: 2,
    explanation:
      "`StdOut` bắt buộc định dạng địa phương theo Locale.US để thống nhất với `StdIn` [182].",
  },
  {
    id: 675,
    topic: "Java Core",
    type: "radio",
    question:
      'Khi bạn tạo String bằng từ khóa `new String("Java")`, điều gì xảy ra?',
    options: [
      "Chuỗi được lưu trữ duy nhất trong String Pool.",
      "Chuỗi mới được tạo trên Heap.",
      "Tham chiếu được trả về từ String Pool.",
      "Luôn luôn gây ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Sử dụng từ khóa `new` tạo một chuỗi mới trong heap [183, 184].",
  },
  {
    id: 676,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một phương thức được đánh dấu là `static`, bạn có thể gọi nó như thế nào?",
    options: [
      "Chỉ sau khi tạo một object.",
      "Thông qua `this` keyword.",
      "Sử dụng tên Class.",
      "Thông qua `super` keyword.",
    ],
    answer: 2,
    explanation:
      "Phương thức static thuộc về class và có thể được truy cập trực tiếp thông qua tên class [174].",
  },
  {
    id: 677,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong `ContactManager` (ví dụ từ nguồn), class `Contact` đại diện cho khái niệm nào trong OOP?",
    options: [
      "Hành vi (Behavior).",
      "Một đối tượng (Object) đại diện cho một thực thể thế giới thực.",
      "Một hàm `main()`.",
      "Một biến `primitive`.",
    ],
    answer: 1,
    explanation:
      "Ví dụ cho thấy `Contact` là một class mà từ đó object `friend` được tạo ra để mô hình hóa một người bạn [185].",
  },
  {
    id: 678,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích của `jdb debugger` trong JDK là gì?",
    options: [
      "Biên dịch mã.",
      "Tạo documentation.",
      "Gỡ lỗi (debugging) chương trình Java.",
      "Chạy bytecode.",
    ],
    answer: 2,
    explanation:
      "`jdb debugger` là một trong những thành phần chính của JDK [69].",
  },
  {
    id: 679,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ, instance variables (biến thể hiện) của một object được lưu trữ ở đâu?",
    options: ["Stack", "Heap", "Static memory", "ROM"],
    answer: 1,
    explanation:
      "Instance variables live (sống) on the heap (nằm trong object) [1].",
  },
  {
    id: 680,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của `Copy constructor` (ví dụ: `public Game(Game g)`) là gì?",
    options: [
      "Thiết lập các hằng số.",
      "Khởi tạo một object mới bằng cách sử dụng một object đã được tạo trước đó cùng loại.",
      "Gọi constructor của lớp cha.",
      "Tạo object trên Stack.",
    ],
    answer: 1,
    explanation:
      "A class object can be initialized with another previously created object of the same class [68].",
  },
  {
    id: 681,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi Downcasting (Ép kiểu xuống), hành động này có thể được thực hiện như thế nào?",
    options: [
      "Tự động.",
      "Thủ công (manual).",
      "Chỉ dùng cho kiểu nguyên thủy.",
      "Chỉ dùng cho `final` class.",
    ],
    answer: 1,
    explanation: "Downcasting phải luôn được thực hiện thủ công [131, 186].",
  },
  {
    id: 682,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là SAI về `Interface` trong Java (trước JDK 8)?",
    options: [
      "Interface được sử dụng để đạt được đa kế thừa.",
      "Tất cả các trường là `public static final`.",
      "Tất cả các phương thức là `public abstract`.",
      "Interface có thể chứa các constructor.",
    ],
    answer: 3,
    explanation:
      "Interface được Java giới thiệu để giải quyết vấn đề đa kế thừa [135]. Interface không thể có constructor. (Lưu ý: Phương thức trong interface ngầm định là public và abstract, trừ default/static methods từ JDK 8 [133]).",
  },
  {
    id: 683,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu một biến được khai báo bên trong khối `if` statement, phạm vi (scope) của biến đó là gì?",
    options: [
      "Toàn bộ chương trình.",
      "Toàn bộ class.",
      "Chỉ bên trong khối lệnh đó (Block Scope).",
      "Chỉ trong `main()`.",
    ],
    answer: 2,
    explanation:
      "Biến cục bộ chỉ tồn tại trong khối code hoặc method mà chúng được khai báo [89].",
  },
  {
    id: 684,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích chính của việc sử dụng các method `setter` (mutators) là gì?",
    options: [
      "Trả về giá trị của một field.",
      "Tạo ra một object mới.",
      "Kiểm soát khi nào và bằng cách nào một field được thay đổi (hỗ trợ Encapsulation).",
      "Giới hạn khả năng kế thừa.",
    ],
    answer: 2,
    explanation:
      "Setters (Mutators) được dùng để thiết lập hoặc thay đổi giá trị, giúp kiểm soát việc thay đổi dữ liệu [87, 118, 119].",
  },
  {
    id: 685,
    topic: "Java Core",
    type: "radio",
    question: "Đâu là một ví dụ về Lỗi biên dịch (Compile-time error)?",
    options: [
      "Sử dụng chỉ số mảng không hợp lệ.",
      "Sử dụng ngoại lệ checked mà không khai báo/xử lý.",
      "Phép chia cho 0.",
      "Lỗi logic.",
    ],
    answer: 1,
    explanation:
      "Lỗi biên dịch được trình biên dịch thông báo khi dịch chương trình, ví dụ: vi phạm các quy tắc ngữ pháp (syntax errors) [95, 117]. Lỗi checked exception không được khai báo/xử lý cũng là lỗi biên dịch [187].",
  },
  {
    id: 686,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong xử lý tín hiệu số, độ to của âm thanh (Loudness) tương ứng với đại lượng nào của sóng âm?",
    options: [
      "Tần số (Frequency).",
      "Trường độ (Duration).",
      "Cường độ/Biên độ (Amplitude).",
      "Pha (Phase).",
    ],
    answer: 2,
    explanation:
      "Cường độ hay biên độ (Amplitude) tương ứng với độ to của âm thanh [165].",
  },
  {
    id: 687,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong thiết kế, nguyên tắc nào nói rằng các thực thể phần mềm nên mở để mở rộng nhưng đóng để sửa đổi?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 1,
    explanation:
      "Open/Closed Principle (OCP): Các thực thể phần mềm nên mở để mở rộng nhưng đóng để sửa đổi [188, 189].",
  },
  {
    id: 688,
    topic: "Java Core",
    type: "radio",
    question: "Các biến `static` được lưu trữ ở đâu?",
    options: [
      "Stack.",
      "Static Memory (hoặc khu vực Metaspace/Heap tương đương trong JVM hiện đại).",
      "String Pool.",
      "ROM.",
    ],
    answer: 1,
    explanation:
      "Biến `static` được lưu trữ trong class và chia sẻ bởi tất cả các object [124, 125].",
  },
  {
    id: 689,
    topic: "Java Core",
    type: "radio",
    question: "Mục đích của việc sử dụng `this()` trong constructor là gì?",
    options: [
      "Để tham chiếu biến instance.",
      "Để gọi constructor của chính class hiện tại (Constructor chaining).",
      "Để gọi constructor của lớp cha.",
      "Để ném ra ngoại lệ.",
    ],
    answer: 1,
    explanation:
      "Sử dụng `this()` để gọi constructor của chính class hiện tại [95, 190, 191].",
  },
  {
    id: 690,
    topic: "Java Core",
    type: "radio",
    question: "Trong xử lý ngoại lệ, `Stack Trace` là gì?",
    options: [
      "Địa chỉ Heap của object.",
      "Danh sách các method đã được gọi, được lưu trữ trên Stack.",
      "Mã bytecode bị lỗi.",
      "Thông tin về Garbage Collector.",
    ],
    answer: 1,
    explanation:
      "Stack Trace là dấu vết của các phương thức được gọi, liên quan đến Stack [192].",
  },
  {
    id: 691,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong `while (x < 5)` của vòng lặp, nếu không có câu lệnh thay đổi `x`, điều gì xảy ra?",
    options: [
      "Lỗi logic (vòng lặp vô hạn).",
      "Lỗi biên dịch.",
      "Nó tự động tăng `x`.",
      "Nó gọi `System.gc()`.",
    ],
    answer: 0,
    explanation:
      "Nếu điều kiện luôn đúng, vòng lặp sẽ là vô hạn (lỗi logic) [86, 151].",
  },
  {
    id: 692,
    topic: "Java Core",
    type: "radio",
    question:
      "Kiểu dữ liệu nào được sử dụng để đọc input từ command line khi dùng `StdIn.readDouble()`?",
    options: [
      "String arguments.",
      "Input stream.",
      "Character streams.",
      "Print streams.",
    ],
    answer: 1,
    explanation:
      "Thư viện đầu vào chuẩn (`StdIn`) cài đặt một luồng dữ liệu trừu tượng để đọc các giá trị [193].",
  },
  {
    id: 693,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong Java, các biến nào là `final` một cách ngầm định (implicitly) trong một `Interface`?",
    options: [
      "Tất cả các methods.",
      "Tất cả các fields.",
      "Tất cả các classes.",
      "Chỉ các constructor.",
    ],
    answer: 1,
    explanation:
      "Tất cả các trường trong một interface đều ngầm định là public, static, final [135, 136].",
  },
  {
    id: 694,
    topic: "Java Core",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `ArrayList<String>` thay vì mảng `String[]` là gì?",
    options: [
      "ArrayList nhanh hơn.",
      "ArrayList chỉ chấp nhận String.",
      "ArrayList có kích thước động, dễ dàng thêm hoặc xóa phần tử.",
      "ArrayList chỉ được lưu trên Stack.",
    ],
    answer: 2,
    explanation:
      "ArrayList là lựa chọn tốt hơn so với Array nếu bạn không biết chính xác số lượng mục trước (kích thước động) [100, 110, 194].",
  },
  {
    id: 695,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong Iterator được sử dụng để lấy phần tử tiếp theo trong collection?",
    options: ["remove()", "next()", "hasNext()", "get()"],
    answer: 1,
    explanation:
      "Giao diện Iterator của Java có các phương thức hasNext(), next(), remove() [28, 29].",
  },
  {
    id: 696,
    topic: "Java Core",
    type: "radio",
    question:
      "Khi hai class không tương thích cần giao tiếp, mẫu thiết kế cấu trúc (Structural Pattern) nào hoạt động như một cầu nối?",
    options: ["Singleton", "Factory", "Adapter", "Decorator"],
    answer: 2,
    explanation:
      "Adapter pattern giúp các đối tượng có giao diện không tương thích cộng tác bằng cách hoạt động như một cầu nối giữa chúng [43, 44].",
  },
  {
    id: 697,
    topic: "Java Core",
    type: "radio",
    question: "Khái niệm đa tải constructor (Overloaded constructors) là gì?",
    options: [
      "Nhiều constructor có tên khác nhau.",
      "Nhiều constructor trong cùng một class có danh sách tham số khác nhau.",
      "Constructor có thể kế thừa từ lớp cha.",
      "Constructor có thể được gọi bằng toán tử `.`.",
    ],
    answer: 1,
    explanation:
      "Overloaded constructors là có nhiều constructor với danh sách tham số khác nhau [94].",
  },
  {
    id: 698,
    topic: "Java Core",
    type: "radio",
    question: "Điều gì là SAI về `StringBuilder` (tương tự `StringBuffer`)?",
    options: [
      "Nó là chuỗi ký tự có thể sửa đổi.",
      "Nó nên được dùng thay thế `String` khi cần nhiều thay đổi chuỗi.",
      "Nó không phải là object.",
      "Nó hiệu quả hơn khi xây dựng chuỗi lớn.",
    ],
    answer: 2,
    explanation:
      "StringBuffer là chuỗi ký tự có thể sửa đổi [195]. String, StringBuffer, StringBuilder đều là class/object. `StringBuffer` là chuỗi ký tự có thể sửa đổi [105, 195].",
  },
  {
    id: 699,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ, nơi nào lưu trữ các tham chiếu object cục bộ (local object references)?",
    options: ["Heap", "Stack", "Static Memory", "String Pool"],
    answer: 1,
    explanation:
      "Biến cục bộ và tham chiếu cục bộ được lưu trữ trên Stack [35, 103].",
  },
  {
    id: 700,
    topic: "Java Core",
    type: "radio",
    question: "Khi nào thì `Array` phải được khởi tạo bằng `new`?",
    options: [
      "Chỉ khi mảng chứa object.",
      "Luôn luôn, vì mảng được xem là object.",
      "Chỉ khi mảng được khai báo là `static`.",
      "Không bao giờ.",
    ],
    answer: 1,
    explanation:
      "Mảng (Array) là một object [109], do đó phải được khởi tạo bằng `new` (hoặc cú pháp khởi tạo compile-time) [196].",
  },
  {
    id: 701,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong xử lý I/O, lệnh nào sau đây được sử dụng để chuyển hướng đầu vào tiêu chuẩn để `StdIn` đọc dữ liệu từ một tập tin thay vì từ cửa sổ terminal?",
    options: ["`|`", "`>`", "`<`", "`>>`"],
    answer: 2,
    explanation:
      "Dấu `<` chuyển hướng đầu vào chuẩn sang tập tin đứng sau nó [197].",
  },
  {
    id: 702,
    topic: "Java Core",
    type: "radio",
    question:
      "Phương thức nào trong các lớp Wrapper được sử dụng để chuyển đổi String thành object Wrapper (ví dụ: `String '12' thành Integer 12`)?",
    options: ["`typeValue()`", "`parseInt()`", "`valueOf()`", "`toObject()`"],
    answer: 2,
    explanation:
      "`valueOf()` được dùng để trả về một object của kiểu tương ứng giữ giá trị của String .",
  },
  {
    id: 703,
    topic: "Java Core",
    type: "radio",
    question:
      "Nếu bạn muốn vẽ một điểm tại vị trí `(x, y)` bằng `StdDraw`, lệnh cơ bản là gì?",
    options: [
      "`StdDraw.line(x, y, x, y)`",
      "`StdDraw.circle(x, y)`",
      "`StdDraw.point(x, y)`",
      "`StdDraw.show(x, y)`",
    ],
    answer: 2,
    explanation:
      "Lệnh `StdDraw.point(x, y)` vẽ một điểm ở vị trí `(x, y)` [164].",
  },
  {
    id: 704,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình Generics, điều gì giải quyết vấn đề cần phải ép kiểu (casting) liên tục khi sử dụng `Object`?",
    options: [
      "Sử dụng `static`.",
      "Generics loại bỏ nhu cầu ép kiểu.",
      "Sử dụng `final`.",
      "Autoboxing.",
    ],
    answer: 1,
    explanation: "Generics giúp loại bỏ nhu cầu ép kiểu [16, 17].",
  },
  {
    id: 705,
    topic: "Java Core",
    type: "radio",
    question:
      "Mẫu thiết kế nào (Design Pattern) được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có?",
    options: ["Singleton", "Factory Method", "Prototype", "Adapter"],
    answer: 2,
    explanation:
      "Prototype được sử dụng để tạo đối tượng mới bằng cách sao chép một đối tượng hiện có [41, 42].",
  },
  {
    id: 706,
    topic: "Java Core",
    type: "radio",
    question:
      "Điều gì là đúng về việc sử dụng `String[] args` trong phương thức `main()`?",
    options: [
      "Nó là tùy chọn và có thể bỏ qua.",
      "Nó là mảng chứa các đối số dòng lệnh (command-line arguments).",
      "Nó chỉ chứa các giá trị `int`.",
      "Nó luôn được khởi tạo là `null`.",
    ],
    answer: 1,
    explanation:
      "Mảng này là chuỗi các đối số dòng lệnh mà chúng ta đánh vào trên ứng dụng terminal [150].",
  },
  {
    id: 707,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong JDK, trình biên dịch nào chuyển đổi mã nguồn thành bytecode?",
    options: ["java", "javac", "jdb", "javadoc"],
    answer: 1,
    explanation:
      "`javac compiler`, converts source code into Java bytecode [69].",
  },
  {
    id: 708,
    topic: "Java Core",
    type: "radio",
    question:
      "Trong mô hình bộ nhớ, kiểu dữ liệu nguyên thủy (primitive data) được lưu trữ ở đâu nếu chúng là biến cục bộ?",
    options: ["Heap", "Stack", "Static Memory", "String Pool"],
    answer: 1,
    explanation:
      "Primitive data (e.g., number, character) không phải là object [113], và biến cục bộ sống trên Stack [35, 103].",
  },
  {
    id: 709,
    topic: "Java Core",
    type: "radio",
    question:
      "Cấu trúc nào cho phép tạo ra nhiều constructor có cùng tên trong cùng một class?",
    options: [
      "Method Overriding.",
      "Method Overloading.",
      "Constructor Chaining.",
      "Inheritance.",
    ],
    answer: 1,
    explanation:
      "Overloaded constructors (đa tải constructor) cho phép có nhiều constructor trong class với danh sách tham số khác nhau [94].",
  },
  {
    id: 710,
    topic: "Inheritance",
    type: "radio",
    question:
      "Tính chất nào của Lập trình hướng đối tượng (OOP) cho phép truyền các đặc điểm hoặc đặc tính từ lớp cha (parent) sang lớp con (child)?",
    options: [
      "Encapsulation (Đóng gói)",
      "Polymorphism (Đa hình)",
      "Inheritance (Kế thừa)",
      "Abstraction (Trừu tượng)",
    ],
    answer: 2,
    explanation:
      "Kế thừa là việc truyền các đặc điểm hoặc đặc tính từ lớp cha sang lớp con [1]. Kế thừa là một trong những tính năng chính của Lập trình hướng đối tượng [2].",
  },
  {
    id: 711,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, từ khóa nào được sử dụng để chỉ định rằng một lớp đang kế thừa từ một lớp khác?",
    options: ["implements", "extends", "inherits", "uses"],
    answer: 1,
    explanation:
      "Để mở rộng một lớp cơ sở, ta thêm cụm từ 'extends' theo sau là tên lớp [3]. Ví dụ: class Checking extends BankAccount [3].",
  },
  {
    id: 712,
    topic: "Inheritance",
    type: "radio",
    question: "Lớp mà các lớp khác kế thừa được gọi là gì?",
    options: [
      "Subclass hoặc Derived class",
      "Specific class",
      "Superclass hoặc Base class",
      "Interface",
    ],
    answer: 2,
    explanation:
      "Lớp được kế thừa (lớp cha) được gọi là Super class hoặc Base class [4], [5]. Nó còn được gọi là General class [4].",
  },
  {
    id: 713,
    topic: "Inheritance",
    type: "radio",
    question: "Lớp kế thừa (extends) từ một lớp khác được gọi là gì?",
    options: [
      "Super class hoặc General class",
      "Base class",
      "Subclass hoặc Derived class",
      "Parent class",
    ],
    answer: 2,
    explanation:
      "Lớp kế thừa là Subclass hoặc Derived class [4], [5]. Nó còn được gọi là Specific class [4].",
  },
  {
    id: 714,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, một lớp có thể kế thừa (extends) tối đa bao nhiêu lớp khác?",
    options: ["Không giới hạn", "Một lớp (đơn kế thừa)", "Hai lớp", "Ba lớp"],
    answer: 1,
    explanation:
      "Java có một hạn chế lớn: một class không thể mở rộng nhiều hơn một class. Nói cách khác, đa kế thừa (multiple inheritance) không được phép trong Java [6], [7].",
  },
  {
    id: 715,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mối quan hệ nào được sử dụng để kiểm tra tính hợp lệ của cây kế thừa?",
    options: [
      "HAS-A relationship",
      "IS-A relationship",
      "PART-OF relationship",
      "USES-A relationship",
    ],
    answer: 1,
    explanation:
      "Nên sử dụng kiểm tra IS-A để xác minh rằng hệ thống phân cấp kế thừa của bạn là hợp lệ. Nếu X mở rộng Y, thì 'X IS-A Y' phải có ý nghĩa [8]. Ví dụ: 'Square IS-A Shape' [9].",
  },
  {
    id: 716,
    topic: "Inheritance",
    type: "radio",
    question:
      "Một lớp con (subclass) kế thừa những thành viên nào của lớp cha (superclass)?",
    options: [
      "Tất cả các trường và phương thức (bao gồm private).",
      "Tất cả các trường và phương thức public.",
      "Chỉ các phương thức public, không bao gồm trường dữ liệu.",
      "Chỉ các thành viên được khai báo là static.",
    ],
    answer: 1,
    explanation:
      "Lớp con kế thừa tất cả các biến instance và phương thức public của lớp cha, nhưng không kế thừa các biến instance và phương thức private [10].",
  },
  {
    id: 717,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong thiết kế hệ thống ngân hàng tài khoản, việc tạo một lớp `BankAccount` chung để chứa `acctNumber` và `balance` giúp đạt được lợi ích nào của kế thừa?",
    options: [
      "Thực thi đa kế thừa.",
      "Giảm thiểu sự lặp lại mã (code repetition).",
      "Đảm bảo tất cả các trường là private.",
      "Ngăn chặn việc ghi đè phương thức.",
    ],
    answer: 1,
    explanation:
      "Ví dụ về tài khoản ngân hàng cho thấy việc sử dụng kế thừa đã cho phép chúng ta giảm thiểu việc lặp lại bất kỳ mã nào [11].",
  },
  {
    id: 718,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra với các thành viên được khai báo là `private` trong lớp cha khi lớp con kế thừa?",
    options: [
      "Chúng được kế thừa và có thể truy cập trực tiếp.",
      "Chúng không được kế thừa.",
      "Chúng được kế thừa nhưng không thể truy cập trực tiếp.",
      "Chúng tự động trở thành `protected` trong lớp con.",
    ],
    answer: 1,
    explanation:
      "Các thành viên private không được kế thừa bởi lớp con [12], [10].",
  },
  {
    id: 719,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong mô hình OOP, khái niệm Đa hình (Polymorphism) liên quan đến kế thừa như thế nào?",
    options: [
      "Nó cho phép các đối tượng lớp con chỉ được tham chiếu bằng kiểu lớp con.",
      "Nó ngăn chặn việc ghi đè phương thức.",
      "Nó cho phép tham chiếu đến các đối tượng tồn tại dưới nhiều tên biến [1].",
      "Nó giới hạn khả năng sử dụng các đối tượng của các lớp khác nhau.",
    ],
    answer: 2,
    explanation:
      "Kế thừa cho phép đa hình [1]. Đa hình cho phép các đối tượng của các lớp khác nhau được xử lý như thể chúng thuộc về một kiểu hoặc nhóm chung (thông qua tham chiếu lớp cha) [11].",
  },
  {
    id: 720,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi một phương thức trong lớp cha được khai báo là `final`, lớp con sẽ bị hạn chế điều gì?",
    options: [
      "Không thể gọi phương thức đó.",
      "Phải khai báo phương thức đó là `static`.",
      "Không thể ghi đè (override) phương thức đó.",
      "Chỉ có thể gọi phương thức đó thông qua từ khóa `super`.",
    ],
    answer: 2,
    explanation:
      "Nếu bạn muốn bảo vệ phương thức của mình khỏi bị ghi đè trong lớp con, bạn có thể thêm tiền tố từ khóa 'final' [13]. Phương thức final không thể bị ghi đè [14].",
  },
  {
    id: 721,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một lớp cha không có constructor mặc định (no-arg constructor) và lớp con không gọi rõ ràng một constructor có tham số của lớp cha?",
    options: [
      "Lỗi biên dịch (compile-time error).",
      "Lớp con sẽ được khởi tạo với giá trị null cho các trường kế thừa.",
      "Chương trình chạy bình thường.",
      "Trình biên dịch tự động tạo một constructor mặc định rỗng cho lớp cha.",
    ],
    answer: 0,
    explanation:
      "Nếu lớp cha không có constructor mặc định, bạn sẽ nhận được lỗi biên dịch nếu constructor của lớp con không gọi rõ ràng constructor của lớp cha bằng `super` [15].",
  },
  {
    id: 722,
    topic: "Inheritance",
    type: "radio",
    question:
      "Đa hình (Polymorphism) cho phép đối tượng của lớp con được đối xử như thể nó là một thể hiện của cả lớp con đó và lớp nào?",
    options: [
      "Chỉ lớp cha của nó",
      "Chỉ lớp con",
      "Tất cả các lớp anh chị em (sibling classes)",
      "Tất cả các lớp cha/siêu lớp (superclasses) của nó",
    ],
    answer: 3,
    explanation:
      "Đa hình cho phép đối tượng của lớp con được đối xử như một instance của cả lớp của chính nó và lớp cha của nó [11]. Thậm chí là của tất cả các lớp siêu lớp (ví dụ: Cat là Mammal, Animal, và Object) [16].",
  },
  {
    id: 723,
    topic: "Inheritance",
    type: "radio",
    question: "Upcasting trong Java là gì?",
    options: [
      "Ép kiểu thủ công đối tượng lớp cha thành lớp con.",
      "Ép kiểu tự động đối tượng lớp con thành kiểu lớp cha.",
      "Chuyển đổi kiểu dữ liệu nguyên thủy sang đối tượng Wrapper.",
      "Chuyển đổi một đối tượng về kiểu `Object` một cách rõ ràng.",
    ],
    answer: 1,
    explanation:
      "Upcasting là khi một đối tượng của lớp con được đối xử như một đối tượng của bất kỳ lớp siêu lớp nào [17]. Upcasting được thực hiện tự động [18], [19].",
  },
  {
    id: 724,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu có khai báo `Cat c = new Cat(); Animal a = c;`, thì `a` là loại tham chiếu nào?",
    options: [
      "Tham chiếu kiểu `Cat`",
      "Tham chiếu kiểu `Animal` trỏ đến đối tượng `Animal`",
      "Tham chiếu kiểu `Animal` trỏ đến đối tượng `Cat`",
      "Lỗi biên dịch",
    ],
    answer: 2,
    explanation:
      "Đây là Upcasting, trong đó tham chiếu kiểu `Animal` (lớp cha) trỏ đến đối tượng `Cat` (lớp con) [20], [21]. Điều này là hợp lệ vì Cat IS-A Animal [16].",
  },
  {
    id: 725,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi một đối tượng lớp con được Upcasting thành kiểu lớp cha, đối tượng đó giữ lại những gì bên trong?",
    options: [
      "Chỉ các thuộc tính và phương thức của lớp cha.",
      "Chỉ các thuộc tính và phương thức mà nó đã ghi đè.",
      "Tất cả các thuộc tính và phương thức của nó (lớp con).",
      "Chỉ các trường static.",
    ],
    answer: 2,
    explanation:
      "Đối tượng giữ lại tất cả các thuộc tính và phương thức của nó một cách nội bộ, nhưng bạn chỉ có thể truy cập những thuộc tính và phương thức thuộc về kiểu lớp cha (reference type) [22].",
  },
  {
    id: 726,
    topic: "Inheritance",
    type: "radio",
    question: "Downcasting trong Java là gì?",
    options: [
      "Ép kiểu tự động từ lớp con lên lớp cha.",
      "Ép kiểu thủ công từ lớp cha về lại kiểu lớp con ban đầu.",
      "Ép kiểu từ kiểu số nguyên sang kiểu số thực.",
      "Ép kiểu một đối tượng về kiểu `Object`.",
    ],
    answer: 1,
    explanation:
      "Downcasting là ép kiểu thủ công đối tượng lớp cha trở lại lớp con ban đầu của nó [17], [22], [23]. Điều này cho phép bạn lấy lại quyền truy cập vào các thuộc tính và phương thức dành riêng cho lớp con [22].",
  },
  {
    id: 727,
    topic: "Inheritance",
    type: "radio",
    question: "Downcasting cần phải được thực hiện như thế nào?",
    options: [
      "Tự động (Implicitly)",
      "Thủ công (Manually) bằng cách sử dụng toán tử cast `()`",
      "Chỉ được thực hiện trong `try-catch` block",
      "Chỉ được thực hiện khi lớp cha là `abstract`",
    ],
    answer: 1,
    explanation:
      "Downcasting phải luôn được thực hiện thủ công [17], [24]. Ví dụ: Cat c2 = (Cat) a; [20].",
  },
  {
    id: 728,
    topic: "Inheritance",
    type: "radio",
    question:
      "Toán tử nào được sử dụng để kiểm tra xem một đối tượng có phải là một thể hiện của một lớp (hoặc lớp con) cụ thể trước khi Downcasting an toàn?",
    options: ["instanceOf", "typeof", "isA", "getClass()"],
    answer: 0,
    explanation:
      "Toán tử `instanceof` được sử dụng để kiểm tra xem một đối tượng có phải là một thể hiện của một class nào đó (hoặc lớp con) hay không, cho phép downcasting an toàn [20], [25].",
  },
  {
    id: 729,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng Downcasting một đối tượng thành một lớp không phải là kiểu thực tế của nó (ví dụ: Ép kiểu một `Mammal` thành `Cat` khi nó không phải là `Cat`)?",
    options: [
      "Lỗi biên dịch.",
      "Chương trình chạy bình thường nhưng có thể có hành vi không mong muốn.",
      "Ném ra ngoại lệ `java.lang.ClassCastException` khi chạy.",
      "Trình biên dịch tự động chuyển đổi nó sang kiểu `Object`.",
    ],
    answer: 2,
    explanation:
      "Mã này vượt qua quá trình biên dịch, nhưng ném ra ngoại lệ `ClassCastException` khi chạy vì lớp cha không phải là một thể hiện của lớp con mà ta cố gắng ép kiểu [26], [23].",
  },
  {
    id: 730,
    topic: "Inheritance",
    type: "radio",
    question: "Ghi đè phương thức (Method Overriding) là gì?",
    options: [
      "Định nghĩa nhiều phương thức cùng tên nhưng khác tham số trong cùng một lớp.",
      "Định nghĩa lại một phương thức đã được kế thừa trong lớp con với cùng chữ ký phương thức.",
      "Thay đổi kiểu trả về của phương thức trong lớp con.",
      "Gọi phương thức lớp cha bằng từ khóa `super`.",
    ],
    answer: 1,
    explanation:
      "Ghi đè về cơ bản có nghĩa là khai báo lại phương thức đó trong lớp con và định nghĩa lại những gì chúng nên làm, thường là để tùy chỉnh hành vi [27], [28].",
  },
  {
    id: 731,
    topic: "Inheritance",
    type: "radio",
    question:
      "Quy tắc quan trọng nhất đối với chữ ký phương thức (method signature - tên và danh sách tham số) khi ghi đè là gì?",
    options: [
      "Có thể thay đổi tên phương thức.",
      "Phải giữ nguyên tên phương thức và danh sách tham số.",
      "Phải thay đổi thứ tự tham số.",
      "Chỉ cần thay đổi kiểu trả về.",
    ],
    answer: 1,
    explanation:
      "Quy tắc cho việc ghi đè là các đối số phải giống nhau [29], và lớp con phải định nghĩa lại phương thức với cùng chữ ký (tên và tham số) [28]. Nếu thay đổi đối số, đó là Overloading, không phải Overriding [30].",
  },
  {
    id: 732,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi ghi đè một phương thức, kiểu trả về (return type) phải tuân theo quy tắc nào?",
    options: [
      "Phải giống hệt với phương thức trong lớp cha.",
      "Phải là cùng kiểu hoặc là kiểu con (subtype) của kiểu trả về của lớp cha.",
      "Có thể là bất kỳ kiểu nào.",
      "Phải là kiểu `void`.",
    ],
    answer: 1,
    explanation:
      "Kiểu trả về phải giống nhau hoặc tương thích. An toàn khi trả về một kiểu con (subtype) nơi lớp cha được mong đợi [31].",
  },
  {
    id: 733,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi ghi đè một phương thức, access modifier của phương thức trong lớp con phải như thế nào so với lớp cha?",
    options: [
      "Phải giữ nguyên.",
      "Có thể làm hạn chế hơn (ví dụ: từ `public` sang `protected`).",
      "Không được làm hạn chế hơn (phải bằng hoặc rộng hơn).",
      "Luôn luôn phải là `public`.",
    ],
    answer: 2,
    explanation:
      "Bạn không được phép hạn chế access level của phương thức ghi đè so với phương thức trong lớp cha [30].",
  },
  {
    id: 734,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo là `static` trong lớp cha, điều gì xảy ra khi lớp con định nghĩa lại một phương thức cùng tên và chữ ký?",
    options: [
      "Phương thức đó bị ghi đè (overridden).",
      "Phương thức đó bị ẩn (hidden), không phải ghi đè, và sử dụng liên kết tĩnh (static binding).",
      "Lỗi biên dịch.",
      "Trình biên dịch Java tự động thêm từ khóa `final`.",
    ],
    answer: 1,
    explanation:
      "Bạn không thể ghi đè các phương thức `static` trong Java [32]. Thay vào đó, nó là hiện tượng che giấu phương thức (method hiding) và sử dụng liên kết tĩnh [33].",
  },
  {
    id: 735,
    topic: "Inheritance",
    type: "radio",
    question:
      "Từ khóa `super` được sử dụng để làm gì trong lớp con (ngoài việc gọi constructor)?",
    options: [
      "Tham chiếu đến đối tượng hiện tại (giống `this`).",
      "Gọi constructor của một lớp anh chị em.",
      "Gọi phiên bản lớp cha của một phương thức đã bị ghi đè.",
      "Khởi tạo các biến `private` của lớp cha.",
    ],
    answer: 2,
    explanation:
      "Để tái sử dụng (hoặc mở rộng) phương thức của lớp cha, ta dùng từ khóa `super` để gọi phiên bản lớp cha của phương thức đã bị ghi đè [34], [35].",
  },
  {
    id: 736,
    topic: "Inheritance",
    type: "radio",
    question:
      "Lệnh gọi `super()` trong constructor của lớp con dùng để làm gì?",
    options: [
      "Gọi phương thức `finalize()` của lớp cha.",
      "Gọi constructor của lớp cha.",
      "Gọi constructor khác của chính lớp con.",
      "Ngăn chặn việc kế thừa.",
    ],
    answer: 1,
    explanation:
      "Lệnh gọi `super()` trong constructor là cách duy nhất để gọi constructor của lớp cha [36]. Điều này kích hoạt chuỗi constructor (constructor chaining) [37].",
  },
  {
    id: 737,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi sử dụng `super()`, nó phải là câu lệnh đầu tiên trong constructor của lớp con ngoại trừ trường hợp nào?",
    options: [
      "Khi gọi một phương thức `static`.",
      "Khi gọi constructor lớp cha có tham số.",
      "Khi gọi một constructor quá tải (overloaded) khác của chính lớp con bằng `this()` [38].",
      "Không có trường hợp ngoại lệ nào, nó luôn phải là câu lệnh đầu tiên.",
    ],
    answer: 2,
    explanation:
      "Lệnh gọi `super()` phải là câu lệnh đầu tiên trong mỗi constructor [39]. Tuy nhiên, bạn có thể gọi một constructor quá tải khác của chính lớp con bằng `this()`, nhưng không thể có cả `super()` và `this()` trong cùng một constructor vì cả hai đều phải là câu lệnh đầu tiên [38], [40].",
  },
  {
    id: 738,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ví dụ cờ vua, tại sao lớp `Rook` (xe) cần ghi đè phương thức `isValidMove()` từ lớp `Piece` (quân cờ)?",
    options: [
      "Để ngăn `Rook` di chuyển.",
      "Để thêm chức năng không liên quan đến di chuyển.",
      "Để triển khai logic di chuyển cụ thể của quân Xe (ngang hoặc dọc).",
      "Để đảm bảo rằng nó chỉ có thể được gọi từ lớp `Piece`.",
    ],
    answer: 2,
    explanation:
      "Mỗi loại quân cờ có mẫu di chuyển khác nhau, vì vậy lớp con cần ghi đè `isValidMove()` để tùy chỉnh việc kiểm tra tính hợp lệ của nước đi (ví dụ: Xe chỉ di chuyển theo chiều dọc hoặc ngang) [41], [27].",
  },
  {
    id: 739,
    topic: "Inheritance",
    type: "radio",
    question:
      "Cơ chế liên kết nào (Binding) được sử dụng khi gọi một phương thức đã bị ghi đè thông qua tham chiếu lớp cha (polymorphic reference)?",
    options: [
      "Static Binding (Liên kết tĩnh)",
      "Runtime Binding (Liên kết thời gian chạy) hoặc Dynamic Binding (Liên kết động)",
      "Early Binding",
      "Pre-compile Binding",
    ],
    answer: 1,
    explanation:
      "Các phương thức bị ghi đè (overridden) được liên kết bằng Dynamic Binding (Liên kết động) tại thời điểm chạy, dựa trên kiểu đối tượng thực tế [33], [32].",
  },
  {
    id: 740,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Animal` là lớp cha của `Dog`, khi khai báo `Animal a = new Dog();`, tham chiếu `a` có thể truy cập được phương thức `fetch()` chỉ có trong `Dog` không?",
    options: [
      "Có, vì đối tượng thực tế là `Dog`.",
      "Không, vì trình biên dịch chỉ kiểm tra các phương thức có trong kiểu tham chiếu (`Animal`).",
      "Chỉ khi phương thức `fetch()` là `static`.",
      "Chỉ khi sử dụng từ khóa `super`.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch kiểm tra kiểu tham chiếu (`Animal`) trước khi cho phép bạn gọi một phương thức [42], [43]. Mặc dù đối tượng là `Dog`, trình biên dịch không biết `fetch()` có tồn tại trong `Animal` hay không [44].",
  },
  {
    id: 741,
    topic: "Inheritance",
    type: "radio",
    question: "Điều nào sau đây là KHÔNG thể đối với một lớp con trong Java?",
    options: [
      "Kế thừa các trường `protected` của lớp cha.",
      "Kế thừa các trường `private` của lớp cha.",
      "Ghi đè một phương thức `public` của lớp cha.",
      "Kế thừa một constructor có tham số của lớp cha.",
    ],
    answer: 1,
    explanation:
      "Lớp con không kế thừa các thành viên `private` của lớp cha [12], [10]. Constructor không được kế thừa, nhưng có thể được gọi [45], [46].",
  },
  {
    id: 742,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` và lớp `B` cùng nằm trong một package. `B` là lớp con của `A`. Lớp `A` có một trường `protected`. Điều gì đúng?",
    options: [
      "Chỉ `A` có thể truy cập trường đó.",
      "`B` không thể truy cập trường đó vì nó là `protected`.",
      "Cả `A` và `B` đều có thể truy cập trường đó.",
      "Chỉ các lớp bên ngoài package mới có thể truy cập trường đó.",
    ],
    answer: 2,
    explanation:
      "Các thành viên `protected` có thể truy cập được trong cùng một package HOẶC trong các lớp con của các package khác [47]. Vì `B` là lớp con và cùng package, nó có thể truy cập [48].",
  },
  {
    id: 743,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Animal` là lớp cơ sở, lớp `Mammal` kế thừa `Animal`, và lớp `Cat` kế thừa `Mammal`. Mối quan hệ nào là sai?",
    options: [
      "Cat IS-A Mammal",
      "Mammal IS-A Animal",
      "Cat IS-A Animal",
      "Animal IS-A Cat",
    ],
    answer: 3,
    explanation:
      "Mối quan hệ IS-A chỉ hoạt động theo một chiều từ lớp con lên lớp cha. 'Animal IS-A Cat' là sai, vì không phải tất cả động vật đều là mèo [8], [16].",
  },
  {
    id: 744,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu phương thức `Animal.eat()` được khai báo là `public`, phương thức ghi đè `Dog.eat()` có thể được khai báo là gì?",
    options: [
      "private",
      "default (package-private)",
      "protected hoặc public",
      "final",
    ],
    answer: 2,
    explanation:
      "Phương thức ghi đè không được hạn chế access level so với lớp cha [30]. Vì vậy, nếu lớp cha là `public`, lớp con phải là `public` (hoặc `protected` nếu có thể truy cập), nhưng `public` là an toàn nhất để tránh hạn chế [49], [10].",
  },
  {
    id: 745,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, điều gì cho phép bạn lấy lại quyền truy cập vào các thuộc tính và phương thức dành riêng cho lớp con?",
    options: [
      "Từ khóa `super`.",
      "Quá trình liên kết tĩnh.",
      "Sự thay đổi kiểu tham chiếu (reference type) của đối tượng.",
      "Việc đối tượng đã được Upcasting trước đó.",
    ],
    answer: 2,
    explanation:
      "Downcasting (ép kiểu thủ công) cho phép bạn lấy lại quyền truy cập vào các thuộc tính và phương thức dành riêng cho lớp con, bằng cách thay đổi kiểu tham chiếu [22], [50].",
  },
  {
    id: 746,
    topic: "Inheritance",
    type: "radio",
    question: "Nếu lớp `Animal` được định nghĩa là `final`, điều gì xảy ra?",
    options: [
      "Không thể tạo đối tượng `Animal`.",
      "Các phương thức của `Animal` không thể bị ghi đè.",
      "Lớp `Animal` không thể được kế thừa.",
      "Tất cả các trường của `Animal` phải là `static`.",
    ],
    answer: 2,
    explanation:
      "Final class (lớp cuối cùng): không thể được kế thừa [14], [51].",
  },
  {
    id: 747,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích chính của việc sử dụng các tham chiếu đa hình (polymorphic arguments) trong phương thức (ví dụ: `void giveShot(Animal a)` trong lớp `Vet`) là gì?",
    options: [
      "Giới hạn phương thức chỉ xử lý một loại đối tượng duy nhất.",
      "Đảm bảo mã không cần thay đổi khi các lớp con `Animal` mới được giới thiệu.",
      "Buộc các lớp con phải ghi đè phương thức này.",
      "Sử dụng liên kết tĩnh.",
    ],
    answer: 1,
    explanation:
      "Với đa hình, bạn có thể viết mã mà không cần thay đổi khi bạn giới thiệu các lớp con mới vào chương trình [52]. Phương thức `giveShot(Animal a)` có thể nhận BẤT KỲ kiểu `Animal` nào làm đối số [53].",
  },
  {
    id: 748,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong cú pháp `super(name);` bên trong constructor lớp con, `name` đại diện cho điều gì?",
    options: [
      "Một tham chiếu đến trường của lớp con.",
      "Một hằng số được định nghĩa trong lớp cha.",
      "Các đối số được truyền từ constructor lớp con lên constructor lớp cha.",
      "Tên của lớp cha.",
    ],
    answer: 2,
    explanation:
      "Lớp con có thể chuyển các đối số lên constructor của lớp cha bằng cách sử dụng `super(args)`, ví dụ: `Hippo` chuyển tên lên constructor `Animal` [54].",
  },
  {
    id: 749,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng ghi đè một trường instance (instance variable) trong lớp con?",
    options: [
      "Nó là hợp pháp và thường được sử dụng để thay đổi hành vi.",
      "Các biến instance không thể bị ghi đè, mặc dù chúng có thể được định nghĩa lại (nhưng không nên làm).",
      "Lỗi biên dịch xảy ra.",
      "Trường đó sẽ tự động trở thành `static`.",
    ],
    answer: 1,
    explanation: "Các biến instance không thể bị ghi đè [55], [10].",
  },
  {
    id: 750,
    topic: "Inheritance",
    type: "code",
    question: "Đoạn mã sau in ra gì? (Overriding và Dynamic Binding)",
    code: 'class A { public void m1() { System.out.print("A\'s m1"); } } class B extends A { public void m1() { System.out.print("B\'s m1"); } } public class Test { public static void main(String[] args) { A a = new B(); a.m1(); } }',
    options: ["A's m1", "B's m1", "Lỗi biên dịch", "null"],
    answer: 1,
    explanation:
      "Vì `A a = new B();` là upcasting, kiểu tham chiếu là `A` nhưng đối tượng thực tế là `B`. Khi gọi phương thức đã bị ghi đè (`m1()`), Liên kết động (Dynamic Binding) sẽ đảm bảo phiên bản cụ thể nhất của đối tượng (`B`'s `m1()`) được gọi. (The lowest one wins) [56], [8], [32].",
  },
  {
    id: 751,
    topic: "Inheritance",
    type: "radio",
    question:
      "Phương thức nào là lớp siêu lớp tối thượng (ultimate superclass) của mọi lớp trong Java (trừ kiểu nguyên thủy)?",
    options: [
      "Interface",
      "java.lang.Class",
      "java.lang.Object",
      "Abstract Class",
    ],
    answer: 2,
    explanation:
      "Mọi lớp trong Java đều là lớp con trực tiếp hoặc gián tiếp của lớp `Object` (java.lang.Object). `Object` là siêu lớp tối thượng của mọi thứ [57], [58], [59].",
  },
  {
    id: 752,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi bạn gọi một phương thức trên một tham chiếu, trình biên dịch kiểm tra tính hợp lệ của cuộc gọi dựa trên yếu tố nào?",
    options: [
      "Kiểu đối tượng thực tế trên Heap.",
      "Kiểu dữ liệu nguyên thủy được sử dụng.",
      "Kiểu tham chiếu (reference type) của biến.",
      "Kiểu trả về của phương thức.",
    ],
    answer: 2,
    explanation:
      "Trình biên dịch kiểm tra kiểu tham chiếu để quyết định xem bạn có thể gọi một phương thức cụ thể trên tham chiếu đó hay không [42], [43].",
  },
  {
    id: 753,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong mô hình kế thừa `Piece` -> `Rook`, việc ghi đè `isValidMove()` trong `Rook` để kiểm tra nước đi cụ thể của quân Xe là ví dụ về nguyên tắc thiết kế nào?",
    options: [
      "Đóng gói (Encapsulation)",
      "Mở để mở rộng, Đóng để sửa đổi (Open/Closed Principle)",
      "Đa hình (Polymorphism)",
      "Đơn kế thừa (Single Inheritance)",
    ],
    answer: 2,
    explanation:
      "Đây là một ví dụ rõ ràng về Đa hình (Polymorphism) thông qua Ghi đè phương thức (Overriding), cho phép các đối tượng `Rook` hành xử khác với đối tượng `Piece` chung khi phương thức `isValidMove()` được gọi [11], [41].",
  },
  {
    id: 754,
    topic: "Inheritance",
    type: "radio",
    question:
      "Lệnh gọi `super()` trong constructor của lớp con đảm bảo điều gì xảy ra trước khi lớp con được khởi tạo?",
    options: [
      "Tất cả các biến instance của lớp con được gán giá trị mặc định.",
      "Các phần của đối tượng thuộc lớp cha được xây dựng và khởi tạo hoàn toàn.",
      "Constructor của lớp con khác được gọi.",
      "Trình biên dịch kiểm tra lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Phần lớp cha của một đối tượng phải được hình thành đầy đủ (hoàn toàn được xây dựng) trước khi các phần lớp con có thể được xây dựng [60]. Chuỗi constructor đảm bảo rằng constructor của lớp cha phải chạy và kết thúc trước [61], [62].",
  },
  {
    id: 755,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ngữ cảnh kế thừa và Generics, điều gì đúng về mối quan hệ giữa `Pair<Animal>` và `Pair<Cat>`?",
    options: [
      "Pair<Cat> kế thừa Pair<Animal>.",
      "Pair<Animal> kế thừa Pair<Cat>.",
      "Không có mối quan hệ kế thừa giữa chúng.",
      "Chúng có thể được ép kiểu lẫn nhau tự động.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau, ngay cả khi các tham số kiểu có quan hệ kế thừa (ví dụ: `Pair<Animal>` và `Pair<Cat>`) [63], [64].",
  },
  {
    id: 756,
    topic: "Inheritance",
    type: "radio",
    question:
      "Từ khóa `super` được coi là một tham chiếu đến phần nào của đối tượng?",
    options: [
      "Đối tượng `Object` tối thượng.",
      "Phần lớp cha (superclass portion) của đối tượng.",
      "Đối tượng hiện tại (giống `this`).",
      "Lớp `main`.",
    ],
    answer: 1,
    explanation:
      "Từ khóa `super` thực sự là một tham chiếu đến phần lớp cha của một đối tượng [65].",
  },
  {
    id: 757,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong trường hợp nào, `super()` không được tự động chèn bởi trình biên dịch vào constructor lớp con?",
    options: [
      "Lớp cha không có constructor.",
      "Lớp con không có constructor.",
      "Lớp con gọi constructor khác của chính nó bằng `this()` [38].",
      "Lớp cha được khai báo là `abstract`.",
    ],
    answer: 2,
    explanation:
      "Nếu constructor gọi constructor quá tải khác bằng `this()`, trình biên dịch sẽ không tự động chèn `super()`, vì `this()` phải là câu lệnh đầu tiên [38].",
  },
  {
    id: 758,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mặc dù Java không cho phép đa kế thừa (multiple inheritance) giữa các lớp, Interface được coi là giải pháp thay thế vì lý do gì?",
    options: [
      "Interface có thể định nghĩa các trường instance.",
      "Một lớp có thể triển khai nhiều interface.",
      "Interface có thể chứa implementation code.",
      "Interface không thể có các phương thức `abstract`.",
    ],
    answer: 1,
    explanation:
      "Java không cho phép đa kế thừa giữa các class do vấn đề 'Deadly Diamond of Death'. Java sử dụng Interface như một giải pháp thay thế vì một class có thể triển khai nhiều interface [6], [7], [66].",
  },
  {
    id: 759,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là mục đích của `instanceof` khi được sử dụng với Upcasting và Downcasting?",
    options: [
      "Để kiểm tra xem hai tham chiếu có trỏ đến cùng một đối tượng không.",
      "Để buộc Upcasting xảy ra.",
      "Để ngăn chặn `ClassCastException` tiềm ẩn khi Downcasting.",
      "Để chỉ định rằng một phương thức đã bị ghi đè.",
    ],
    answer: 2,
    explanation:
      "Toán tử `instanceof` được sử dụng để kiểm tra kiểu đối tượng thực tế trước khi Downcasting, đảm bảo rằng việc ép kiểu là an toàn và tránh `ClassCastException` [20], [25].",
  },
  {
    id: 760,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong mô hình kế thừa, `superclass` được coi là trừu tượng (abstract) hơn hay cụ thể (specific) hơn so với `subclass`?",
    options: [
      "Cụ thể hơn.",
      "Trừu tượng hơn.",
      "Cả hai đều giống nhau.",
      "Điều này phụ thuộc vào việc lớp cha có phải là `abstract` không.",
    ],
    answer: 1,
    explanation:
      "Lớp cha/siêu lớp được coi là trừu tượng hơn (more abstract), trong khi lớp con/lớp dẫn xuất được coi là cụ thể hơn (more specific) [67], [68], [69], [70].",
  },
  {
    id: 761,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` không phải là lớp trừu tượng (concrete class) và `B extends A`. Khi gọi `new B()`, constructor nào được gọi trước?",
    options: [
      "Constructor của lớp `B`.",
      "Constructor của lớp `A`.",
      "Constructor của lớp `Object`.",
      "Không thể xác định.",
    ],
    answer: 2,
    explanation:
      "Chuỗi constructor sẽ chạy từ trên xuống dưới (Object -> A -> B) [46], [61]. Constructor của lớp `Object` là lớp cao nhất trong hệ thống phân cấp sẽ chạy và kết thúc trước tiên [71], [62].",
  },
  {
    id: 762,
    topic: "Inheritance",
    type: "radio",
    question:
      "Việc sử dụng tham chiếu lớp cha (ví dụ: `Person p = new Student();`) khi tạo đối tượng được gọi là gì?",
    options: ["Downcasting", "Multicasting", "Upcasting", "Overloading"],
    answer: 2,
    explanation:
      "Đây là Upcasting, trong đó đối tượng lớp con được gán cho một tham chiếu lớp cha [72], [18].",
  },
  {
    id: 763,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Animal` có phương thức `public void sound()` và lớp `Dog` ghi đè phương thức này. Khi `Animal a = new Dog();` và gọi `a.sound()`, phiên bản phương thức nào sẽ chạy?",
    options: [
      "Phương thức `sound()` của lớp `Animal`.",
      "Phương thức `sound()` của lớp `Dog`.",
      "Lỗi thời gian chạy.",
      "Phương thức `sound()` của lớp `Object`.",
    ],
    answer: 1,
    explanation:
      "Do Dynamic Binding, phương thức của đối tượng thực tế (`Dog`) sẽ được gọi, ngay cả khi tham chiếu là kiểu lớp cha (`Animal`) [21], [44], [8].",
  },
  {
    id: 764,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, mục đích chính của việc tránh đa kế thừa (multiple class inheritance) là gì?",
    options: [
      "Để giảm độ phức tạp của mã.",
      "Để giải quyết vấn đề mơ hồ (ambiguity) nếu các lớp cơ sở có phương thức tương tự (Deadly Diamond of Death).",
      "Để giới hạn số lượng lớp trong một dự án.",
      "Vì chỉ có một `main` method.",
    ],
    answer: 1,
    explanation:
      "Đa kế thừa có thể gây ra sự mơ hồ nếu các lớp cơ sở có các phương thức tương tự (Deadly Diamond of Death). Java giải quyết điều này bằng cách cấm đa kế thừa giữa các lớp [6], [73], [74].",
  },
  {
    id: 765,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, điều kiện nào sau đây phải được đáp ứng để tránh `ClassCastException`?",
    options: [
      "Lớp cha phải là `abstract`.",
      "Đối tượng phải thực sự là một thể hiện của lớp con đích (target subclass).",
      "Lớp con phải là `final`.",
      "Lớp cha phải là `Object`.",
    ],
    answer: 1,
    explanation:
      "Nếu bạn đang downcasting, đối tượng phải thực sự là một thể hiện của lớp con mà bạn đang ép kiểu, nếu không sẽ xảy ra `ClassCastException` [26].",
  },
  {
    id: 766,
    topic: "Inheritance",
    type: "radio",
    question: "Trong chuỗi constructor, thứ tự chạy của code là gì?",
    options: [
      "Constructor lớp con hoàn thành trước, sau đó là lớp cha.",
      "Constructor lớp cha hoàn thành trước, sau đó là lớp con.",
      "Tất cả code lớp cha chạy trước, sau đó là tất cả code lớp con.",
      "Thứ tự không được xác định.",
    ],
    answer: 1,
    explanation:
      "Lệnh gọi `super()` đẩy constructor lớp cha lên Stack [75]. Constructor lớp cha phải hoàn thành trước khi constructor lớp con có thể tiếp tục và hoàn thành [60], [62].",
  },
  {
    id: 767,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Piece` có trường `Position position` được khai báo là `private`, làm thế nào lớp con `Rook` có thể sử dụng vị trí của chính nó để tính toán nước đi hợp lệ?",
    options: [
      "Bằng cách ghi đè trường `position` trong `Rook`.",
      "Bằng cách truy cập trực tiếp `position` (nếu chúng cùng package).",
      "Bằng cách sử dụng các phương thức `public getter` được định nghĩa trong `Piece`.",
      "Điều này là không thể.",
    ],
    answer: 2,
    explanation:
      "Các biến `private` không thể truy cập trực tiếp trong lớp con [10]. Cần có các phương thức getter/setter công khai trong lớp cha để thao tác hoặc đọc giá trị [76].",
  },
  {
    id: 768,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu một phương thức trong lớp cha ném ra một Checked Exception, phương thức ghi đè trong lớp con có thể làm gì?",
    options: [
      "Ném ra một Checked Exception khác không liên quan.",
      "Ném ra một ngoại lệ rộng hơn (superclass exception).",
      "Ném ra cùng một Checked Exception hoặc một ngoại lệ hẹp hơn (subclass exception), hoặc không ném ra ngoại lệ nào.",
      "Phải ném ra ngoại lệ Unchecked.",
    ],
    answer: 2,
    explanation:
      "Khi ghi đè, phương thức lớp con không thể ném ra một ngoại lệ checked rộng hơn (superclass exception) so với lớp cha [77].",
  },
  {
    id: 769,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là lợi ích của việc sử dụng `Pair<? extends Animal>` (wildcard) trong Generics liên quan đến kế thừa?",
    options: [
      "Buộc kiểu tham số phải là chính xác `Animal`.",
      "Cho phép đối tượng chấp nhận `Pair<Cat>` hoặc bất kỳ lớp con nào của `Animal`.",
      "Ngăn chặn hoàn toàn sự kế thừa.",
      "Cho phép đa kế thừa giữa các lớp.",
    ],
    answer: 1,
    explanation:
      "Wildcard mở rộng (`? extends Animal`) cho phép một kiểu `Pair` hoạt động với một kiểu con (subtype) của `Animal`, chẳng hạn như `Pair<Cat>` [63].",
  },
  {
    id: 770,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu bạn muốn lớp `Vehicle` (xe cộ) không thể được khởi tạo (instantiated) nhưng vẫn có thể được kế thừa, bạn nên khai báo nó như thế nào?",
    options: [
      "public final class Vehicle",
      "public interface Vehicle",
      "public abstract class Vehicle",
      "public static class Vehicle",
    ],
    answer: 2,
    explanation:
      "Một lớp trừu tượng (abstract class) không thể được khởi tạo thành đối tượng [78], [79], [80], nhưng nó được thiết kế để được kế thừa [81]. Interface cũng không thể khởi tạo [82], nhưng nó không phải là class [83].",
  },
  {
    id: 771,
    topic: "Inheritance",
    type: "radio",
    question: "Khi Downcasting, bạn sử dụng `instanceof` để làm gì?",
    options: [
      "Để thực hiện việc ép kiểu.",
      "Để kiểm tra tính hợp lệ của cú pháp.",
      "Để xác minh rằng đối tượng lớp cha ban đầu là thể hiện của lớp con mà bạn muốn ép kiểu.",
      "Để gọi constructor của lớp con.",
    ],
    answer: 2,
    explanation:
      "Sử dụng `instanceof` để kiểm tra nếu đối tượng đang được tham chiếu là một thể hiện của lớp con (ví dụ: `if(a instanceof Cat)`) trước khi ép kiểu [20].",
  },
  {
    id: 772,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là KHÔNG đúng về Downcasting?",
    options: [
      "Nó là quá trình ép kiểu một đối tượng lớp cha về kiểu lớp con.",
      "Nó luôn luôn an toàn và không bao giờ ném ra ngoại lệ.",
      "Nó cho phép truy cập các thành viên dành riêng cho lớp con.",
      "Nó phải được thực hiện một cách thủ công.",
    ],
    answer: 1,
    explanation:
      "Downcasting không phải lúc nào cũng an toàn và có thể ném ra `ClassCastException` tại thời điểm chạy nếu đối tượng thực tế không phải là instance của lớp con đích [26], [50], [23].",
  },
  {
    id: 773,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong trường hợp nào, việc ghi đè phương thức được liên kết tại thời điểm biên dịch (Static Binding)?",
    options: [
      "Khi phương thức lớp cha là `abstract`.",
      "Khi phương thức được gọi từ lớp con bằng `super`.",
      "Khi phương thức bị ghi đè không sử dụng tham chiếu đa hình.",
      "Không có trường hợp nào, overriding luôn là Dynamic Binding.",
    ],
    answer: 3,
    explanation:
      "Ngay cả khi gọi phương thức bị ghi đè trên tham chiếu lớp con (ví dụ: `Dog d = new Dog(); d.sound();`), nó vẫn là Dynamic Binding. Tất cả các phương thức bị ghi đè (non-static) đều là Dynamic Binding [33], [32], [84].",
  },
  {
    id: 774,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Piece` có phương thức `public final boolean isFixed()`, và lớp `Rook` kế thừa `Piece`. Điều gì xảy ra nếu `Rook` cố gắng định nghĩa lại `isFixed()`?",
    options: [
      "Lỗi biên dịch.",
      "Nó được phép vì `Rook` là lớp con.",
      "Nó sẽ ẩn (hide) phương thức của lớp cha.",
      "Nó sẽ gây ra `ClassCastException`.",
    ],
    answer: 0,
    explanation:
      "Phương thức `final` không thể bị ghi đè, do đó sẽ xảy ra lỗi biên dịch [13], [14], [85].",
  },
  {
    id: 775,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, khi tạo một mảng đa hình như `Animal[] animals = new Animal[86];`, mảng này có thể chứa những đối tượng nào?",
    options: [
      "Chỉ các đối tượng kiểu `Animal`.",
      "Các đối tượng `Animal` và các đối tượng của bất kỳ lớp con nào của `Animal`.",
      "Các đối tượng `Animal` và bất kỳ đối tượng nào khác (ví dụ: `String`).",
      "Chỉ các đối tượng có constructor mặc định.",
    ],
    answer: 1,
    explanation:
      "Bạn có thể khai báo một mảng kiểu siêu lớp (`Animal`) và gán các đối tượng lớp con (`Dog`, `Cat`, `Wolf`, `Hippo`, `Lion`) cho các phần tử của nó. Điều này là cốt lõi của đa hình [87].",
  },
  {
    id: 776,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ví dụ cờ vua, lớp `Piece` có thể bao gồm những thuộc tính nào chung cho tất cả các quân cờ?",
    options: [
      "Tên của quân cờ (ví dụ: 'Rook').",
      "Vị trí (position) và Màu sắc (color).",
      "Logic di chuyển riêng (ví dụ: di chuyển chéo).",
      "Chỉ các trường `static`.",
    ],
    answer: 1,
    explanation:
      "Lớp `Piece` (lớp cơ sở) chứa tất cả các thuộc tính và phương thức chung cho tất cả các quân cờ, ví dụ: màu sắc, vị trí [88].",
  },
  {
    id: 777,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi nào việc ghi đè một phương thức (Method Overriding) được cho là không hợp lệ (gây lỗi biên dịch)?",
    options: [
      "Khi nó sử dụng từ khóa `super`.",
      "Khi nó làm cho access level rộng hơn (ví dụ: `protected` thành `public`).",
      "Khi nó thay đổi tên phương thức.",
      "Khi nó sử dụng kiểu trả về không tương thích.",
    ],
    answer: 3,
    explanation:
      "Nếu chỉ thay đổi kiểu trả về (không tương thích), trình biên dịch sẽ cho rằng bạn đang cố gắng ghi đè phương thức và nó sẽ không hợp lệ trừ khi kiểu trả về là một kiểu con của kiểu lớp cha [89], [31].",
  },
  {
    id: 778,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Person` có một constructor là `Person(String name)`. Lớp con `Employee` muốn gọi constructor này, nó phải làm gì trong constructor của mình?",
    options: [
      "Gọi `this(name)`.",
      "Gọi `name.super()`.",
      "Gọi `super(name);`.",
      "Không cần làm gì, nó được gọi tự động.",
    ],
    answer: 2,
    explanation:
      "Để gọi constructor lớp cha có tham số, lớp con phải gọi rõ ràng `super(tham số)` và phải là câu lệnh đầu tiên [90], [54].",
  },
  {
    id: 779,
    topic: "Inheritance",
    type: "radio",
    question:
      "Giả sử lớp `Piece` có constructor mặc định. Lớp `Queen` kế thừa `Piece` và có constructor `Queen()`. Lệnh nào được chèn tự động vào `Queen()`?",
    options: ["Không có lệnh nào.", "super();", "this();", "super(this);"],
    answer: 1,
    explanation:
      "Nếu constructor của lớp con không gọi rõ ràng constructor của lớp cha, trình biên dịch Java tự động chèn một lệnh gọi đến constructor mặc định của lớp cha: `super()` [15], [91], [92].",
  },
  {
    id: 780,
    topic: "Inheritance",
    type: "radio",
    question: "Upcasting được thực hiện khi nào?",
    options: [
      "Chỉ khi lớp cha là `abstract`.",
      "Khi cần lưu trữ đối tượng lớp con trong một biến tham chiếu kiểu lớp cha.",
      "Chỉ khi Downcasting thất bại.",
      "Khi cố gắng gọi một phương thức private.",
    ],
    answer: 1,
    explanation:
      "Upcasting được sử dụng khi bạn cần lưu trữ đối tượng lớp con trong một tham chiếu kiểu lớp cha (đa hình) [93], [87].",
  },
  {
    id: 781,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ví dụ `Item` -> `Crossbow` trong hệ thống túi đồ, tại sao `Bag` có thể chứa `Crossbow` mà không cần ép kiểu?",
    options: [
      "Vì `Crossbow` không phải là một đối tượng.",
      "Vì `Crossbow` tự động được Upcasting thành `Item`.",
      "Vì `Bag` được định nghĩa để chấp nhận `Object`.",
      "Vì `Crossbow` là `final`.",
    ],
    answer: 1,
    explanation:
      "Do `Crossbow` kế thừa `Item`, nó tự động được Upcasting khi được thêm vào `Bag` (thứ chứa mảng `Item[] list`) [94], [95]. Điều này cho thấy tính đa hình hoạt động [96], [53].",
  },
  {
    id: 782,
    topic: "Inheritance",
    type: "radio",
    question: "Downcasting là bắt buộc khi nào?",
    options: [
      "Khi gọi một phương thức đã ghi đè.",
      "Khi cần truy cập các phương thức dành riêng cho lớp con trên một tham chiếu lớp cha.",
      "Khi chuyển đối số cho một phương thức.",
      "Khi sử dụng toán tử `instanceof`.",
    ],
    answer: 1,
    explanation:
      "Downcasting là cần thiết khi bạn có một tham chiếu lớp cha (ví dụ: lấy đối tượng từ `ArrayList<Object>`) và muốn gọi một phương thức chỉ có trong lớp con [22], [50].",
  },
  {
    id: 783,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` là lớp cha và `B` là lớp con. Khi `A obj = new B();`, nếu phương thức `m2()` không bị ghi đè, cuộc gọi `obj.m2()` sẽ sử dụng phiên bản nào?",
    options: [
      "Phiên bản `m2()` của lớp `B`.",
      "Phiên bản `m2()` của lớp `A`.",
      "Lỗi thời gian chạy.",
      "Lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Nếu phương thức không bị ghi đè, lớp con kế thừa phiên bản của lớp cha. Do đó, nó vẫn là phiên bản trong lớp `A` [5], [56].",
  },
  {
    id: 784,
    topic: "Inheritance",
    type: "radio",
    question: "Trong trường hợp nào, `ClassCastException` thường xảy ra nhất?",
    options: [
      "Khi Downcasting được thực hiện tự động.",
      "Khi Upcasting được thực hiện thủ công.",
      "Khi Downcasting một đối tượng thành một lớp không phải là kiểu thực tế của nó (ví dụ: Ép kiểu `Animal` sang `Cat` khi đối tượng là `Dog`).",
      "Khi ghi đè một phương thức `static`.",
    ],
    answer: 2,
    explanation:
      "Lỗi xảy ra khi đối tượng trên heap không thực sự là kiểu mà chúng ta cố gắng ép kiểu thành [26], [23].",
  },
  {
    id: 785,
    topic: "Inheritance",
    type: "radio",
    question:
      "Sự khác biệt chính giữa Ghi đè phương thức (Overriding) và Nạp chồng phương thức (Overloading) là gì?",
    options: [
      "Overriding xảy ra trong cùng một lớp, Overloading xảy ra giữa các lớp.",
      "Overriding cần thay đổi tham số, Overloading thì không.",
      "Overriding giữ nguyên chữ ký nhưng thay đổi implementation, Overloading thay đổi tham số.",
      "Overloading sử dụng Dynamic Binding, Overriding sử dụng Static Binding.",
    ],
    answer: 2,
    explanation:
      "Overriding là định nghĩa lại phương thức kế thừa (cùng chữ ký) [27], [97]. Overloading là có nhiều phương thức cùng tên nhưng khác danh sách đối số [98], [99].",
  },
  {
    id: 786,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ví dụ cờ vua, logic kiểm tra biên (boundary check) trong phương thức `Piece.isValidMove()` là một ví dụ về mã nào?",
    options: [
      "Mã cụ thể, không thể tái sử dụng.",
      "Mã chung (generic code) có thể tái sử dụng bởi tất cả các lớp con quân cờ.",
      "Mã phải được khai báo `final`.",
      "Mã chỉ hoạt động khi không có ghi đè.",
    ],
    answer: 1,
    explanation:
      "Logic kiểm tra biên là chung cho mọi quân cờ (tất cả đều phải nằm trên bảng 8x8), do đó nó được đặt trong lớp `Piece` để các lớp con có thể tái sử dụng, ví dụ bằng `super.isValidMove()` [100], [34].",
  },
  {
    id: 787,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Vehicle` được kế thừa bởi `Car` và `Truck`. Lợi ích nào của kế thừa được thể hiện rõ nhất khi thêm một trường mới như `bankCode`?",
    options: [
      "Chỉ cần sửa đổi lớp `Vehicle` (lớp cha) mà không cần chạm vào `Car` và `Truck`.",
      "Buộc `Car` và `Truck` phải Downcasting.",
      "Ngăn chặn việc sử dụng từ khóa `super`.",
      "Kích hoạt `ClassCastException`.",
    ],
    answer: 0,
    explanation:
      "Việc đặt các thuộc tính chung vào lớp cha giúp bảo trì dễ dàng hơn. Nếu cần thêm `bankCode`, chỉ cần thêm vào `BankAccount` (hoặc `Vehicle`) và tất cả các lớp con sẽ tự động kế thừa [101], [102].",
  },
  {
    id: 788,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, điều gì đảm bảo rằng mọi đối tượng, ngoại trừ các kiểu nguyên thủy, đều là một `Object`?",
    options: [
      "Cơ chế Boxing.",
      "Quy tắc sử dụng `instanceof`.",
      "Tất cả các lớp đều kế thừa từ `java.lang.Object`.",
      "Tất cả các lớp đều triển khai interface `Serializable`.",
    ],
    answer: 2,
    explanation:
      "Trong Java, mọi thứ đều là một đối tượng ngoại trừ các kiểu nguyên thủy [17], và mọi class đều kế thừa từ `Object` [59].",
  },
  {
    id: 789,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu một mảng `Item[] list` được khai báo, và `RareItem` kế thừa `Item`, bạn có thể gán `RareItem r` cho một phần tử của `list` bằng cách nào?",
    options: [
      "list[i] = (Item) r; (Upcasting thủ công)",
      "list[i] = r; (Upcasting tự động)",
      "list[i] = (RareItem) r; (Downcasting)",
      "list[i] = new Item();",
    ],
    answer: 1,
    explanation:
      "Upcasting là tự động, vì `RareItem` là một `Item` (IS-A) [18]. Việc ép kiểu thủ công `(Item) r` cũng tương đương [18].",
  },
  {
    id: 790,
    topic: "Inheritance",
    type: "code",
    question: "Đoạn mã sau in ra gì? (Sử dụng `super`)",
    code: 'class Parent { public void display() { System.out.print("Parent"); } } class Child extends Parent { public void display() { super.display(); System.out.print("Child"); } } public class Test { public static void main(String[] args) { Child c = new Child(); c.display(); } }',
    options: ["Parent", "Child", "ParentChild", "ChildParent"],
    answer: 2,
    explanation:
      "Phương thức `display()` của `Child` gọi `super.display()` trước, in ra 'Parent', sau đó in ra 'Child' [34], [35]. Kết quả là 'ParentChild'.",
  },
  {
    id: 791,
    topic: "Inheritance",
    type: "radio",
    question:
      "Lệnh gọi constructor lớp cha `super()` phải đặt ở vị trí nào trong constructor lớp con?",
    options: [
      "Cuối constructor.",
      "Trước khi khởi tạo bất kỳ biến instance nào.",
      "Luôn luôn là câu lệnh đầu tiên.",
      "Nó có thể nằm ở bất kỳ đâu.",
    ],
    answer: 2,
    explanation:
      "Lệnh gọi đến `super()` phải là câu lệnh đầu tiên trong mỗi constructor [39]. Đây là quy tắc cho Chuỗi Constructor [60].",
  },
  {
    id: 792,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Person` có một trường `protected String name`, lớp con `Student` (trong package khác) có thể truy cập trường này không?",
    options: [
      "Không, vì chúng khác package.",
      "Có, vì `protected` cho phép truy cập từ lớp con ở mọi package.",
      "Chỉ khi trường được khai báo là `public`.",
      "Chỉ nếu `Student` không ghi đè bất kỳ phương thức nào.",
    ],
    answer: 1,
    explanation:
      "Các thành viên `protected` có thể truy cập được trong cùng một package HOẶC trong các lớp con của các package khác [47], [48].",
  },
  {
    id: 793,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi áp dụng `instanceof`, biểu thức `a instanceof Cat` sẽ trả về `true` nếu:",
    options: [
      "`a` là tham chiếu kiểu `Cat`.",
      "Đối tượng mà `a` trỏ đến trên heap là một instance của `Cat` hoặc lớp con của `Cat`.",
      "`a` đã được Upcasting.",
      "`Cat` không phải là `final`.",
    ],
    answer: 1,
    explanation:
      "Toán tử `instanceof` kiểm tra xem đối tượng thực tế (instance) có phải là một instance của lớp được chỉ định hay không [20], [25].",
  },
  {
    id: 794,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc sử dụng một lớp cơ sở như `Animal` với các phương thức như `eat()`, `sleep()` là gì?",
    options: [
      "Buộc tất cả các lớp con phải là `abstract`.",
      "Xác định một giao thức chung (common protocol) cho tất cả các lớp con `Animal`.",
      "Sử dụng đa kế thừa.",
      "Ngăn chặn tất cả các phương thức bị ghi đè.",
    ],
    answer: 1,
    explanation:
      "Kế thừa cho phép bạn xác định một giao thức chung (common protocol) cho một nhóm các lớp con, đảm bảo tất cả các subtype đều có các phương thức đó [103], [104].",
  },
  {
    id: 795,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu một lớp cha có `public void methodA()` và lớp con có `public void methodA(int x)`. Đây là hiện tượng gì?",
    options: [
      "Ghi đè phương thức (Overriding)",
      "Che giấu phương thức (Method Hiding)",
      "Nạp chồng phương thức (Overloading)",
      "Lỗi biên dịch",
    ],
    answer: 2,
    explanation:
      "Đây là Nạp chồng phương thức (Overloading) vì danh sách tham số đã thay đổi [98], [99].",
  },
  {
    id: 796,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là quan trọng nhất khi thiết kế với kế thừa?",
    options: [
      "Giữ cho tất cả các lớp là `final`.",
      "Đảm bảo mối quan hệ IS-A có ý nghĩa theo một chiều.",
      "Đảm bảo tất cả các lớp con đều có thể Downcasting về lớp cha.",
      "Sử dụng các lớp `private`.",
    ],
    answer: 1,
    explanation:
      "Luôn luôn tự hỏi liệu lớp con IS-A một kiểu cụ thể hơn của lớp cha [102]. Mối quan hệ IS-A chỉ hoạt động theo một chiều [8].",
  },
  {
    id: 797,
    topic: "Inheritance",
    type: "radio",
    question:
      "Việc ghi đè phương thức không hợp lệ (lỗi biên dịch) nếu phương thức lớp con cố gắng ném ra một Checked Exception nào so với lớp cha?",
    options: [
      "Checked Exception hẹp hơn.",
      "Checked Exception rộng hơn.",
      "Unchecked Exception.",
      "Không ném ra Exception nào.",
    ],
    answer: 1,
    explanation:
      "Khi ghi đè, phương thức lớp con không thể ném ra một Checked Exception rộng hơn (superclass exception) so với phương thức lớp cha [77].",
  },
  {
    id: 798,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, nếu không sử dụng `instanceof` trước, điều gì có thể xảy ra?",
    options: [
      "Upcasting tự động.",
      "Lỗi biên dịch.",
      "`NullPointerException`.",
      "`ClassCastException` nếu đối tượng không khớp kiểu.",
    ],
    answer: 3,
    explanation:
      "Thiếu kiểm tra `instanceof` có thể dẫn đến `ClassCastException` nếu đối tượng thực tế không phải là kiểu được yêu cầu [20], [26].",
  },
  {
    id: 799,
    topic: "Inheritance",
    type: "radio",
    question:
      "Giả sử lớp `A` có constructor mặc định. Lớp `B extends A` có `public B(int x) { this.x = x; }`. Điều gì xảy ra khi `new B(5)`?",
    options: [
      "Lỗi biên dịch vì thiếu `super()`.",
      "Constructor `A()` được gọi tự động sau `this.x = x;`.",
      "Constructor `A()` được gọi tự động trước `this.x = x;`.",
      "Chỉ constructor `B(int x)` được gọi.",
    ],
    answer: 2,
    explanation:
      "Trình biên dịch tự động chèn `super()` là câu lệnh đầu tiên, ngay cả khi không được khai báo rõ ràng, miễn là lớp cha có constructor mặc định [15], [91], [39], [92].",
  },
  {
    id: 800,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về Upcasting?",
    options: [
      "Nó giới hạn quyền truy cập vào các phương thức của lớp con.",
      "Nó thay đổi kiểu đối tượng thực tế trên heap.",
      "Nó luôn yêu cầu ép kiểu thủ công.",
      "Nó chỉ hoạt động nếu lớp con là `final`.",
    ],
    answer: 0,
    explanation:
      "Khi Upcasting, bạn chỉ có thể truy cập những phương thức và thuộc tính được định nghĩa trong kiểu tham chiếu (superclass), hạn chế quyền truy cập vào các thành viên dành riêng cho lớp con [22], [42].",
  },
  {
    id: 801,
    topic: "Inheritance",
    type: "radio",
    question: "Trong trường hợp nào, việc sử dụng `super` là bắt buộc?",
    options: [
      "Khi gọi một phương thức `static` của lớp cha.",
      "Khi lớp con có constructor nhưng lớp cha không có constructor mặc định.",
      "Khi ghi đè một trường instance.",
      "Khi phương thức lớp cha là `public`.",
    ],
    answer: 1,
    explanation:
      "Nếu lớp cha chỉ có constructor có tham số, lớp con BẮT BUỘC phải gọi một trong số chúng bằng `super(args)` để tránh lỗi biên dịch [15], [91].",
  },
  {
    id: 802,
    topic: "Inheritance",
    type: "radio",
    question:
      "Phương thức nào trong `Object` class bạn được khuyến khích ghi đè trong các lớp tùy chỉnh?",
    options: [
      "getClass()",
      "hashCode(), equals(), và toString()",
      "notify()",
      "wait()",
    ],
    answer: 1,
    explanation:
      "Bạn được khuyến khích mạnh mẽ ghi đè `hashCode()`, `equals()`, và `toString()` trong các lớp của riêng bạn [105], [106].",
  },
  {
    id: 803,
    topic: "Inheritance",
    type: "radio",
    question: "Sự khác biệt chính giữa `extends` và `implements` là gì?",
    options: [
      "`extends` dùng cho interfaces, `implements` dùng cho classes.",
      "`extends` cho phép đơn kế thừa, `implements` cho phép đa kế thừa interface.",
      "`extends` chỉ dùng cho lớp `abstract`, `implements` dùng cho lớp `concrete`.",
      "Cả hai đều cho phép đa kế thừa.",
    ],
    answer: 1,
    explanation:
      "Một lớp chỉ có thể `extends` một lớp khác (đơn kế thừa) [6], nhưng có thể `implements` nhiều interface (đa kế thừa hành vi) [7], [66].",
  },
  {
    id: 804,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có constructor `A(int x)`. Lớp `B extends A` phải làm gì trong constructor mặc định `B()` của nó?",
    options: [
      "Không cần làm gì, Java sẽ xử lý.",
      "Phải gọi `super(một số nguyên)`.",
      "Phải gọi `this(một số nguyên)`.",
      "Phải khai báo `A` là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Vì `A` không có constructor mặc định, `B` phải gọi rõ ràng một constructor của `A` bằng cách sử dụng `super(args)` [15], [91].",
  },
  {
    id: 805,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `Dog d = (Dog) a;` được thực hiện, điều gì xảy ra nếu `a` là tham chiếu `Animal` nhưng đối tượng thực tế là `Cat`?",
    options: [
      "Lỗi biên dịch.",
      "Đối tượng `Cat` được ép kiểu thành `Dog`.",
      "`ClassCastException`.",
      "Upcasting xảy ra.",
    ],
    answer: 2,
    explanation:
      "Vì `Cat` và `Dog` là các lớp anh chị em (sibling classes) và `Cat` không phải là `Dog`, Downcasting thất bại tại runtime và ném ra `ClassCastException` [20], [26].",
  },
  {
    id: 806,
    topic: "Inheritance",
    type: "radio",
    question:
      "Việc sử dụng `super.method()` trong phương thức ghi đè giúp lớp con đạt được điều gì?",
    options: [
      "Thay thế hoàn toàn hành vi của lớp cha.",
      "Mở rộng chức năng của lớp cha (chạy code lớp cha và thêm code lớp con).",
      "Ngăn chặn lớp cha được khởi tạo.",
      "Buộc liên kết tĩnh.",
    ],
    answer: 1,
    explanation:
      "Từ khóa `super` cho phép lớp con mở rộng chức năng của lớp cha, bằng cách chạy code lớp cha trước rồi thêm code cụ thể của lớp con [35], [107].",
  },
  {
    id: 807,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `int x` và lớp `B extends A` cũng có `int x`. Lớp `B` gọi `this.x` và `super.x`. Điều gì xảy ra?",
    options: [
      "Sẽ gây ra lỗi biên dịch vì trùng tên biến.",
      "Chỉ `this.x` tham chiếu đến biến của `B`, `super.x` tham chiếu đến biến của `A` (nếu `A.x` không `private`).",
      "Không thể sử dụng `super.x` vì biến instance không bị ghi đè.",
      "Cả hai đều tham chiếu đến cùng một biến của lớp `B`.",
    ],
    answer: 2,
    explanation:
      "Các biến instance không bị ghi đè [10]. Tuy nhiên, nếu `x` trong `A` là `public` hoặc `protected`, `super.x` sẽ truy cập biến của lớp cha. Nếu `x` trong `A` là `private`, `super.x` sẽ không hợp lệ. Nhưng vì lớp con không nên định nghĩa lại biến đã kế thừa [10], [55].",
  },
  {
    id: 808,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `Cat c = new Cat(); Mammal m = c;`, tham chiếu `m` (kiểu `Mammal`) vẫn giữ thông tin rằng đối tượng thực tế là `Cat` nhờ cơ chế nào?",
    options: [
      "Liên kết tĩnh.",
      "Run-Time Type Information (RTTI).",
      "Downcasting.",
      "Sử dụng từ khóa `this`.",
    ],
    answer: 1,
    explanation:
      "Mặc dù tham chiếu là `Mammal`, đối tượng vẫn giữ bản chất `Cat` của nó [18]. Hành vi đa hình (Dynamic Binding) dựa trên thông tin kiểu đối tượng thực tế (RTTI) để gọi phương thức [84], [32].",
  },
  {
    id: 809,
    topic: "Inheritance",
    type: "radio",
    question: "Tại sao lớp `Object` không được coi là lớp `abstract`?",
    options: [
      "Vì nó không có constructor.",
      "Vì nó không có phương thức `abstract`.",
      "Vì nó không thể được kế thừa.",
      "Vì nó có các phương thức bị ghi đè.",
    ],
    answer: 1,
    explanation:
      "Một lớp được coi là `abstract` nếu nó có ít nhất một phương thức `abstract` [108]. `Object` là một non-abstract class vì nó có các phương thức đã được triển khai sẵn mà tất cả các lớp có thể kế thừa và sử dụng [109].",
  },
  {
    id: 810,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu lớp `A` có một phương thức được khai báo là `public` và lớp `B` (lớp con) cố gắng ghi đè nó thành `protected`?",
    options: [
      "Lỗi biên dịch vì access level bị hạn chế.",
      "Lỗi biên dịch vì kiểu trả về không khớp.",
      "Nó được coi là Overloading hợp lệ.",
      "Nó được phép nếu `A` và `B` cùng package.",
    ],
    answer: 0,
    explanation:
      "Bạn không được phép hạn chế access level của phương thức ghi đè (phương thức lớp con phải có access level bằng hoặc rộng hơn lớp cha) [30].",
  },
  {
    id: 811,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Piece` có phương thức `move(Position p)` ném ra `IOException` (Checked Exception). Lớp con `King` ghi đè phương thức này, nó có thể ném ra loại Exception nào?",
    options: [
      "Một `Exception` mới không liên quan.",
      "`IOException` hoặc `FileNotFoundException` (lớp con của `IOException`)",
      "Chỉ `Exception` (lớp cha của `IOException`)",
      "Phải ném ra `RuntimeException`.",
    ],
    answer: 1,
    explanation:
      "Phương thức ghi đè có thể ném ra cùng một loại Checked Exception, hoặc một subtype của nó [77]. `FileNotFoundException` là một subtype của `IOException` [110].",
  },
  {
    id: 812,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `Mammal m = new Cat();`, tham chiếu `m` chỉ có thể gọi các phương thức có sẵn trong kiểu `Mammal`. Điều này được kiểm tra ở giai đoạn nào?",
    options: [
      "Runtime (Thời gian chạy).",
      "Compile-time (Thời gian biên dịch).",
      "Thiết kế (Design time).",
      "Initialization (Khởi tạo).",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch kiểm tra kiểu tham chiếu để đảm bảo rằng phương thức được gọi hợp lệ với kiểu đó, ngay cả khi đối tượng thực tế có nhiều khả năng hơn [42], [43].",
  },
  {
    id: 813,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là ĐÚNG khi sử dụng `this()` và `super()` trong constructor?",
    options: [
      "Có thể gọi cả hai trong cùng một constructor.",
      "Cả hai đều phải là câu lệnh đầu tiên, do đó chỉ có thể gọi một trong hai.",
      "`this()` gọi constructor lớp cha, `super()` gọi constructor lớp con.",
      "Cả hai đều không được phép nếu lớp cha là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Cả `this()` (gọi constructor cùng lớp) và `super()` (gọi constructor lớp cha) đều phải là câu lệnh đầu tiên, do đó chúng loại trừ lẫn nhau [111], [40].",
  },
  {
    id: 814,
    topic: "Inheritance",
    type: "radio",
    question:
      "Lớp `Wrapper` trong Java (ví dụ: `Integer` gói `int`) được thiết kế dựa trên nguyên tắc OOP nào?",
    options: [
      "Polymorphism.",
      "Composition (Thành phần).",
      "Inheritance (Kế thừa từ `Object`).",
      "Singleton.",
    ],
    answer: 2,
    explanation:
      "Lớp Wrapper gói gọn kiểu dữ liệu nguyên thủy, mang lại cho nó vẻ ngoài của một đối tượng [112], và bản thân nó là các lớp bình thường, kế thừa từ `Object` [113].",
  },
  {
    id: 815,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi nào thì phương thức `toString()` của lớp `Object` thường được ghi đè?",
    options: [
      "Khi lớp cần hiển thị danh sách các tham số của nó.",
      "Khi lớp cần trả về biểu diễn văn bản (text representation) có ý nghĩa của đối tượng.",
      "Khi lớp là lớp con của một Interface.",
      "Khi lớp có các phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `String toString()` trả về biểu diễn văn bản của đối tượng và thường được định nghĩa lại (ghi đè) để cung cấp thông tin hữu ích về đối tượng [106], [114].",
  },
  {
    id: 816,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public static void methodB()`, và lớp `B extends A` cũng có `public static void methodB()`. Khi Upcasting `A a = new B();` và gọi `a.methodB()`, phiên bản nào được gọi?",
    options: [
      "Phiên bản `methodB()` của `A` (Static Binding).",
      "Phiên bản `methodB()` của `B` (Dynamic Binding).",
      "Lỗi biên dịch.",
      "Cả hai phiên bản.",
    ],
    answer: 0,
    explanation:
      "Các phương thức `static` không thể bị ghi đè, mà bị ẩn (hidden). Việc gọi chúng sử dụng Static Binding (Liên kết tĩnh), dựa trên kiểu tham chiếu (`A`), do đó phiên bản của `A` được gọi [33], [32].",
  },
  {
    id: 817,
    topic: "Inheritance",
    type: "radio",
    question:
      "Lợi ích nào sau đây là kết quả trực tiếp của Kế thừa và Đa hình?",
    options: [
      "Tăng cường khả năng sử dụng các kiểu dữ liệu nguyên thủy.",
      "Tái sử dụng code và tăng tính linh hoạt của hệ thống đối với các kiểu mới.",
      "Giới hạn số lượng đối tượng có thể được tạo.",
      "Buộc tất cả các trường phải là `private`.",
    ],
    answer: 1,
    explanation:
      "Kế thừa cho phép tái sử dụng code (giảm trùng lặp) [102], và đa hình cho phép hệ thống linh hoạt khi thêm các lớp con mới [52].",
  },
  {
    id: 818,
    topic: "Inheritance",
    type: "radio",
    question: "Điều nào sau đây là KHÔNG thể đối với một lớp cha?",
    options: [
      "Có constructor `private`.",
      "Kế thừa từ một lớp khác.",
      "Gọi constructor của lớp con bằng `super()`.",
      "Triển khai một Interface.",
    ],
    answer: 2,
    explanation:
      "Lớp cha không thể gọi constructor của lớp con. Các lớp con kế thừa từ lớp cha, không phải ngược lại. Không có kiểu kế thừa ngược [49], [60].",
  },
  {
    id: 819,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Vehicle` là `abstract` với phương thức `abstract void create()`. Lớp con `Car extends Vehicle` phải làm gì với `create()`?",
    options: [
      "Phải khai báo `create()` là `final`.",
      "Phải khai báo `create()` là `static`.",
      "Phải triển khai (implement) phương thức `create()` nếu `Car` là concrete class.",
      "Không cần làm gì, nó được kế thừa tự động.",
    ],
    answer: 2,
    explanation:
      "Các phương thức `abstract` (trừu tượng) phải được ghi đè (triển khai) trong lớp con concrete đầu tiên trong cây kế thừa [81], [57], [43].",
  },
  {
    id: 820,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi nào thì Java chèn lệnh gọi `super()` vào constructor lớp con?",
    options: [
      "Khi lớp cha là `abstract`.",
      "Khi lớp con không gọi rõ ràng `this()` hoặc `super()`.",
      "Chỉ khi lớp con có constructor mặc định.",
      "Khi lớp con có các trường `private`.",
    ],
    answer: 1,
    explanation:
      "Nếu constructor của lớp con không gọi rõ ràng `super()` hoặc `this()`, trình biên dịch sẽ tự động chèn `super()` [15], [91].",
  },
  {
    id: 821,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Piece` có phương thức `public Position getPosition()`. Lớp con `Rook` ghi đè phương thức này thành `public Position getPosition()`. Đây là ví dụ về quy tắc ghi đè nào?",
    options: [
      "Nó là không hợp lệ vì không có thay đổi.",
      "Kiểu trả về phải giống nhau (hoặc là kiểu con).",
      "Access modifier phải được giới hạn.",
      "Nó là Overloading.",
    ],
    answer: 1,
    explanation:
      "Kiểu trả về phải giống nhau hoặc là kiểu con (covariant return type) [31]. Việc giữ nguyên kiểu trả về là hợp lệ và phổ biến.",
  },
  {
    id: 822,
    topic: "Inheritance",
    type: "radio",
    question: "Downcasting là bắt buộc phải làm thủ công vì lý do gì?",
    options: [
      "Để JVM tối ưu hóa bộ nhớ.",
      "Để người lập trình chịu trách nhiệm kiểm tra an toàn (sử dụng `instanceof`)",
      "Vì lớp cha luôn là `abstract`.",
      "Vì Downcasting sử dụng liên kết tĩnh.",
    ],
    answer: 1,
    explanation:
      "Downcasting phải được thực hiện thủ công để người lập trình ý thức được rủi ro `ClassCastException` và thực hiện kiểm tra an toàn [18], [20], [23].",
  },
  {
    id: 823,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `Animal a = new Dog();`, đối tượng `Dog` trên heap chứa bao nhiêu phần (tính cả lớp cha `Object`)?",
    options: [
      "Một phần (chỉ `Dog`).",
      "Một phần (`Dog`) và một phần `Animal` (lớp cha) và một phần `Object` (siêu lớp tối thượng).",
      "Chỉ phần `Animal`.",
      "Chỉ các phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "Một đối tượng trên heap chứa các phần từ lớp của nó và tất cả các lớp cha của nó trong cây kế thừa, bao gồm cả `Object` [115], [116], [46].",
  },
  {
    id: 824,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong mô hình `Pair<T extends Comparable<T> & Serializable>`, `Comparable<T>` và `Serializable` được gọi là gì?",
    options: [
      "Unbounded wildcards.",
      "Generic interfaces.",
      "Multiple bounds (Giới hạn đa kiểu).",
      "Recursive types.",
    ],
    answer: 2,
    explanation:
      "Cú pháp này sử dụng giới hạn đa kiểu (Multiple bounds), trong đó tham số kiểu `T` phải kế thừa một lớp và triển khai một hoặc nhiều interface [117].",
  },
  {
    id: 825,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về Constructor Chaining (Chuỗi Constructor)?",
    options: [
      "Nó chỉ xảy ra nếu `super()` được gọi rõ ràng.",
      "Nó luôn bắt đầu từ constructor của lớp con xuống lớp cha.",
      "Tất cả các constructor trong cây kế thừa của đối tượng phải chạy khi tạo đối tượng mới.",
      "Nó bị ngăn chặn bởi từ khóa `final`.",
    ],
    answer: 2,
    explanation:
      "Tất cả các constructor trong cây kế thừa phải chạy khi bạn tạo một đối tượng mới [46], [37].",
  },
  {
    id: 826,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` và `B` nằm trong các package khác nhau, và `B extends A`. Lớp `A` có `protected void methodX()`. Điều gì đúng?",
    options: [
      "`B` không thể gọi `methodX()` vì khác package.",
      "`B` có thể gọi `methodX()` vì nó là lớp con.",
      "Chỉ các lớp trong package của `A` mới có thể gọi `methodX()`.",
      "`methodX()` được coi là `default` access.",
    ],
    answer: 1,
    explanation:
      "`protected` cho phép truy cập từ lớp con ở mọi package [47], [48].",
  },
  {
    id: 827,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, mục đích của việc ghi đè phương thức `equals(Object o)` trong lớp `Object` là gì?",
    options: [
      "So sánh tham chiếu bộ nhớ (giống `==`).",
      "So sánh giá trị (state) của hai đối tượng.",
      "Kiểm tra kiểu lớp (giống `instanceof`).",
      "Tính toán mã hash (hash code).",
    ],
    answer: 1,
    explanation:
      "Phiên bản mặc định của `equals()` trong `Object` là so sánh `==` (so sánh tham chiếu) [118]. Khi ghi đè, nó được sử dụng để so sánh giá trị (state) của hai đối tượng [106], [119].",
  },
  {
    id: 828,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là quan trọng đối với lớp con khi lớp cha có constructor `private`?",
    options: [
      "Lớp con không thể được định nghĩa vì constructor `private` không thể truy cập để gọi `super()`.",
      "Lớp con phải gọi constructor `private` bằng `this()`.",
      "Lớp con phải là `final`.",
      "Lớp con phải là `abstract`.",
    ],
    answer: 0,
    explanation:
      "Nếu một lớp có constructor `private`, nó không thể được mở rộng, vì lỗi biên dịch sẽ xảy ra khi cố gắng gọi `super()` (mà không thể truy cập được) [120].",
  },
  {
    id: 829,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu `Animal a = new Cat();`, và `Cat` có phương thức `private void meow()`. Tham chiếu `a` có thể gọi `meow()` không?",
    options: [
      "Có, vì đối tượng thực tế là `Cat`.",
      "Không, vì `meow()` là `private` và không nằm trong `Animal`.",
      "Chỉ sau khi Downcasting.",
      "Chỉ khi `Cat` là `final`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `private` không được kế thừa, và không thể truy cập từ bên ngoài lớp, ngay cả khi tham chiếu đa hình được sử dụng [10].",
  },
  {
    id: 830,
    topic: "Inheritance",
    type: "code",
    question: "Đoạn mã sau in ra gì? (Static binding vs Dynamic binding)",
    code: 'class Parent { public static void print() { System.out.print("Parent Static"); } public void run() { System.out.print("Parent Run"); } } class Child extends Parent { public static void print() { System.out.print("Child Static"); } public void run() { System.out.print("Child Run"); } } public class Test { public static void main(String[] args) { Parent p = new Child(); p.print(); p.run(); } }',
    options: [
      "Child StaticChild Run",
      "Parent StaticParent Run",
      "Parent StaticChild Run",
      "Child StaticParent Run",
    ],
    answer: 2,
    explanation:
      "Phương thức `print()` là `static`, sử dụng Static Binding (liên kết dựa trên kiểu tham chiếu `Parent`), in ra 'Parent Static'. Phương thức `run()` là instance, sử dụng Dynamic Binding (liên kết dựa trên kiểu đối tượng thực tế `Child`), in ra 'Child Run' [33], [32].",
  },
  {
    id: 831,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là đúng về việc Downcasting một đối tượng đã được Upcasting?",
    options: [
      "Nó luôn thành công và không cần kiểm tra.",
      "Nó chỉ thành công nếu đối tượng ban đầu thực sự là kiểu lớp con đích.",
      "Nó chỉ thành công nếu cả lớp cha và lớp con đều nằm trong cùng một package.",
      "Nó yêu cầu sử dụng `final`.",
    ],
    answer: 1,
    explanation:
      "Bạn chỉ có thể downcasting trở lại kiểu ban đầu hoặc kiểu cha mẹ của kiểu đó. Nếu đối tượng không khớp, `ClassCastException` sẽ được ném ra [20], [26], [23].",
  },
  {
    id: 832,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ngôn ngữ Java, mục đích của việc thiết kế một lớp `abstract` là gì?",
    options: [
      "Để tạo ra một đối tượng mẫu có thể sử dụng trực tiếp.",
      "Để cung cấp một khuôn mẫu (template) cho một nhóm các lớp con, cho phép chia sẻ mã và định nghĩa các phương thức cần ghi đè.",
      "Để ngăn chặn tất cả các phương thức bị ghi đè.",
      "Để cho phép đa kế thừa giữa các lớp.",
    ],
    answer: 1,
    explanation:
      "Lớp abstract được sử dụng để định nghĩa một khuôn mẫu cho các lớp con. Nó cho phép chia sẻ các đoạn code chung và định nghĩa các phương thức trừu tượng (cần ghi đè) [81], [121].",
  },
  {
    id: 833,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có phương thức `void print(String s)` và lớp `B extends A` có `void print(Object o)`. Đây là gì?",
    options: [
      "Overriding",
      "Overloading",
      "Lỗi biên dịch",
      "Che giấu phương thức",
    ],
    answer: 1,
    explanation:
      "Đây là Overloading, vì danh sách tham số (kiểu `String` so với kiểu `Object`) khác nhau, mặc dù tên phương thức giống nhau [98], [99].",
  },
  {
    id: 834,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, `Cat c2 = (Cat) a;` là một hành động tiềm ẩn nguy hiểm vì lý do gì?",
    options: [
      "Nó là Static Binding.",
      "Trình biên dịch không thể đảm bảo an toàn kiểu tại thời điểm biên dịch.",
      "Nó yêu cầu `this` keyword.",
      "Nó luôn dẫn đến `NullPointerException`.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch cho phép downcasting nếu có khả năng thành công, nhưng không thể kiểm tra an toàn tại thời điểm biên dịch. Rủi ro sẽ xuất hiện tại runtime nếu đối tượng thực tế không khớp [26], [23].",
  },
  {
    id: 835,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, lớp con không thể làm gì với các phương thức đã kế thừa?",
    options: [
      "Ghi đè chúng.",
      "Gọi chúng bằng `super`.",
      "Thay đổi kiểu trả về sang kiểu không tương thích khi ghi đè.",
      "Kế thừa chúng.",
    ],
    answer: 2,
    explanation:
      "Khi ghi đè, kiểu trả về phải là cùng kiểu hoặc là kiểu con (covariant return type) của kiểu trả về lớp cha. Thay đổi sang kiểu không tương thích sẽ gây lỗi biên dịch [31], [89].",
  },
  {
    id: 836,
    topic: "Inheritance",
    type: "radio",
    question:
      "Lớp `Object` bao gồm phương thức nào được sử dụng để trả về kiểu lớp (Class type) của đối tượng hiện tại?",
    options: ["getSuperclass()", "getName()", "getClass()", "getObjectType()"],
    answer: 2,
    explanation:
      "Phương thức `Class getClass()` trong lớp `Object` trả về tên lớp của đối tượng hiện tại [106], [114], [122].",
  },
  {
    id: 837,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ngữ cảnh `super`, điều gì là mục đích của việc gọi `super()` khi lớp cha có constructor mặc định?",
    options: [
      "Khởi tạo các biến `final` của lớp con.",
      "Thực hiện các lệnh khởi tạo trong constructor lớp cha, đảm bảo phần lớp cha của đối tượng được xây dựng.",
      "Ngăn chặn lớp cha được sử dụng.",
      "Gọi phương thức `main()` của lớp cha.",
    ],
    answer: 1,
    explanation:
      "Mục đích của `super()` là để thực thi chuỗi constructor, đảm bảo phần lớp cha của đối tượng được xây dựng và khởi tạo [46], [75], [60].",
  },
  {
    id: 838,
    topic: "Inheritance",
    type: "radio",
    question: "Nếu lớp `Car` là `final`, điều gì là đúng?",
    options: [
      "Không thể tạo đối tượng `Car`.",
      "Các phương thức của `Car` không thể bị ghi đè.",
      "Không thể có lớp con của `Car`.",
      "Các trường của `Car` là `static`.",
    ],
    answer: 2,
    explanation:
      "Final class: không thể được kế thừa (subclassed) [14], [51], [85].",
  },
  {
    id: 839,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong một chương trình cờ vua, việc sử dụng `Piece p = new Queen();` là một ví dụ tuyệt vời về tính chất nào?",
    options: [
      "Encapsulation.",
      "Upcasting và Polymorphism.",
      "Downcasting và Runtime Exception.",
      "Static Binding.",
    ],
    answer: 1,
    explanation:
      "Đây là Upcasting (gán lớp con cho tham chiếu lớp cha) cho phép Polymorphism (đa hình), nơi `p` có thể đại diện cho bất kỳ loại quân cờ nào [72], [93].",
  },
  {
    id: 840,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public void methodC()`. Lớp `B extends A` có `public String methodC()`. Điều gì xảy ra?",
    options: [
      "Overloading hợp lệ.",
      "Overriding hợp lệ (covariant return type).",
      "Lỗi biên dịch vì kiểu trả về không tương thích.",
      "Che giấu phương thức.",
    ],
    answer: 2,
    explanation:
      "Đây là lỗi biên dịch. Kiểu trả về phải là cùng kiểu hoặc là kiểu con (subclass) của kiểu trả về lớp cha. `String` không phải là kiểu con của `void` [31], [89].",
  },
  {
    id: 841,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `wildcard` (`?`) trong Generics là gì?",
    options: [
      "Để giới hạn kiểu tham số ở một lớp cụ thể.",
      "Để cho phép sử dụng các kiểu không xác định hoặc bị ràng buộc (unknown or bounded types) trong các method signature.",
      "Để thay thế từ khóa `extends`.",
      "Để cho phép đa kế thừa.",
    ],
    answer: 1,
    explanation:
      "Wildcards (`?`) được sử dụng để tạo ra các kiểu tham số có thể làm việc với một phạm vi các kiểu khác nhau (ví dụ: `List<?>`) [123].",
  },
  {
    id: 842,
    topic: "Inheritance",
    type: "radio",
    question: "Trong Java, điều gì là ĐÚNG về lớp `Object`?",
    options: [
      "Nó chỉ là lớp cha của các lớp do người dùng định nghĩa.",
      "Nó là lớp cha của tất cả các lớp, bao gồm cả các lớp Wrapper.",
      "Nó chứa các trường instance của mọi lớp.",
      "Nó chứa phương thức `main()`.",
    ],
    answer: 1,
    explanation:
      "Mọi lớp, bao gồm cả các lớp Wrapper (`Integer`, `Long`, v.v.), đều kế thừa từ `Object` [16], [59].",
  },
  {
    id: 843,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu lớp `Animal` không có constructor mặc định và lớp `Dog` (lớp con) có constructor mặc định `Dog()`?",
    options: [
      "Lỗi biên dịch.",
      "Chương trình chạy bình thường vì `Dog` có constructor mặc định.",
      "Chỉ constructor `Dog()` được gọi.",
      "Cần sử dụng `this()`.",
    ],
    answer: 0,
    explanation:
      "Trình biên dịch cố gắng chèn `super()` vào `Dog()`, nhưng vì `Animal` không có constructor mặc định, lỗi biên dịch sẽ xảy ra [15], [91].",
  },
  {
    id: 844,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu `Animal a = new Dog();` và `Dog` ghi đè `sound()`. Khi gọi `a.sound()`, phiên bản `Dog.sound()` chạy vì cơ chế nào?",
    options: [
      "Tính đa hình (Polymorphism) và Dynamic Binding.",
      "Tính đóng gói (Encapsulation).",
      "Tính trừu tượng (Abstraction).",
      "Static Binding.",
    ],
    answer: 0,
    explanation:
      "Đây là cốt lõi của đa hình. Mặc dù tham chiếu là lớp cha, phiên bản lớp con (ghi đè) được gọi tại runtime do Dynamic Binding [21], [32], [8].",
  },
  {
    id: 845,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `protected` method. Lớp `B` (trong package khác) kế thừa `A`. `B` cố gắng ghi đè nó thành `public`. Điều này là:",
    options: [
      "Không hợp lệ (Lỗi biên dịch).",
      "Hợp lệ, vì nó làm cho access level rộng hơn.",
      "Hợp lệ, vì nó là `protected`.",
      "Chỉ hợp lệ nếu `A` là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Ghi đè cho phép mở rộng access level (từ `protected` sang `public` là hợp lệ) [30].",
  },
  {
    id: 846,
    topic: "Inheritance",
    type: "radio",
    question:
      "Downcasting là cần thiết khi bạn lấy một đối tượng từ cấu trúc dữ liệu nào có thể trả về tham chiếu kiểu `Object` (ví dụ: trước JDK 5.0)?",
    options: [
      "String Array.",
      "Primitive Array.",
      "ArrayList (Non-Generic).",
      "HashMap<String, String>.",
    ],
    answer: 2,
    explanation:
      "Khi lấy đối tượng từ `ArrayList` (non-generic), chúng thường được trả về dưới dạng kiểu `Object`. Sau đó, cần phải ép kiểu thủ công (Downcasting) trở lại kiểu ban đầu [124], [125], [50].",
  },
  {
    id: 847,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Rook` có `Position currentPosition` và `Rook` muốn gọi phương thức `isValidMove(Position p)` chung từ lớp cha `Piece` để kiểm tra ranh giới, nó nên dùng cú pháp nào?",
    options: [
      "Piece.isValidMove(p)",
      "super.isValidMove(p)",
      "this.isValidMove(p)",
      "p.isValidMove()",
    ],
    answer: 1,
    explanation:
      "Sử dụng `super.isValidMove(p)` để gọi rõ ràng phiên bản lớp cha của phương thức đã ghi đè [34], [126].",
  },
  {
    id: 848,
    topic: "Inheritance",
    type: "radio",
    question: "Lớp nào sau đây là lớp cha trực tiếp của `Integer`?",
    options: ["int", "Number", "Primitive", "Wrapper"],
    answer: 1,
    explanation:
      "Tài liệu nhắc đến `Integer`, `Short`, `Byte`, `Long`, `Float`, `Double` đều là các lớp Wrapper thuộc hệ thống phân cấp dưới lớp `Number` [113].",
  },
  {
    id: 849,
    topic: "Inheritance",
    type: "radio",
    question: "Trong trường hợp nào, `instanceof` là vô nghĩa?",
    options: [
      "Kiểm tra Downcasting.",
      "Kiểm tra đa hình.",
      "Kiểm tra xem một đối tượng có phải là `Object` không (luôn là `true`).",
      "Kiểm tra `null`.",
    ],
    answer: 2,
    explanation:
      "Mọi đối tượng (trừ `null`) đều là một thể hiện của `Object` [17], [127], do đó kiểm tra `if (obj instanceof Object)` là thừa thãi.",
  },
  {
    id: 850,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc khai báo một biến tham chiếu là `Object` (`Object o = new Dog();`) là gì?",
    options: [
      "Buộc sử dụng Downcasting.",
      "Giới hạn quyền truy cập chỉ các phương thức cơ bản của `Object`.",
      "Cho phép đối tượng chấp nhận bất kỳ kiểu dữ liệu nào (trừ nguyên thủy).",
      "Cả A và B.",
    ],
    answer: 3,
    explanation:
      "`Object` là kiểu đa hình tối thượng, cho phép tham chiếu đến bất kỳ đối tượng nào [59], [127]. Tuy nhiên, việc này giới hạn quyền truy cập chỉ các phương thức trong lớp `Object` (ví dụ: `equals()`, `toString()`) [115], [43].",
  },
  {
    id: 851,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có constructor mặc định. Lớp `B extends A` có `B() { this(5); }` và `B(int x)`. Constructor nào của `A` được gọi?",
    options: [
      "Constructor A() được gọi từ `B(int x)`.",
      "Constructor A() được gọi từ `B()`.",
      "Không có constructor nào của `A` được gọi.",
      "Lỗi biên dịch.",
    ],
    answer: 0,
    explanation:
      "`B()` gọi `B(5)` bằng `this()`. `B(int x)` sẽ tự động chèn `super()` là câu lệnh đầu tiên (vì không có `this()` hoặc `super()` rõ ràng), gọi constructor `A()` [111], [38], [91].",
  },
  {
    id: 852,
    topic: "Inheritance",
    type: "radio",
    question:
      "Sự khác biệt giữa liên kết tĩnh (Static Binding) và liên kết động (Dynamic Binding) là gì?",
    options: [
      "Static Binding xảy ra tại runtime, Dynamic Binding tại compile time.",
      "Static Binding được dùng cho phương thức `final`, Dynamic Binding cho phương thức `private`.",
      "Static Binding dựa trên kiểu tham chiếu, Dynamic Binding dựa trên kiểu đối tượng thực tế.",
      "Static Binding được dùng cho Overriding, Dynamic Binding cho Overloading.",
    ],
    answer: 2,
    explanation:
      "Static Binding xác định kiểu đối tượng tại compile time (kiểu tham chiếu), Dynamic Binding xác định tại runtime (kiểu đối tượng thực tế) [128], [33].",
  },
  {
    id: 853,
    topic: "Inheritance",
    type: "radio",
    question: "Trong trường hợp nào, `ClassCastException` là không thể xảy ra?",
    options: [
      "Upcasting.",
      "Downcasting có kiểm tra `instanceof`.",
      "Downcasting không kiểm tra `instanceof`.",
      "Ghi đè phương thức.",
    ],
    answer: 0,
    explanation:
      "Upcasting luôn được thực hiện tự động và an toàn, vì lớp con luôn là một kiểu của lớp cha [17], [19].",
  },
  {
    id: 854,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `int x` và lớp `B extends A` có `int y`. Tổng số biến instance mà một đối tượng `B` có là bao nhiêu?",
    options: [
      "1 (chỉ y).",
      "2 (x được kế thừa, y của chính B).",
      "Phụ thuộc vào `access modifier`.",
      "Không xác định.",
    ],
    answer: 1,
    explanation:
      "Lớp con kế thừa tất cả các biến instance và phương thức public của lớp cha [10]. Nếu `x` không phải là `private`, `B` có `x` và `y` [129], [130]. Nếu `x` là `private`, `B` vẫn có 'phần' chứa `x` nhưng không thể truy cập trực tiếp [115], [116]. Tuy nhiên, nếu không nói rõ, ta giả định nó có 2 trường (1 kế thừa, 1 tự định nghĩa).",
  },
  {
    id: 855,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, mục đích của việc sử dụng `if (a instanceof Cat)` là gì?",
    options: [
      "Để kiểm tra xem `a` có phải là `null` không.",
      "Để ràng buộc kiểu tham chiếu là `Cat`.",
      "Để chỉ thực hiện Downcasting nếu đối tượng thực tế là `Cat` hoặc lớp con của `Cat`.",
      "Để kích hoạt Dynamic Binding.",
    ],
    answer: 2,
    explanation: "Đó là cơ chế để đảm bảo an toàn Downcasting [20], [25].",
  },
  {
    id: 856,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Java, một lớp có thể kế thừa (extends) nhiều lớp cha không?",
    options: [
      "Có, nếu tất cả là `abstract`.",
      "Không, chỉ cho phép đơn kế thừa.",
      "Có, nếu sử dụng Generic.",
      "Chỉ khi sử dụng Interface.",
    ],
    answer: 1,
    explanation: "Chỉ cho phép đơn kế thừa [6], [73], [7], [131].",
  },
  {
    id: 857,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về Dynamic Binding?",
    options: [
      "Nó chỉ áp dụng cho các phương thức `static`.",
      "Nó chỉ xảy ra khi gọi phương thức trên một tham chiếu lớp cha.",
      "Nó xảy ra cho tất cả các phương thức non-static bị ghi đè.",
      "Nó làm tăng tốc độ thực thi chương trình.",
    ],
    answer: 2,
    explanation:
      "Dynamic Binding (hoặc Runtime Binding) được sử dụng cho các phương thức bị ghi đè (non-static) [33], [32], [84].",
  },
  {
    id: 858,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `protected` constructor. Lớp `B extends A` có thể gọi constructor này như thế nào?",
    options: [
      "Không thể gọi được.",
      "Chỉ bằng cách sử dụng `this()`.",
      "Bằng cách sử dụng `super()` hoặc `super(args)`.",
      "Chỉ nếu chúng khác package.",
    ],
    answer: 2,
    explanation:
      "Constructor `protected` có thể truy cập được từ lớp con ở mọi package. Lớp con sử dụng `super()` để gọi nó [47], [36].",
  },
  {
    id: 859,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng `super` để gọi phương thức lớp cha?",
    options: [
      "Đảm bảo phiên bản lớp con được gọi.",
      "Để tránh viết lại logic chung của lớp cha.",
      "Chỉ để khởi tạo biến instance.",
      "Để buộc Static Binding.",
    ],
    answer: 1,
    explanation:
      "Bằng cách sử dụng `super.method()`, lớp con tái sử dụng logic đã được viết trong lớp cha [34], [35], [107].",
  },
  {
    id: 860,
    topic: "Inheritance",
    type: "radio",
    question:
      "Thứ tự nào là đúng của việc constructor hoàn thành (hoàn tất) khi `new Child()` được gọi?",
    options: [
      "Child -> Parent -> Object",
      "Object -> Parent -> Child",
      "Parent -> Child -> Object",
      "Object -> Child -> Parent",
    ],
    answer: 1,
    explanation:
      "Chuỗi constructor chạy từ trên xuống dưới: `Object` hoàn thành trước, sau đó là `Parent`, sau đó là `Child` [61], [62], [60].",
  },
  {
    id: 861,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public void foo()`. Lớp `B extends A` có `private void foo()`. Điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Overloading.",
      "Phương thức lớp `B` sẽ được gọi.",
      "Che giấu phương thức.",
    ],
    answer: 0,
    explanation:
      "Đây là lỗi biên dịch vì phương thức lớp con cố gắng hạn chế quyền truy cập của phương thức ghi đè (`public` -> `private`) [30].",
  },
  {
    id: 862,
    topic: "Inheritance",
    type: "radio",
    question: "Nếu lớp `A` là `abstract` và có một constructor. Điều gì đúng?",
    options: [
      "Constructor đó sẽ không bao giờ được gọi.",
      "Constructor đó phải là `private`.",
      "Constructor đó được gọi khi lớp con của `A` được khởi tạo.",
      "Lớp `A` phải là `final`.",
    ],
    answer: 2,
    explanation:
      "Constructor của lớp trừu tượng không thể được gọi trực tiếp, nhưng nó được gọi khi tạo đối tượng của lớp kế thừa (lớp con) [78]. Chuỗi constructor đảm bảo điều này xảy ra [46].",
  },
  {
    id: 863,
    topic: "Inheritance",
    type: "radio",
    question: "Khi Downcasting, nếu đối tượng là `null`, điều gì xảy ra?",
    options: [
      "`ClassCastException`.",
      "`NullPointerException`.",
      "Downcasting thành công và đối tượng vẫn là `null`.",
      "Lỗi biên dịch.",
    ],
    answer: 2,
    explanation:
      "Downcasting một tham chiếu `null` luôn thành công và kết quả vẫn là `null`. `ClassCastException` chỉ xảy ra khi cố gắng ép kiểu một đối tượng không tương thích [26].",
  },
  {
    id: 864,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ví dụ cờ vua, logic kiểm tra rằng `#vertical steps` bằng `#horizontal steps` trong `Bishop.isValidMove()` là ví dụ về gì?",
    options: [
      "Mã được chia sẻ (shared code).",
      "Logic cụ thể của lớp con thông qua ghi đè.",
      "Mã sử dụng `super`.",
      "Mã sử dụng liên kết tĩnh.",
    ],
    answer: 1,
    explanation:
      "Đó là logic di chuyển riêng của quân Tượng (Bishop), được triển khai bằng cách ghi đè `isValidMove()` [132]. Logic này khác với logic di chuyển của `Rook` [133].",
  },
  {
    id: 865,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về từ khóa `final` khi áp dụng cho một phương thức?",
    options: [
      "Nó làm cho phương thức đó trở thành `static`.",
      "Nó chỉ cho phép phương thức đó được gọi một lần.",
      "Nó ngăn chặn phương thức đó bị ghi đè trong các lớp con.",
      "Nó buộc phương thức phải trả về kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Một phương thức `final` không thể bị ghi đè [13], [14], [29], [85].",
  },
  {
    id: 866,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong tình huống nào, bạn có thể nhận được `java.lang.ClassCastException`?",
    options: [
      "Upcasting một đối tượng.",
      "Gọi một phương thức `private`.",
      "Downcasting một đối tượng thành kiểu không tương thích.",
      "Kế thừa từ một lớp `final`.",
    ],
    answer: 2,
    explanation:
      "Đây là ngoại lệ phổ biến xảy ra khi Downcasting một đối tượng về một kiểu lớp mà nó không phải là thể hiện [26], [23].",
  },
  {
    id: 867,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` và `B` trong cùng một package. `B extends A`. `A` có `int x` (default access). Điều gì đúng?",
    options: [
      "Chỉ `A` có thể truy cập `x`.",
      "Cả `A` và `B` đều có thể truy cập `x`.",
      "Chỉ các lớp bên ngoài package mới có thể truy cập `x`.",
      "`x` bị ẩn trong `B`.",
    ],
    answer: 1,
    explanation:
      "Access modifier mặc định (default/package-private) cho phép truy cập trong cùng một package [134]. Vì `B` cùng package với `A`, `B` có thể truy cập `x`.",
  },
  {
    id: 868,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc lớp con kế thừa phương thức `public` của lớp cha?",
    options: [
      "Lớp con chỉ được kế thừa nếu nó là `abstract`.",
      "Lớp con kế thừa phương thức đó như thể nó tự định nghĩa phương thức đó.",
      "Lớp con phải gọi phương thức đó bằng `super`.",
      "Phương thức đó tự động trở thành `private` trong lớp con.",
    ],
    answer: 1,
    explanation:
      "Khi một lớp con kế thừa một thành viên, nó giống như thể lớp con tự định nghĩa thành viên đó [135].",
  },
  {
    id: 869,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Dog` có phương thức `sound()` và `Cat` cũng có `sound()`, nhưng chúng không kế thừa lẫn nhau. Đây là ví dụ về gì?",
    options: [
      "Polymorphism.",
      "Overriding.",
      "Inheritance.",
      "Trùng tên phương thức (coincidence) nhưng không phải Overriding.",
    ],
    answer: 3,
    explanation:
      "Overriding yêu cầu mối quan hệ kế thừa [67]. Nếu không có mối quan hệ này, đây chỉ là hai phương thức độc lập tình cờ có cùng tên.",
  },
  {
    id: 870,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, bạn phải khai báo rõ ràng kiểu đích (target type). Đây là hình thức Downcasting nào?",
    options: [
      "Automatic (Tự động).",
      "Explicit (Rõ ràng/thủ công).",
      "Implicit (Ngầm định).",
      "Static (Tĩnh).",
    ],
    answer: 1,
    explanation:
      "Downcasting phải luôn được thực hiện thủ công (explicitly) [17], [18], [24].",
  },
  {
    id: 871,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu `Animal a = new Animal();` được thực hiện. Lệnh `a instanceof Dog` sẽ trả về gì?",
    options: ["true", "false", "Lỗi biên dịch", "Lỗi thời gian chạy"],
    answer: 1,
    explanation:
      "Đối tượng thực tế là `Animal`, không phải là `Dog`, do đó trả về `false`. Nếu bạn cố gắng ép kiểu sẽ gây ra `ClassCastException` [26].",
  },
  {
    id: 872,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong trường hợp nào, việc ghi đè một phương thức không cần giữ nguyên tên phương thức?",
    options: [
      "Overriding.",
      "Overloading.",
      "Trong tất cả các trường hợp.",
      "Không có trường hợp nào.",
    ],
    answer: 2,
    explanation:
      "Việc ghi đè phương thức (Overriding) YÊU CẦU giữ nguyên tên [29], [28]. Trong khi Overloading YÊU CẦU thay đổi tham số nhưng giữ nguyên tên [98], [99]. Tuy nhiên, nếu không có quan hệ overriding/overloading, tên phương thức có thể thay đổi tùy ý.",
  },
  {
    id: 873,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting một đối tượng từ `Object` thành `String` (ví dụ: `String s = (String) o;`), điều gì cho phép hành động này thành công?",
    options: [
      "`String` là lớp cha của `Object`.",
      "Đa hình.",
      "Đối tượng `o` thực sự phải là một instance của `String`.",
      "Không cần ép kiểu nếu `o` là `Object`.",
    ],
    answer: 2,
    explanation:
      "Để Downcasting thành công, đối tượng trên heap phải là kiểu đích. Trong trường hợp này, `o` phải là một instance của `String` [26], [50], [23].",
  },
  {
    id: 874,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public int getX()`. Lớp `B extends A` có `public long getX()`. Điều gì xảy ra?",
    options: [
      "Overriding hợp lệ (covariant return type).",
      "Overloading hợp lệ.",
      "Lỗi biên dịch vì kiểu trả về không tương thích.",
      "Phương thức lớp `B` được gọi.",
    ],
    answer: 2,
    explanation:
      "`long` không phải là kiểu con của `int`. Kiểu trả về phải tương thích. Đây là lỗi biên dịch vì cố gắng ghi đè với kiểu trả về không tương thích [31], [89].",
  },
  {
    id: 875,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc sử dụng `super` trong constructor?",
    options: [
      "Nó chỉ có thể được sử dụng trong constructor mặc định.",
      "Nó phải được sử dụng để gọi constructor lớp cha nếu lớp cha không có constructor mặc định.",
      "Nó là tùy chọn trong mọi trường hợp.",
      "Nó buộc lớp con phải là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Nó là bắt buộc nếu lớp cha không có constructor mặc định [15], [91], [92].",
  },
  {
    id: 876,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, bạn phải truyền đối tượng trong dấu ngoặc đơn. Ví dụ: `(Cat) a`. Đây là cú pháp để làm gì?",
    options: [
      "Ép kiểu rõ ràng (explicit cast).",
      "Khai báo một biến mới.",
      "Thực thi phương thức.",
      "Kiểm tra tính hợp lệ của `a`.",
    ],
    answer: 0,
    explanation:
      "Đó là cú pháp bắt buộc cho việc ép kiểu thủ công (explicit cast) [20], [50].",
  },
  {
    id: 877,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `super.isValidMove(position)` trong lớp `Rook` là để kiểm tra điều gì?",
    options: [
      "Tính hợp lệ của nước đi chéo.",
      "Tính hợp lệ của nước đi thẳng.",
      "Giới hạn của bàn cờ (board bounds).",
      "Đảm bảo `Rook` không di chuyển.",
    ],
    answer: 2,
    explanation:
      "Trong ví dụ cờ vua, phiên bản `Piece.isValidMove()` (lớp cha) thực hiện kiểm tra chung về ranh giới bàn cờ, được gọi bằng `super` trước khi kiểm tra nước đi cụ thể của `Rook` [34], [126].",
  },
  {
    id: 878,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc ghi đè các phương thức `static`?",
    options: [
      "Nó sử dụng Dynamic Binding.",
      "Nó được gọi là che giấu phương thức (method hiding).",
      "Nó là hợp lệ và được khuyến khích.",
      "Lỗi biên dịch xảy ra nếu cố gắng ghi đè.",
    ],
    answer: 1,
    explanation:
      "Bạn không thể ghi đè phương thức `static`. Nếu bạn định nghĩa lại, đó là che giấu phương thức (method hiding) và sử dụng liên kết tĩnh [32], [33].",
  },
  {
    id: 879,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có constructor mặc định. Lớp `B extends A` có constructor `public B() { this(); }`. Điều gì xảy ra?",
    options: [
      "Lỗi biên dịch vì đệ quy vô hạn (infinite recursion).",
      "Lỗi biên dịch vì thiếu `super()`.",
      "Lỗi thời gian chạy.",
      "Chương trình chạy bình thường.",
    ],
    answer: 0,
    explanation:
      "`this()` gọi lại chính nó, dẫn đến đệ quy vô hạn trong constructor, gây lỗi biên dịch hoặc lỗi runtime (StackOverflowError).",
  },
  {
    id: 880,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Animal` là `abstract`, điều gì xảy ra khi `new Animal()` được gọi?",
    options: [
      "Tạo một đối tượng `Animal` rỗng.",
      "Lỗi biên dịch.",
      "Lỗi thời gian chạy.",
      "Constructor của lớp `Object` được gọi.",
    ],
    answer: 1,
    explanation:
      "Không thể tạo đối tượng (instance) từ một lớp trừu tượng [78], [79], [80]. Lệnh này sẽ gây ra lỗi biên dịch.",
  },
  {
    id: 881,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong trường hợp nào, lớp con không nhất thiết phải triển khai (implement) phương thức `abstract` của lớp cha?",
    options: [
      "Khi lớp con cũng được khai báo là `abstract`.",
      "Khi lớp cha là `final`.",
      "Khi phương thức là `private`.",
      "Không có trường hợp nào.",
    ],
    answer: 0,
    explanation:
      "Chỉ lớp con concrete đầu tiên mới bắt buộc phải triển khai tất cả các phương thức trừu tượng. Nếu lớp con cũng là `abstract`, nó có thể trì hoãn việc triển khai đó [57], [108].",
  },
  {
    id: 882,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ví dụ `Person` -> `Student`, nếu `Person` có `String name` và `Student` cũng có `String name`. Khi `Person p = new Student();`, `p.name` sẽ tham chiếu đến trường nào?",
    options: [
      "Trường `name` của `Student`.",
      "Trường `name` của `Person`.",
      "Lỗi biên dịch vì không thể che giấu biến instance.",
      "Cả hai.",
    ],
    answer: 1,
    explanation:
      "Biến instance không bị ghi đè. Khi truy cập trường (không phải qua getter/setter) trên tham chiếu lớp cha, nó sẽ truy cập biến trong phạm vi khai báo của tham chiếu (`Person.name`) [129].",
  },
  {
    id: 883,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu `Object o = list.get(0);` và `list` là `ArrayList` (non-generic). Để gọi phương thức `bark()` của đối tượng `Dog` bên trong `o`, bạn cần làm gì?",
    options: [
      "Upcasting `o` sang `Dog`.",
      "Sử dụng `instanceof`.",
      "Downcasting `o` sang `Dog`.",
      "Không thể gọi phương thức dành riêng cho lớp con.",
    ],
    answer: 2,
    explanation:
      "Cần ép kiểu rõ ràng (Downcasting) `o` thành `Dog` để truy cập các phương thức dành riêng cho `Dog` như `bark()` [22], [136], [50].",
  },
  {
    id: 884,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về quy tắc cho kiểu trả về khi ghi đè một phương thức?",
    options: [
      "Kiểu trả về phải là kiểu nguyên thủy.",
      "Kiểu trả về có thể là bất kỳ kiểu nào.",
      "Kiểu trả về phải là kiểu con (subtype) của kiểu trả về lớp cha.",
      "Kiểu trả về phải là `Object`.",
    ],
    answer: 2,
    explanation:
      "Kiểu trả về phải là cùng kiểu hoặc là kiểu con (covariant return type) [31], [89].",
  },
  {
    id: 885,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Vehicle` được kế thừa bởi `Car` và `Truck`. Việc gọi `super()` trong constructor của `Car` nhằm mục đích gì?",
    options: [
      "Khởi tạo `Car` trước `Vehicle`.",
      "Đảm bảo constructor của `Vehicle` được gọi.",
      "Ngăn chặn việc ghi đè phương thức.",
      "Chỉ gọi constructor mặc định của `Car`.",
    ],
    answer: 1,
    explanation:
      "Lệnh gọi `super()` đảm bảo rằng constructor của lớp cha (`Vehicle`) được gọi để xây dựng phần lớp cha của đối tượng [37], [75].",
  },
  {
    id: 886,
    topic: "Inheritance",
    type: "radio",
    question: "Mối quan hệ `X IS-A Y` đúng khi nào?",
    options: [
      "`X` là lớp cha của `Y`.",
      "`Y` là lớp cha của `X`.",
      "`X` và `Y` là các lớp anh chị em.",
      "`X` và `Y` là `final`.",
    ],
    answer: 1,
    explanation:
      "Nếu `Y` là lớp cha của `X` (`X extends Y`), thì `X IS-A Y` [137], [8].",
  },
  {
    id: 887,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` không có constructor mặc định. Lớp `B extends A` có thể được tạo ra nếu:",
    options: [
      "`B` không có constructor nào.",
      "`B` gọi `super(args)` trong constructor của nó.",
      "`A` được khai báo là `final`.",
      "`B` không có trường instance.",
    ],
    answer: 1,
    explanation:
      "Nếu lớp cha thiếu constructor mặc định, lớp con phải gọi rõ ràng constructor có tham số của lớp cha bằng `super(args)` [15], [91].",
  },
  {
    id: 888,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là quan trọng để Downcasting từ `Animal` thành `Dog` thành công?",
    options: [
      "Kiểu tham chiếu phải là `Animal`.",
      "Kiểu đối tượng thực tế phải là `Dog` hoặc lớp con của `Dog`.",
      "Phương thức `sound()` phải bị ghi đè.",
      "Upcasting phải được thực hiện bằng tay.",
    ],
    answer: 1,
    explanation:
      "Sự thành công của Downcasting phụ thuộc vào kiểu đối tượng thực tế trên heap [26], [23].",
  },
  {
    id: 889,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, nếu không có `instanceof`, tại sao trình biên dịch vẫn chấp nhận cú pháp đó?",
    options: [
      "Vì trình biên dịch tin tưởng lập trình viên.",
      "Vì nó nhận ra rằng về mặt lý thuyết, đối tượng đó CÓ THỂ là kiểu đích.",
      "Vì nó là Dynamic Binding.",
      "Vì `ClassCastException` là Unchecked Exception.",
    ],
    answer: 1,
    explanation:
      "Downcasting vượt qua biên dịch (compiles) vì về mặt lý thuyết, đối tượng CÓ THỂ là kiểu đích [26], [23].",
  },
  {
    id: 890,
    topic: "Inheritance",
    type: "radio",
    question:
      "Sự khác biệt giữa Overriding và Hiding (che giấu phương thức static) là gì?",
    options: [
      "Overriding dùng cho `static`, Hiding dùng cho instance.",
      "Overriding dùng Dynamic Binding, Hiding dùng Static Binding.",
      "Overriding cần `super`, Hiding không cần.",
      "Overriding không cần quan hệ kế thừa, Hiding cần.",
    ],
    answer: 1,
    explanation:
      "Phương thức bị ghi đè (instance) sử dụng Dynamic Binding. Phương thức bị ẩn (static) sử dụng Static Binding [33], [32].",
  },
  {
    id: 891,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public final void methodF()`. Lớp `B extends A` có thể làm gì?",
    options: [
      "Ghi đè `methodF()` để thay đổi logic.",
      "Gọi `super.methodF()` và thêm logic của riêng mình.",
      "Không thể kế thừa `methodF()`.",
      "Khai báo một phương thức `static` cùng tên.",
    ],
    answer: 1,
    explanation:
      "Phương thức `final` không thể bị ghi đè [13], [14]. Tuy nhiên, nó vẫn được kế thừa và có thể được gọi [13], [138].",
  },
  {
    id: 892,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Animal` là lớp cha, khai báo `ArrayList<Animal> list = new ArrayList<Dog>();` có hợp lệ không?",
    options: [
      "Hợp lệ.",
      "Không hợp lệ vì không có mối quan hệ kế thừa giữa các kiểu Generic.",
      "Chỉ hợp lệ nếu `Dog` là `final`.",
      "Chỉ hợp lệ nếu sử dụng `wildcard`.",
    ],
    answer: 1,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: `ArrayList<Animal>` và `ArrayList<Dog>`), do đó đây là lỗi biên dịch [139], [140], [64].",
  },
  {
    id: 893,
    topic: "Inheritance",
    type: "radio",
    question: "Trong ví dụ `Pair<T>`, tham số kiểu `T` cho phép bạn làm gì?",
    options: [
      "Chỉ sử dụng các kiểu nguyên thủy.",
      "Tái sử dụng cùng một mã với các kiểu đầu vào khác nhau.",
      "Ngăn chặn ép kiểu.",
      "Thực hiện đa kế thừa.",
    ],
    answer: 1,
    explanation:
      "Generics cho phép các lớp chấp nhận tham số kiểu khi định nghĩa, cho phép tái sử dụng cùng một mã với các kiểu đầu vào khác nhau [141], [142].",
  },
  {
    id: 894,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, điều gì cho phép bạn truy cập `Dog.fetch()` sau khi Downcasting `Animal` thành `Dog`?",
    options: [
      "Dynamic Binding.",
      "Phương thức `fetch()` được di chuyển lên `Animal`.",
      "Kiểu tham chiếu mới (`Dog`) chứa chữ ký của `fetch()`.",
      "Sử dụng `instanceof`.",
    ],
    answer: 2,
    explanation:
      "Sau khi Downcasting, kiểu tham chiếu trở thành `Dog`, cho phép bạn gọi các phương thức chỉ có trong lớp `Dog` [22], [50].",
  },
  {
    id: 895,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public String getName()`. Lớp `B extends A` có `public Object getName()`. Điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Overriding hợp lệ.",
      "Overloading hợp lệ.",
      "Che giấu phương thức.",
    ],
    answer: 0,
    explanation:
      "`Object` là lớp cha của `String`. Khi ghi đè, kiểu trả về lớp con phải là cùng kiểu hoặc kiểu con (covariant return type) của lớp cha. Vì `Object` rộng hơn `String`, đây là lỗi biên dịch [31], [89].",
  },
  {
    id: 896,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong Generics, nếu bạn muốn một phương thức chấp nhận `List<Integer>`, `List<Number>`, và `List<Object>`, bạn sử dụng wildcard nào?",
    options: [
      `List<? extends Integer>`,
      `List<? super Integer>`,
      `List<Integer>`,
      `List<?>`,
    ],
    answer: 1,
    explanation:
      "Sử dụng Lower Bounded Wildcard (`? super Integer`) giới hạn kiểu không xác định là kiểu cha (supertype) của `Integer` [143].",
  },
  {
    id: 897,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có constructor `A(int x)`. Lớp `B extends A` có constructor `B(String s)`. Điều gì xảy ra?",
    options: [
      "Lỗi biên dịch nếu `B(String s)` không gọi `super(int)`.",
      "Chương trình chạy bình thường.",
      "Constructor `A(int x)` được gọi tự động.",
      "Lớp `B` phải là `abstract`.",
    ],
    answer: 0,
    explanation:
      "Vì `A` chỉ có constructor có tham số, `B` phải gọi rõ ràng `super(int)` để đảm bảo chuỗi constructor [15], [91], [92].",
  },
  {
    id: 898,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về Upcasting trong Java?",
    options: [
      "Nó là ép kiểu rõ ràng (explicit cast).",
      "Nó là ép kiểu ngầm định (implicit cast).",
      "Nó chỉ hoạt động nếu lớp cha là `Object`.",
      "Nó yêu cầu `instanceof`.",
    ],
    answer: 1,
    explanation:
      "Upcasting được thực hiện tự động (ngầm định) [17], [18], [24].",
  },
  {
    id: 899,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong ngữ cảnh kế thừa, nếu lớp `Animal` là lớp cha, việc khởi tạo `Animal a = new Animal();` tạo ra kiểu đối tượng nào?",
    options: [
      "Đối tượng `Object`.",
      "Đối tượng `Animal`.",
      "Đối tượng `Dog` (kiểu con đầu tiên).",
      "Đối tượng `null`.",
    ],
    answer: 1,
    explanation: "Đối tượng thực tế được tạo là `Animal` [26], [22].",
  },
  {
    id: 900,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc thiết kế các lớp con như `Checking`, `SavingAccount` để kế thừa `BankAccount` là để làm gì?",
    options: [
      "Thực hiện các thao tác I/O phức tạp.",
      "Tổ chức mã bằng cách tách các thuộc tính chung và riêng biệt.",
      "Buộc sử dụng Generics.",
      "Ngăn chặn Downcasting.",
    ],
    answer: 1,
    explanation:
      "Kế thừa cho phép thiết kế tốt hơn, tổ chức mã bằng cách trừu tượng hóa các thuộc tính chung vào lớp cha và giữ các thuộc tính riêng biệt trong lớp con [101], [11].",
  },
  {
    id: 901,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting từ `Object` xuống một lớp cụ thể, nếu không có Generics, điều gì là bắt buộc phải làm?",
    options: [
      "Gọi `super()`.",
      "Gọi `this()`.",
      "Sử dụng toán tử ép kiểu thủ công.",
      "Phương thức phải là `final`.",
    ],
    answer: 2,
    explanation:
      "Downcasting luôn cần ép kiểu rõ ràng/thủ công [17], [18], [24].",
  },
  {
    id: 902,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu lớp con ghi đè một phương thức nhưng không sử dụng `super`?",
    options: [
      "Logic lớp cha sẽ tự động chạy trước.",
      "Logic lớp cha sẽ bị bỏ qua và chỉ logic lớp con chạy.",
      "Lỗi biên dịch xảy ra.",
      "Nó trở thành Overloading.",
    ],
    answer: 1,
    explanation:
      "Nếu bạn ghi đè một phương thức, bạn về cơ bản bỏ qua mọi thứ đã có trong lớp cha. Để chạy logic lớp cha, bạn phải gọi rõ ràng `super.method()` [34].",
  },
  {
    id: 903,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `Animal a = new Dog();`, đối tượng `Dog` trên heap được tạo ở đâu?",
    options: [
      "Stack memory.",
      "Static memory.",
      "Heap memory.",
      "Code segment.",
    ],
    answer: 2,
    explanation:
      "Trong Java, các đối tượng (objects) luôn được phân bổ động trên Heap [144], [145], [146].",
  },
  {
    id: 904,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `int x = 10;` và lớp `B extends A` có `int x = 20;`. Khi `A a = new B();`, giá trị của `a.x` là bao nhiêu?",
    options: [
      "10 (Giá trị của lớp tham chiếu).",
      "20 (Giá trị của lớp đối tượng).",
      "Lỗi biên dịch.",
      "Lỗi thời gian chạy.",
    ],
    answer: 0,
    explanation:
      "Biến instance không bị ghi đè. Truy cập trường trên tham chiếu lớp cha sẽ truy cập trường của lớp cha [129], [10]. Giá trị là 10 (của A).",
  },
  {
    id: 905,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong mô hình `Pair<T extends Number & Comparable<T>>`, điều gì là ĐÚNG về `T`?",
    options: [
      "`T` phải là `Number` hoặc `Comparable<T>`.",
      "`T` phải là kiểu cha (supertype) của `Number`.",
      "`T` phải kế thừa `Number` VÀ triển khai `Comparable<T>`.",
      "`T` chỉ có thể là `Integer` hoặc `Long`.",
    ],
    answer: 2,
    explanation:
      "Cú pháp giới hạn đa kiểu (`&`) yêu cầu kiểu `T` phải thỏa mãn tất cả các ràng buộc, tức là phải là kiểu con của `Number` và triển khai `Comparable<T>` [117].",
  },
  {
    id: 906,
    topic: "Inheritance",
    type: "radio",
    question: "Khi Downcasting, bạn đang làm gì với kiểu tham chiếu?",
    options: [
      "Mở rộng kiểu tham chiếu.",
      "Thu hẹp kiểu tham chiếu.",
      "Giữ nguyên kiểu tham chiếu.",
      "Thay đổi đối tượng thực tế.",
    ],
    answer: 1,
    explanation:
      "Downcasting thay đổi kiểu tham chiếu từ rộng (superclass) sang hẹp hơn (subclass) [22], [50].",
  },
  {
    id: 907,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về Upcasting trong Java?",
    options: [
      "Nó chỉ hoạt động khi lớp cha là `final`.",
      "Nó là cơ chế nền tảng cho Polymorphism.",
      "Nó yêu cầu Downcasting ngay sau đó.",
      "Nó thay đổi logic phương thức của đối tượng.",
    ],
    answer: 1,
    explanation:
      "Upcasting là cơ sở để tham chiếu đa hình có thể hoạt động, do đó là nền tảng cho Polymorphism [93], [147].",
  },
  {
    id: 908,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` là lớp cha và `B` là lớp con. Khi `A a = new B();`, nếu phương thức `m3()` không bị ghi đè, cuộc gọi `a.m3()` sẽ sử dụng liên kết nào?",
    options: [
      "Static Binding.",
      "Dynamic Binding.",
      "Early Binding.",
      "Multicasting.",
    ],
    answer: 1,
    explanation:
      "Vì `m3()` là một phương thức instance (non-static), nó sử dụng Dynamic Binding, ngay cả khi nó không bị ghi đè (phiên bản của lớp `A` được gọi) [33], [32].",
  },
  {
    id: 909,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về lớp `Object` và các phương thức của nó?",
    options: [
      "Tất cả các phương thức đều là `final`.",
      "Không thể ghi đè phương thức `getClass()` vì nó là `final`.",
      "Tất cả các phương thức đều là `public`.",
      "Tất cả các phương thức đều phải được ghi đè.",
    ],
    answer: 1,
    explanation:
      "Một số phương thức trong `Object` (như `getClass()`) được đánh dấu là `final`, ngăn chặn việc ghi đè [105].",
  },
  {
    id: 910,
    topic: "Inheritance",
    type: "radio",
    question: "Mục tiêu chính của việc sử dụng `instanceof` là gì?",
    options: [
      "Để kiểm tra trạng thái bộ nhớ.",
      "Để xác minh rằng một đối tượng có thể được ép kiểu một cách an toàn.",
      "Để ngăn chặn Overloading.",
      "Để gọi phương thức `private`.",
    ],
    answer: 1,
    explanation:
      "Toán tử `instanceof` được sử dụng để kiểm tra xem đối tượng có phải là một instance của class (hoặc subclass) đó hay không, cho phép Downcasting an toàn [20], [25].",
  },
  {
    id: 911,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `protected String s`. Lớp `B extends A` (khác package) có thể truy cập `s` không?",
    options: [
      "Không.",
      "Có, vì `B` là lớp con.",
      "Chỉ khi `s` là `final`.",
      "Chỉ khi `s` là `static`.",
    ],
    answer: 1,
    explanation:
      "`protected` cho phép lớp con truy cập các thành viên, bất kể package [47].",
  },
  {
    id: 912,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc Downcasting?",
    options: [
      "Nó là tự động.",
      "Nó làm cho đối tượng trở thành kiểu lớp cha.",
      "Nó giúp lấy lại các phương thức dành riêng cho lớp con.",
      "Nó chỉ áp dụng cho các kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Downcasting cho phép bạn lấy lại quyền truy cập vào các phương thức dành riêng cho lớp con [22], [50].",
  },
  {
    id: 913,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public void go()`. Lớp `B extends A` có `public void go()`. Điều gì là yêu cầu bắt buộc để đây là Overriding?",
    options: [
      "Kiểu trả về phải là kiểu con của `void`.",
      "Phải có cùng danh sách tham số (trống).",
      "Phải sử dụng từ khóa `super`.",
      "Access modifier phải là `private`.",
    ],
    answer: 1,
    explanation:
      "Overriding yêu cầu cùng tên phương thức và cùng danh sách tham số [31], [28].",
  },
  {
    id: 914,
    topic: "Inheritance",
    type: "radio",
    question: "Trong Generics, `Pair<? extends Number>` cho phép bạn làm gì?",
    options: [
      "Chỉ sử dụng `Number`.",
      "Sử dụng `Number` và bất kỳ lớp cha nào của `Number`.",
      "Sử dụng `Number` và bất kỳ lớp con nào của `Number`.",
      "Chỉ sử dụng các kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Upper Bounded Wildcard (`? extends Number`) cho phép sử dụng `Number` hoặc bất kỳ kiểu con nào của `Number` [63].",
  },
  {
    id: 915,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public void print(int x)` và lớp `B extends A` có `public void print(int x)`. Điều này là:",
    options: ["Overloading.", "Overriding.", "Hiding.", "Lỗi biên dịch."],
    answer: 1,
    explanation: "Cùng tên, cùng tham số là Overriding [31], [28].",
  },
  {
    id: 916,
    topic: "Inheritance",
    type: "radio",
    question:
      "Để đảm bảo một phương thức hành xử theo cùng một cách trong tất cả các lớp con, ta sử dụng từ khóa nào?",
    options: ["abstract", "final", "static", "protected"],
    answer: 1,
    explanation:
      "`final` ngăn chặn việc ghi đè, đảm bảo hành vi không đổi [13], [148], [29], [85].",
  },
  {
    id: 917,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `Animal a = new Dog();` và gọi phương thức `eat()` (bị ghi đè), JVM sử dụng kiểu đối tượng nào để quyết định phiên bản nào để chạy?",
    options: [
      "Kiểu tham chiếu (`Animal`).",
      "Kiểu đối tượng thực tế (`Dog`).",
      "Kiểu `Object`.",
      "Kết quả là không thể đoán trước.",
    ],
    answer: 1,
    explanation:
      "Dynamic Binding sử dụng kiểu đối tượng thực tế (`Dog`) [32], [84], [8].",
  },
  {
    id: 918,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Piece` có phương thức `sound()` và `Rook` không ghi đè. Khi `Rook r = new Rook(); r.sound()`, phiên bản nào được gọi?",
    options: [
      "Phiên bản `Rook` rỗng.",
      "Phiên bản `Piece` (kế thừa).",
      "Lỗi biên dịch.",
      "Phiên bản `Object`.",
    ],
    answer: 1,
    explanation:
      "Nếu không ghi đè, lớp con kế thừa và sử dụng phiên bản của lớp cha [5], [56].",
  },
  {
    id: 919,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi `super()` được gọi trong constructor lớp con, điều gì xảy ra với các biến instance của lớp cha?",
    options: [
      "Chúng được khởi tạo sau khi constructor lớp con hoàn thành.",
      "Chúng được khởi tạo trong quá trình thực thi constructor lớp cha.",
      "Chúng được khởi tạo với `null` hoặc 0.",
      "Chúng bị bỏ qua.",
    ],
    answer: 1,
    explanation:
      "Constructor lớp cha chịu trách nhiệm khởi tạo các trường của lớp cha [91], [37].",
  },
  {
    id: 920,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về `instanceof`?",
    options: [
      "Nó hoạt động trên kiểu tham chiếu.",
      "Nó hoạt động trên kiểu đối tượng thực tế.",
      "Nó chỉ dùng để kiểm tra `null`.",
      "Nó yêu cầu Downcasting.",
    ],
    answer: 1,
    explanation:
      "Toán tử `instanceof` kiểm tra kiểu đối tượng thực tế trên heap [20], [25].",
  },
  {
    id: 921,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` là lớp cha và `B` là lớp con. Khi `A a = new B();`, `a` được gọi là gì?",
    options: [
      "Final variable.",
      "Static variable.",
      "Polymorphic reference.",
      "Private reference.",
    ],
    answer: 2,
    explanation:
      "Đây là một tham chiếu đa hình [149], [147], cho phép nó trỏ đến các kiểu đối tượng khác nhau (các lớp con của A).",
  },
  {
    id: 922,
    topic: "Inheritance",
    type: "radio",
    question:
      "Downcasting thất bại tại runtime (ném ra exception) trong tình huống nào?",
    options: [
      "Khi lớp cha là `abstract`.",
      "Khi đối tượng đã Downcasting trước đó.",
      "Khi đối tượng thực tế không phải là kiểu lớp con đích.",
      "Khi không sử dụng `final`.",
    ],
    answer: 2,
    explanation:
      "`ClassCastException` xảy ra khi ép kiểu không hợp lệ [26], [23].",
  },
  {
    id: 923,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public void methodX() throws IOException`. Lớp `B extends A` ghi đè `methodX()`. Điều gì là KHÔNG hợp lệ?",
    options: [
      "Ghi đè và không ném ra exception nào.",
      "Ghi đè và ném ra `FileNotFoundException` (subclass của `IOException`).",
      "Ghi đè và ném ra `Exception` (superclass của `IOException`).",
      "Ghi đè và ném ra `RuntimeException`.",
    ],
    answer: 2,
    explanation:
      "Phương thức lớp con không thể ném ra một Checked Exception rộng hơn (superclass exception) [77].",
  },
  {
    id: 924,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mối quan hệ nào mô tả việc một lớp chứa một tham chiếu đến một lớp khác (ví dụ: `Person` HAS-A `MyDate`)?",
    options: [
      "Inheritance (Kế thừa)",
      "Polymorphism (Đa hình)",
      "Composition (Thành phần) hoặc HAS-A",
      "Abstraction (Trừu tượng)",
    ],
    answer: 2,
    explanation:
      "Composition (Thành phần) đề cập đến nguyên tắc thiết kế nơi một lớp chứa một tham chiếu đến lớp khác, thiết lập mối quan hệ 'has-a' [150], [9].",
  },
  {
    id: 925,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public Object getValue()`. Lớp `B extends A` ghi đè thành `public String getValue()`. Đây là ví dụ về gì?",
    options: [
      "Overloading.",
      "Ghi đè với kiểu trả về covariant.",
      "Lỗi biên dịch.",
      "Hiding.",
    ],
    answer: 1,
    explanation:
      "Vì `String` là kiểu con của `Object`, đây là ghi đè hợp lệ với kiểu trả về covariant [31].",
  },
  {
    id: 926,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về `instanceof` và `null`?",
    options: [
      "`null instanceof AnyClass` trả về `true`.",
      "`null instanceof AnyClass` ném ra `NullPointerException`.",
      "`null instanceof AnyClass` trả về `false`.",
      "`instanceof` không thể được sử dụng với `null`.",
    ],
    answer: 2,
    explanation:
      "Nếu toán hạng bên trái là `null`, `instanceof` luôn trả về `false`.",
  },
  {
    id: 927,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong mô hình kế thừa, điều gì giúp giảm thiểu rủi ro khi thay đổi code?",
    options: [
      "Đóng gói (Encapsulation) và Kế thừa.",
      "Chỉ sử dụng các phương thức `static`.",
      "Sử dụng `final` cho tất cả các lớp.",
      "Downcasting thường xuyên.",
    ],
    answer: 0,
    explanation:
      "Encapsulation (bảo vệ data) và Inheritance (tái sử dụng code chung) giúp tăng tính linh hoạt và dễ bảo trì [151], [152], [102].",
  },
  {
    id: 928,
    topic: "Inheritance",
    type: "radio",
    question: "Nếu lớp `A` là `final`, điều gì là KHÔNG thể?",
    options: [
      "Tạo instance của `A`.",
      "Kế thừa từ `A`.",
      "Sử dụng `A` như một kiểu tham chiếu.",
      "`A` có constructor.",
    ],
    answer: 1,
    explanation: "`final` class không thể được kế thừa [14], [51].",
  },
  {
    id: 929,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, bạn đang cố gắng truy cập lại những thành viên nào?",
    options: [
      "Các thành viên `private` của lớp cha.",
      "Các thành viên `protected` của lớp cha.",
      "Các thành viên dành riêng cho lớp con (subclass-specific members).",
      "Các thành viên `static`.",
    ],
    answer: 2,
    explanation:
      "Downcasting cho phép bạn lấy lại quyền truy cập vào các thuộc tính và phương thức dành riêng cho lớp con [22], [50].",
  },
  {
    id: 930,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc gọi constructor của lớp cha trong constructor lớp con là gì?",
    options: [
      "Đảm bảo các phương thức được ghi đè.",
      "Khởi tạo đúng cách trạng thái kế thừa của đối tượng.",
      "Ngăn chặn Upcasting.",
      "Sử dụng Static Binding.",
    ],
    answer: 1,
    explanation:
      "Constructor lớp cha khởi tạo các trường đã kế thừa. Điều này là bắt buộc cho việc khởi tạo đối tượng đúng cách [46], [91].",
  },
  {
    id: 931,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` và `B` nằm trong cùng package và `B extends A`. `A` có `protected void methodP()`. Điều gì là KHÔNG đúng?",
    options: [
      "`A` có thể gọi `methodP()`.",
      "`B` có thể gọi `methodP()`.",
      "Một lớp khác trong cùng package có thể gọi `methodP()`.",
      "Một lớp khác trong package khác có thể gọi `methodP()`.",
    ],
    answer: 3,
    explanation:
      "`protected` cho phép truy cập trong cùng package [47]. Lớp ngoài package chỉ có thể truy cập nếu chúng là lớp con của `A` [47], [48].",
  },
  {
    id: 932,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì mô tả tốt nhất về Dynamic Binding (Liên kết động)?",
    options: [
      "Quyết định phương thức được gọi tại compile time.",
      "Quyết định phương thức được gọi tại runtime dựa trên kiểu đối tượng thực tế.",
      "Chỉ dành cho các phương thức `final`.",
      "Chỉ dành cho các phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "Dynamic Binding quyết định phương thức được gọi tại runtime (thời gian chạy) dựa trên kiểu đối tượng thực tế [32], [84].",
  },
  {
    id: 933,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `int count`. Lớp `B extends A` cũng có `int count`. Khi `B b = new B(); b.count = 5;`. Giá trị nào của `count` bị thay đổi?",
    options: [
      "Chỉ `A.count`.",
      "Chỉ `B.count`.",
      "Cả hai.",
      "Không có gì thay đổi.",
    ],
    answer: 1,
    explanation:
      "Vì `count` trong `B` che giấu `count` trong `A`, `b.count` tham chiếu đến phiên bản `B.count` [129], [10].",
  },
  {
    id: 934,
    topic: "Inheritance",
    type: "radio",
    question: "Trong Java, một constructor không bao giờ có kiểu trả về nào?",
    options: [
      "Không có kiểu trả về (kể cả `void`).",
      "`void`.",
      "`Object`.",
      "Kiểu lớp của chính nó.",
    ],
    answer: 0,
    explanation:
      "Constructor không có bất kỳ kiểu trả về nào, ngay cả `void` [153].",
  },
  {
    id: 935,
    topic: "Inheritance",
    type: "radio",
    question: "Upcasting được thực hiện khi nào?",
    options: [
      "Khi bạn cố gắng Downcasting.",
      "Khi bạn gán một đối tượng lớp con cho một tham chiếu lớp cha.",
      "Khi bạn sử dụng `instanceof`.",
      "Khi bạn gọi `super()`.",
    ],
    answer: 1,
    explanation:
      "Upcasting là gán đối tượng lớp con cho tham chiếu lớp cha [17], [18], [19].",
  },
  {
    id: 936,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng `super` để gọi constructor có tham số của lớp cha?",
    options: [
      "Để khởi tạo các trường `static`.",
      "Để truyền dữ liệu khởi tạo cần thiết cho lớp cha.",
      "Để thay thế constructor lớp cha.",
      "Để buộc lớp cha là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Sử dụng `super(args)` cho phép truyền dữ liệu để khởi tạo các trường trong lớp cha [91], [54].",
  },
  {
    id: 937,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public int calculate()`. Lớp `B extends A` có `public int calculate()`. `B` không có code. Khi `A a = new B(); a.calculate()`, code nào chạy?",
    options: [
      "Code của `B` (rỗng).",
      "Code của `A` (được kế thừa).",
      "Lỗi biên dịch.",
      "Lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Nếu `B` ghi đè nhưng thân phương thức rỗng, thì code trong `B` chạy (và không làm gì). Nhưng nếu `B` không ghi đè, nó sẽ kế thừa và chạy code của `A` [5], [56]. (Giả sử `B` ghi đè nhưng không có `super`, thì code rỗng của `B` chạy. Nếu `B` không ghi đè, code của `A` chạy). Vì không có code trong `B` mà chỉ có khai báo, ta giả định nó là Overriding rỗng, code `B` chạy và không làm gì.",
  },
  {
    id: 938,
    topic: "Inheritance",
    type: "radio",
    question: "Mục đích của việc sử dụng `instanceof` là gì?",
    options: [
      "Thực hiện liên kết tĩnh.",
      "Ngăn chặn `NullPointerException`.",
      "Kiểm tra tính an toàn của Downcasting.",
      "Buộc Upcasting.",
    ],
    answer: 2,
    explanation: "Đảm bảo Downcasting là an toàn [20], [25].",
  },
  {
    id: 939,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là KHÔNG đúng về kế thừa trong Java?",
    options: [
      "Hỗ trợ đơn kế thừa lớp.",
      "Các lớp con kế thừa tất cả các thành viên `public`.",
      "Lớp con có thể truy cập trực tiếp các thành viên `private` của lớp cha.",
      "Đa hình là kết quả của kế thừa.",
    ],
    answer: 2,
    explanation:
      "Các lớp con không thể truy cập trực tiếp các thành viên `private` của lớp cha [12], [10].",
  },
  {
    id: 940,
    topic: "Inheritance",
    type: "radio",
    question: "Khi Downcasting, điều gì là cần thiết?",
    options: [
      "Sử dụng từ khóa `final`.",
      "Ép kiểu rõ ràng.",
      "Chỉ sử dụng các lớp `abstract`.",
      "Sử dụng liên kết tĩnh.",
    ],
    answer: 1,
    explanation:
      "Downcasting yêu cầu ép kiểu rõ ràng/thủ công [17], [18], [24].",
  },
  {
    id: 941,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `private int id`. Lớp `B extends A` có thể khởi tạo `id` như thế nào?",
    options: [
      "Bằng cách truy cập trực tiếp `super.id`.",
      "Bằng cách sử dụng một phương thức setter `public` trong `A`.",
      "Bằng cách khai báo lại `id` trong `B`.",
      "Không thể khởi tạo.",
    ],
    answer: 1,
    explanation:
      "Vì `private` không được kế thừa, `B` phải sử dụng getter/setter công khai của `A` để thao tác với `id` [76], [12], [10].",
  },
  {
    id: 942,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc sử dụng tham chiếu đa hình (`Animal a`) là để làm gì?",
    options: [
      "Ghi đè Dynamic Binding.",
      "Giảm tính linh hoạt của mã.",
      "Tăng tính linh hoạt của mã để xử lý các kiểu con khác nhau.",
      "Chỉ gọi các phương thức `static`.",
    ],
    answer: 2,
    explanation:
      "Đa hình cho phép mã làm việc với các kiểu con khác nhau mà không cần thay đổi [53], [52], [147].",
  },
  {
    id: 943,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về chuỗi constructor?",
    options: [
      "Nó bắt đầu từ constructor lớp con.",
      "Nó bắt đầu từ constructor lớp `Object`.",
      "Nó được thực thi bởi `this()`.",
      "Nó chỉ xảy ra nếu không có constructor mặc định.",
    ],
    answer: 1,
    explanation:
      "Chuỗi constructor luôn đi ngược lên cây kế thừa cho đến `Object`, và hoàn thành từ `Object` xuống lớp con cuối cùng [37], [61], [62].",
  },
  {
    id: 944,
    topic: "Inheritance",
    type: "radio",
    question: "Khi `super.method()` được gọi, nó sử dụng cơ chế liên kết nào?",
    options: [
      "Luôn luôn là Static Binding.",
      "Luôn luôn là Dynamic Binding.",
      "Phụ thuộc vào việc phương thức đó có `final` không.",
      "Phụ thuộc vào việc phương thức đó có tham số không.",
    ],
    answer: 1,
    explanation:
      "Mặc dù `super` chỉ định phiên bản lớp cha, nó vẫn là một lời gọi phương thức instance và sử dụng Dynamic Binding [33], [32].",
  },
  {
    id: 945,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là KHÔNG đúng về Overriding?",
    options: [
      "Nó xảy ra giữa lớp cha và lớp con.",
      "Nó phải có cùng danh sách tham số.",
      "Nó có thể thay đổi kiểu trả về thành kiểu không tương thích.",
      "Nó cho phép thay đổi access modifier sang rộng hơn.",
    ],
    answer: 2,
    explanation:
      "Kiểu trả về phải tương thích (cùng kiểu hoặc kiểu con) [31], [89].",
  },
  {
    id: 946,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` là lớp cha và `B` là lớp con. Khi Downcasting `(B) a`, điều gì là cần thiết?",
    options: [
      "Tham chiếu `a` phải là `null`.",
      "Đối tượng thực tế phải là `A`.",
      "Đối tượng thực tế phải là `B`.",
      "Sử dụng `static`.",
    ],
    answer: 2,
    explanation:
      "Đối tượng thực tế trên heap phải là kiểu đích để tránh `ClassCastException` [26], [23].",
  },
  {
    id: 947,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, nếu không có `instanceof`, điều gì là rủi ro chính?",
    options: [
      "Lỗi biên dịch.",
      "Mất dữ liệu.",
      "`ClassCastException` tại runtime.",
      "`NullPointerException`.",
    ],
    answer: 2,
    explanation:
      "Nguy cơ lớn nhất là `ClassCastException` nếu ép kiểu không đúng [26], [23].",
  },
  {
    id: 948,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc lớp con kế thừa các thành viên `private`?",
    options: [
      "Chúng được kế thừa và có thể truy cập bằng `super`.",
      "Chúng được kế thừa nhưng không thể truy cập trực tiếp.",
      "Chúng không được kế thừa.",
      "Chúng trở thành `protected`.",
    ],
    answer: 1,
    explanation:
      "Các thành viên `private` không được kế thừa để truy cập trực tiếp, nhưng 'phần' lớp cha của đối tượng vẫn chứa chúng [12], [10], [115].",
  },
  {
    id: 949,
    topic: "Inheritance",
    type: "radio",
    question: "Upcasting được sử dụng khi nào?",
    options: [
      "Khi cần lưu trữ các đối tượng lớp con khác nhau trong cùng một kiểu tham chiếu lớp cha.",
      "Khi cần gọi một phương thức dành riêng cho lớp con.",
      "Khi cần buộc liên kết tĩnh.",
      "Khi cần Downcasting.",
    ],
    answer: 0,
    explanation:
      "Upcasting là cơ chế cho phép đa hình, lưu trữ nhiều kiểu lớp con dưới một kiểu lớp cha chung [93], [87].",
  },
  {
    id: 950,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` là lớp cha, và `B` là lớp con. `A a = new A();` và `a` có thể được Downcasting thành `B` không?",
    options: [
      "Luôn luôn.",
      "Không bao giờ, vì `A` không phải là `B`.",
      "Chỉ nếu `A` là `abstract`.",
      "Chỉ nếu `a` là `null`.",
    ],
    answer: 1,
    explanation: "Downcasting sẽ thất bại vì `A` không phải là `B` [26], [23].",
  },
  {
    id: 951,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `final` cho một phương thức là để đạt được nguyên tắc thiết kế nào?",
    options: [
      "Encapsulation (Đóng gói).",
      "Sự đơn giản của mã (Code simplicity).",
      "Ngăn chặn sự thay đổi hành vi ngoài ý muốn trong tương lai (Close for modification).",
      "Static Binding.",
    ],
    answer: 2,
    explanation:
      "Đánh dấu `final` ngăn chặn overriding, đảm bảo hành vi không bị thay đổi bởi các lớp con, hỗ trợ nguyên tắc OCP (đóng để sửa đổi) [13], [29].",
  },
  {
    id: 952,
    topic: "Inheritance",
    type: "radio",
    question:
      "Trong trường hợp nào, lệnh gọi `super()` không được tự động chèn?",
    options: [
      "Constructor lớp con gọi `this()`.",
      "Constructor lớp con rỗng.",
      "Constructor lớp cha là `abstract`.",
      "Constructor lớp cha là `public`.",
    ],
    answer: 0,
    explanation:
      "Nếu lớp con gọi constructor khác của chính nó bằng `this()`, `super()` không được chèn tự động, vì `this()` phải là câu lệnh đầu tiên [38], [40].",
  },
  {
    id: 953,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `Animal` là lớp cha, một `ArrayList<Animal>` có thể chứa những gì?",
    options: [
      "Chỉ các đối tượng được khởi tạo là `new Animal()`.",
      "Bất kỳ đối tượng nào (Upcasting thành `Animal`).",
      "Các đối tượng là `Animal` hoặc bất kỳ lớp con nào của `Animal`.",
      "Chỉ các lớp `final`.",
    ],
    answer: 2,
    explanation:
      "Do Upcasting và Polymorphism, nó có thể chứa các đối tượng `Animal` và các lớp con của `Animal` [87].",
  },
  {
    id: 954,
    topic: "Inheritance",
    type: "radio",
    question: "Trong trường hợp nào, bạn sử dụng cú pháp Downcasting:",
    options: [
      "Khi sử dụng `instanceof`.",
      "Khi làm việc với các kiểu Generic.",
      "Khi ép kiểu từ `Object` sang `String`.",
      "Khi ép kiểu từ `String` sang `Object`.",
    ],
    answer: 2,
    explanation:
      "Ép kiểu từ `Object` (rộng) sang `String` (hẹp) là Downcasting và cần cú pháp ép kiểu thủ công [50], [18].",
  },
  {
    id: 955,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về liên kết tĩnh (Static Binding) trong Java?",
    options: [
      "Nó được sử dụng cho các phương thức bị ghi đè.",
      "Nó dựa trên kiểu đối tượng thực tế.",
      "Nó được sử dụng cho các phương thức `static` và `final`.",
      "Nó chỉ xảy ra trong constructor.",
    ],
    answer: 2,
    explanation:
      "Static Binding được sử dụng cho các phương thức `static` và `final` [33], [32]. (Cũng được dùng cho các phương thức `private` và các trường).",
  },
  {
    id: 956,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` có `public void start()`. Lớp `B extends A` có `public void start()`. `A a = new B(); a.start()`. Phiên bản nào chạy?",
    options: [
      "Phiên bản `A.start()`.",
      "Phiên bản `B.start()`.",
      "Lỗi biên dịch.",
      "Cả hai.",
    ],
    answer: 1,
    explanation:
      "Do Dynamic Binding, phiên bản lớp con (`B`) chạy [32], [84], [8].",
  },
  {
    id: 957,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi lớp `A` có `int x = 5` và `B extends A` không định nghĩa lại `x`. Giá trị của `super.x` trong `B` là bao nhiêu?",
    options: [
      "5 (Giá trị kế thừa từ A).",
      "0 (Giá trị mặc định).",
      "Lỗi biên dịch.",
      "Không xác định.",
    ],
    answer: 0,
    explanation:
      "Vì `B` không định nghĩa lại `x`, nó kế thừa `x` từ `A`, và `super.x` truy cập vào giá trị này [129], [10].",
  },
  {
    id: 958,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về từ khóa `super`?",
    options: [
      "Nó chỉ được dùng để gọi constructor.",
      "Nó có thể được dùng để gọi cả phương thức và constructor của lớp cha.",
      "Nó là một biến instance.",
      "Nó chỉ được dùng trong các phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "Có thể dùng `super.method()` để gọi phương thức và `super(args)` để gọi constructor [34], [36], [75], [154].",
  },
  {
    id: 959,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì xảy ra nếu lớp `A` là lớp cha, và `B extends A` có phương thức `public void print()` nhưng `A` không có.",
    options: [
      "Phương thức này bị ghi đè.",
      "Phương thức này là mới trong `B`.",
      "Lỗi biên dịch.",
      "Nó là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Để là Overriding, phương thức phải tồn tại trong lớp cha [41]. Nếu không, đó là một phương thức mới trong `B`.",
  },
  {
    id: 960,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, nếu đối tượng thực tế là `Dog`, biểu thức `(Cat) a` sẽ ném ra ngoại lệ nào?",
    options: [
      "`NullPointerException`.",
      "`ArrayIndexOutOfBoundsException`.",
      "`ClassCastException`.",
      "`IOException`.",
    ],
    answer: 2,
    explanation:
      "Downcasting một đối tượng không tương thích sẽ ném ra `ClassCastException` [26], [23].",
  },
  {
    id: 961,
    topic: "Inheritance",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `super` để gọi phương thức lớp cha là để đạt được nguyên tắc thiết kế nào?",
    options: [
      "Đóng gói (Encapsulation).",
      "Tái sử dụng code (Code reuse).",
      "Giới hạn quyền truy cập.",
      "Liên kết tĩnh (Static Binding).",
    ],
    answer: 1,
    explanation:
      "Sử dụng `super` giúp tái sử dụng logic chung của lớp cha [34], [35], [107].",
  },
  {
    id: 962,
    topic: "Inheritance",
    type: "radio",
    question: "Trong trường hợp nào, `ClassCastException` xảy ra?",
    options: [
      "Upcasting.",
      "Downcasting một kiểu không tương thích.",
      "Gọi phương thức không tồn tại.",
      "Sử dụng `instanceof`.",
    ],
    answer: 1,
    explanation:
      "Lỗi xảy ra khi Downcasting một đối tượng không tương thích [26], [23].",
  },
  {
    id: 963,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu `A` là lớp cha và `B` là lớp con. Khi `A a = new B();`, `a` có thể gọi các phương thức nào?",
    options: [
      "Tất cả các phương thức của `A` và `B`.",
      "Chỉ các phương thức `public` của `A`.",
      "Chỉ các phương thức `private` của `A`.",
      "Các phương thức của `B` không bị ghi đè.",
    ],
    answer: 1,
    explanation:
      "Tham chiếu `a` chỉ có thể gọi các phương thức được định nghĩa trong kiểu `A` [22], [42], [43].",
  },
  {
    id: 964,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là KHÔNG đúng về việc ghi đè phương thức?",
    options: [
      "Nó cho phép thay đổi access modifier sang hẹp hơn.",
      "Nó cho phép thay đổi kiểu trả về thành kiểu con.",
      "Nó giữ nguyên tên và tham số.",
      "Nó sử dụng Dynamic Binding.",
    ],
    answer: 0,
    explanation: "Không được hạn chế access level khi ghi đè [30].",
  },
  {
    id: 965,
    topic: "Inheritance",
    type: "radio",
    question: "Khi Downcasting, điều gì cần được kiểm tra để đảm bảo an toàn?",
    options: [
      "Kiểu trả về.",
      "Từ khóa `final`.",
      "Toán tử `instanceof`.",
      "Lệnh gọi `super()`.",
    ],
    answer: 2,
    explanation:
      "Sử dụng `instanceof` để kiểm tra tính an toàn trước khi ép kiểu [20], [25].",
  },
  {
    id: 966,
    topic: "Inheritance",
    type: "radio",
    question:
      "Nếu lớp `A` là lớp cha, `B extends A` có `public B(int x)`. Lệnh nào được chèn tự động vào `B(int x)`?",
    options: [
      "this();",
      "super();",
      "Không có gì (vì B có constructor).",
      "this(x);",
    ],
    answer: 1,
    explanation:
      "Nếu không có `this()` hoặc `super()` rõ ràng, `super()` được chèn tự động, giả sử `A` có constructor mặc định [15], [91], [92].",
  },
  {
    id: 967,
    topic: "Inheritance",
    type: "radio",
    question: "Upcasting được thực hiện như thế nào?",
    options: [
      "Luôn luôn thủ công.",
      "Luôn luôn tự động.",
      "Sử dụng `instanceof`.",
      "Sử dụng `super`.",
    ],
    answer: 1,
    explanation: "Upcasting được thực hiện tự động [17], [18], [24].",
  },
  {
    id: 968,
    topic: "Inheritance",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng tham chiếu lớp cha (`Animal`) để lưu trữ đối tượng lớp con (`Dog`)?",
    options: [
      "Giới hạn tính đa hình.",
      "Kích hoạt liên kết tĩnh.",
      "Tận dụng tính đa hình.",
      "Buộc Downcasting.",
    ],
    answer: 2,
    explanation: "Đó là cách để tận dụng tính đa hình [93], [147], [87].",
  },
  {
    id: 969,
    topic: "Inheritance",
    type: "radio",
    question:
      "Khi Downcasting, bạn phải đảm bảo rằng kiểu tham chiếu mới là gì?",
    options: [
      "Là kiểu lớp cha.",
      "Là kiểu lớp con của đối tượng thực tế.",
      "Là kiểu `Object`.",
      "Là kiểu `final`.",
    ],
    answer: 1,
    explanation:
      "Kiểu tham chiếu mới phải là kiểu lớp con thực tế (hoặc lớp con của nó) [20], [23].",
  },
  {
    id: 970,
    topic: "Inheritance",
    type: "radio",
    question: "Điều gì là ĐÚNG về chuỗi constructor?",
    options: [
      "Nó đảm bảo rằng lớp con được khởi tạo trước.",
      "Nó đảm bảo rằng lớp cha được khởi tạo trước.",
      "Nó được kiểm tra tại runtime.",
      "Nó là tùy chọn.",
    ],
    answer: 1,
    explanation:
      "Lớp cha phải được xây dựng và khởi tạo hoàn toàn trước lớp con [46], [60].",
  },
  {
    id: 971,
    topic: "Abstract Class",
    question: "Đặc điểm cơ bản nhất của Lớp Trừu tượng (Abstract Class) là gì?",
    options: [
      "Nó phải chứa ít nhất một Abstract Method.",
      "Nó không thể được khởi tạo (instantiated) bằng từ khóa 'new'.",
      "Nó không thể có constructor.",
      "Tất cả các thành viên của nó đều phải là 'private'.",
    ],
    answer: 1,
    explanation: "Lớp Trừu tượng không thể được khởi tạo (tạo đối tượng).",
  },
  {
    id: 972,
    topic: "Abstract Class",
    question: "Từ khóa nào được sử dụng để khai báo một lớp là Lớp Trừu tượng?",
    options: ["class abstract", "interface", "abstract", "virtual"],
    answer: 2,
    explanation:
      "Để khai báo một Abstract Class, ta sử dụng từ khóa 'abstract' trước từ khóa 'class'.",
  },
  {
    id: 973,
    topic: "Abstract Class",
    question:
      "Điều gì xảy ra khi bạn cố gắng tạo một đối tượng từ một Abstract Class (ví dụ: Shape s = new Shape();)?",
    options: [
      "Chương trình chạy bình thường.",
      "Lỗi Biên dịch (Compile Error).",
      "Lỗi Runtime (Runtime Error) do ClassCastException.",
      "Đối tượng được tạo nhưng tự động là 'null'.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch ngăn chặn việc khởi tạo Abstract Class, gây ra lỗi biên dịch.",
  },
  {
    id: 974,
    topic: "Abstract Method",
    question:
      "Một Abstract Method (Phương thức Trừu tượng) được định nghĩa như thế nào?",
    options: [
      "Nó có thân hàm nhưng chỉ chứa code dọn dẹp.",
      "Nó không có thân hàm (method body) và kết thúc bằng dấu chấm phẩy (;).",
      "Nó luôn luôn phải là 'private' và 'final'.",
      "Nó được định nghĩa trong lớp con Concrete.",
    ],
    answer: 1,
    explanation:
      "Một Abstract Method không có thân hàm và phải kết thúc bằng dấu chấm phẩy.",
  },
  {
    id: 975,
    topic: "Abstract Class",
    question:
      "Nếu một lớp chứa DÙ CHỈ MỘT Abstract Method, điều gì là bắt buộc đối với lớp đó?",
    options: [
      "Lớp đó phải là 'final'.",
      "Lớp đó phải được khai báo là 'abstract'.",
      "Lớp đó phải implement một Interface.",
      "Lớp đó không được có fields non-static.",
    ],
    answer: 1,
    explanation:
      "Nếu một lớp có dù chỉ một phương thức trừu tượng, lớp đó phải được đánh dấu là Abstract.",
  },
  {
    id: 976,
    topic: "Inheritance",
    question:
      "Khi một lớp con Concrete (Concrete Subclass) kế thừa Abstract Class, nó phải tuân theo quy tắc nào liên quan đến Abstract Methods?",
    options: [
      "Lớp con chỉ cần ghi đè các phương thức Abstract mà nó muốn thay đổi.",
      "Lớp con phải ghi đè và cung cấp implementation cho TẤT CẢ các Abstract Method được kế thừa.",
      "Lớp con có thể khai báo lại Abstract Methods là 'private'.",
      "Quy tắc này chỉ áp dụng nếu lớp con cũng là Abstract.",
    ],
    answer: 1,
    explanation:
      "Tất cả các Abstract Method phải được implement trong lớp con Concrete đầu tiên.",
  },
  {
    id: 977,
    topic: "Abstract Class",
    question:
      "Abstract Class có thể chứa các phương thức Non-Abstract (có thân hàm) không?",
    options: [
      "Không, một Abstract Class là 100% trừu tượng.",
      "Có, nó có thể chứa cả Abstract và Non-Abstract Methods.",
      "Chỉ khi các phương thức Non-Abstract đó là 'private'.",
      "Chỉ khi các phương thức Non-Abstract đó là 'static'.",
    ],
    answer: 1,
    explanation:
      "Abstract Class có thể chứa cả phương thức abstract và non-abstract.",
  },
  {
    id: 978,
    topic: "Abstract Class",
    question: "Constructor của Abstract Class được gọi khi nào?",
    options: [
      "Nó không bao giờ được gọi.",
      "Chỉ khi nó được khai báo là 'public'.",
      "Khi một đối tượng của lớp con kế thừa Abstract Class đó được khởi tạo.",
      "Khi cố gắng tạo đối tượng Abstract Class (gây ra lỗi biên dịch).",
    ],
    answer: 2,
    explanation:
      "Constructor của lớp trừu tượng được gọi khi tạo một đối tượng của lớp kế thừa.",
  },
  {
    id: 979,
    topic: "Abstract Method",
    question: "Một Abstract Method được dùng khi nào?",
    options: [
      "Khi bạn muốn phương thức đó luôn trả về cùng một giá trị.",
      "Khi bạn không thể nghĩ ra bất kỳ implementation chung nào hữu ích trong Abstract Class, nhưng muốn ép các lớp con phải định nghĩa hành vi riêng.",
      "Khi phương thức đó cần được bảo vệ khỏi bị ghi đè.",
      "Khi phương thức đó cần truy cập các trường 'static'.",
    ],
    answer: 1,
    explanation:
      "Abstract Method được sử dụng khi Abstract Class không thể cung cấp implementation chung có ý nghĩa.",
  },
  {
    id: 980,
    topic: "Inheritance",
    question:
      "Nếu lớp `B` kế thừa Abstract Class `A`, và `A` có Abstract Method `m1()`, nhưng `B` không implement `m1()`, thì `B` phải là loại class nào?",
    options: [
      "Lớp `B` phải là `final`.",
      "Lớp `B` phải được khai báo là `abstract`.",
      "Lớp `B` là một Concrete Class hợp lệ.",
      "Lớp `B` tự động là Interface.",
    ],
    answer: 1,
    explanation:
      "Nếu lớp con không implement tất cả các phương thức trừu tượng, nó phải tự mình là lớp trừu tượng.",
  },
  {
    id: 981,
    topic: "Abstract Class",
    question: "Abstract Class có thể có các fields (trường dữ liệu) không?",
    options: [
      "Không, chỉ Interface mới có fields.",
      "Có, nhưng tất cả fields phải là 'final'.",
      "Có, và chúng có thể là fields bình thường (non-static, non-final).",
      "Có, nhưng tất cả fields phải là 'abstract'.",
    ],
    answer: 2,
    explanation:
      "Abstract Class có thể có fields bình thường (x, y, objectName).",
  },
  {
    id: 982,
    topic: "Abstract Method",
    question: "Cú pháp nào sau đây là KHÔNG hợp lệ cho Abstract Method?",
    options: [
      "`public abstract void run();`",
      "`abstract protected int calculate();`",
      "`public final abstract void execute();`",
      "`abstract double getRate();`",
    ],
    answer: 2,
    explanation:
      "Phương thức Abstract không thể là 'final' vì nó bắt buộc phải được ghi đè (implement).",
  },
  {
    id: 983,
    topic: "Abstract Class",
    question:
      "Mục tiêu Trừu tượng (Abstraction) trong OOP đạt được thông qua cơ chế nào?",
    options: [
      "Chỉ sử dụng lớp Concrete.",
      "Ẩn giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết.",
      "Luôn khai báo các fields là 'public'.",
      "Đảm bảo rằng tất cả các class đều là 'final'.",
    ],
    answer: 1,
    explanation:
      "Trừu tượng là cơ chế ẩn giấu các chi tiết triển khai phức tạp và chỉ hiển thị thông tin cần thiết.",
  },
  {
    id: 984,
    topic: "Comparison",
    question:
      "Sự khác biệt chính giữa Abstract Class và Interface (trước JDK 8) là gì?",
    options: [
      "Interface có thể chứa implementation code; Abstract Class thì không.",
      "Abstract Class có thể có Constructor; Interface thì không.",
      "Interface có thể có fields non-static; Abstract Class thì không.",
      "Abstract Class cho phép đa kế thừa; Interface thì không.",
    ],
    answer: 1,
    explanation:
      "Abstract Class có thể có constructor; Interface (trước JDK 8) không thể có implementation code, và fields của nó ngầm định là public, static, final.",
  },
  {
    id: 985,
    topic: "Abstract Class",
    question:
      "Trong thiết kế, khi nào nên chọn Abstract Class thay vì Interface?",
    options: [
      "Khi bạn muốn cho phép đa kế thừa (implement nhiều loại).",
      "Khi bạn muốn cung cấp một số logic (implementation code) chung cho các lớp con sử dụng.",
      "Khi bạn chỉ muốn định nghĩa các hằng số.",
      "Khi bạn chỉ muốn định nghĩa protocol (Abstract Methods).",
    ],
    answer: 1,
    explanation:
      "Sử dụng Abstract Class khi bạn có sẵn một số implementation code mà các lớp con có thể tái sử dụng.",
  },
  {
    id: 986,
    topic: "Abstract Class",
    question:
      "Một Abstract Class có thể được sử dụng làm kiểu tham chiếu (reference type) cho đối tượng của lớp con không?",
    options: [
      "Không, vì Abstract Class không thể được khởi tạo.",
      "Có, đây là một phần quan trọng để đạt được Đa hình (Polymorphism).",
      "Chỉ khi lớp con là 'final'.",
      "Chỉ khi sử dụng Downcasting.",
    ],
    answer: 1,
    explanation: "Bạn vẫn có thể sử dụng kiểu Abstract đó làm kiểu tham chiếu.",
  },
  {
    id: 987,
    topic: "Abstract Method",
    question:
      "Nếu một Abstract Method không có thân hàm, lớp con Concrete cần làm gì khi implement nó?",
    options: [
      "Tạo một phương thức với cùng chữ ký, nhưng phải thêm từ khóa 'final'.",
      "Tạo một phương thức với cùng chữ ký và cung cấp thân hàm (body).",
      "Gán giá trị 'null' cho phương thức đó.",
      "Khai báo nó là 'static'.",
    ],
    answer: 1,
    explanation:
      "Phải cung cấp thân hàm (body) cho Abstract Method khi implement.",
  },
  {
    id: 988,
    topic: "Inheritance",
    question:
      "Lớp nào trong cây kế thừa được yêu cầu thực thi tất cả các Abstract Method còn lại?",
    options: [
      "Lớp Abstract Class gốc.",
      "Lớp Abstract Class trung gian.",
      "Lớp Concrete Class đầu tiên.",
      "Lớp Interface.",
    ],
    answer: 2,
    explanation:
      "Tất cả các Abstract Method phải được implement trong lớp con Concrete đầu tiên trong cây kế thừa.",
  },
  {
    id: 989,
    topic: "Abstract Class",
    question:
      "Lớp Trừu tượng được tạo ra để ngăn việc khởi tạo các đối tượng 'chung chung' không có ý nghĩa (ví dụ: một đối tượng 'Animal' chung chung). Đây là cơ chế gì?",
    options: [
      "Cơ chế kiểm tra lỗi kiểu ở thời điểm chạy.",
      "Bắt buộc sử dụng Interface.",
      "Ngăn chặn việc khởi tạo class.",
      "Ép kiểu lên (Upcasting).",
    ],
    answer: 2,
    explanation:
      "Bằng cách đánh dấu Abstract, ta ngăn việc tạo ra các instance của class đó.",
  },
  {
    id: 990,
    topic: "Abstract Class",
    question: "Lớp nào sau đây được gọi là 'Concrete Class'?",
    options: [
      "Là lớp không thể được kế thừa.",
      "Là lớp không có Abstract Methods và có thể được khởi tạo.",
      "Là lớp chỉ chứa các hằng số.",
      "Là lớp kế thừa nhiều Interface.",
    ],
    answer: 1,
    explanation: "Concrete Classes là những lớp đủ cụ thể để được khởi tạo.",
  },
  {
    id: 991,
    topic: "Abstract Method",
    question:
      "Nếu một Abstract Class `Vehicle` có Abstract Method `startEngine()`, thì phương thức này nhằm mục đích gì?",
    options: [
      "Cung cấp logic khởi động động cơ chung cho tất cả xe.",
      "Đảm bảo rằng mọi loại xe (Car, Truck) phải định nghĩa cách động cơ của nó khởi động.",
      "Ngăn chặn việc ghi đè phương thức này.",
      "Gây ra lỗi nếu không được gọi bằng `super`.",
    ],
    answer: 1,
    explanation:
      "Abstract Methods định nghĩa protocol, buộc các lớp con phải implement hành vi cụ thể.",
  },
  {
    id: 992,
    topic: "Abstract Class",
    question: "Một Abstract Class có thể được khai báo là 'final' không?",
    options: [
      "Có, Abstract Class luôn là 'final'.",
      "Không, vì 'final' ngăn cản kế thừa, nhưng Abstract Class lại được thiết kế để được kế thừa (extended).",
      "Chỉ khi nó không có constructor.",
      "Chỉ khi nó không có Abstract Methods.",
    ],
    answer: 1,
    explanation:
      "Một Abstract Class được thiết kế để được mở rộng, trong khi 'final' ngăn cản điều đó.",
  },
  {
    id: 993,
    topic: "Abstract Method",
    question: "Abstract Method có thể là 'static' không?",
    options: [
      "Có, nếu nó không có fields non-static.",
      "Không, vì 'static' thuộc về class, trong khi Abstract Method yêu cầu implement dựa trên instance để đạt được đa hình.",
      "Chỉ trong Interface (từ JDK 8).",
      "Có, nếu nó được khai báo là 'private'.",
    ],
    answer: 1,
    explanation:
      "Abstract Method yêu cầu được ghi đè/implement trên instance, trong khi static method thuộc về class và không thể được ghi đè theo cách đó.",
  },
  {
    id: 994,
    topic: "Inheritance",
    question:
      "Khi một lớp con Abstract kế thừa lớp cha Abstract, điều gì xảy ra với Abstract Method của lớp cha?",
    options: [
      "Lớp con Abstract phải implement tất cả Abstract Methods của lớp cha.",
      "Lớp con Abstract không bắt buộc phải implement, có thể 'pass the buck' xuống lớp con Concrete tiếp theo.",
      "Các Abstract Methods đó tự động trở thành Concrete Methods.",
      "Lớp con Abstract bị lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Lớp con Abstract có thể 'pass the buck' (chuyển trách nhiệm implement) xuống lớp con Abstract hoặc Concrete tiếp theo.",
  },
  {
    id: 995,
    topic: "Abstract Class",
    question:
      "Abstract Class có thể có phương thức Non-Abstract được đánh dấu là 'final' không?",
    options: [
      "Không, 'final' không thể xuất hiện trong Abstract Class.",
      "Có, điều này ngăn các lớp con ghi đè phương thức đó, bảo toàn logic chung.",
      "Chỉ khi phương thức đó là 'private'.",
      "Chỉ khi phương thức đó là Abstract.",
    ],
    answer: 1,
    explanation:
      "Abstract Class có thể có phương thức final, ngăn việc ghi đè logic đã được cung cấp (ví dụ: `getArea()` không nên thay đổi cách tính).",
  },
  {
    id: 996,
    topic: "Abstract Class",
    question:
      "Điều gì là một hạn chế lớn của Abstract Class so với Interface liên quan đến kế thừa?",
    options: [
      "Abstract Class không thể kế thừa bất kỳ lớp nào.",
      "Abstract Class không thể kế thừa nhiều hơn một lớp (Java không cho phép đa kế thừa lớp).",
      "Abstract Class không thể có constructor.",
      "Abstract Class không thể sử dụng cho đa hình.",
    ],
    answer: 1,
    explanation:
      "Java không cho phép đa kế thừa giữa các class, giới hạn Abstract Class chỉ có thể kế thừa một lớp khác.",
  },
  {
    id: 997,
    topic: "Abstract Method",
    question:
      "Nếu một phương thức Abstract được khai báo trong Abstract Class, nó được ngầm định (implicitly) là gì?",
    options: [
      "public và static.",
      "public và abstract.",
      "protected và final.",
      "private và static.",
    ],
    answer: 1,
    explanation:
      "Trong Abstract Class, Abstract Methods không ngầm định access modifier, nhưng chúng thường được khai báo public hoặc protected để cho phép lớp con truy cập và ghi đè. (Trong Interface, chúng ngầm định là public và abstract).",
  },
  {
    id: 998,
    topic: "Abstract Class",
    question:
      "Đâu là ưu điểm của việc sử dụng Abstract Class thay vì chỉ sử dụng Interface?",
    options: [
      "Đảm bảo tất cả các phương thức đều là abstract.",
      "Giúp tổ chức mã nguồn tốt hơn do Abstract Class có thể che giấu chi tiết triển khai.",
      "Giảm thiểu sự cần thiết của polymorphism.",
      "Nó cho phép đa kế thừa.",
    ],
    answer: 1,
    explanation:
      "Trừu tượng (Abstraction) là cơ chế ẩn giấu chi tiết triển khai phức tạp.",
  },
  {
    id: 999,
    topic: "Abstract Class",
    question: "Lớp nào sau đây là bắt buộc phải được khai báo là Abstract?",
    options: [
      "Lớp có constructor private.",
      "Lớp có phương thức final.",
      "Lớp có ít nhất một phương thức Abstract.",
      "Lớp không có fields nào.",
    ],
    answer: 2,
    explanation:
      "Nếu một class có even one abstract method, the class must be marked abstract.",
  },
  {
    id: 1000,
    topic: "Inheritance",
    question:
      "Nếu bạn sử dụng một Abstract Class làm kiểu tham chiếu cho một đối tượng lớp con, bạn chỉ có thể gọi các phương thức nào?",
    options: [
      "Chỉ các phương thức được định nghĩa trong Abstract Class (và các Superclass của nó), bất kể đối tượng thực tế là gì.",
      "Tất cả các phương thức của đối tượng lớp con (Subclass).",
      "Chỉ các phương thức là Abstract.",
      "Chỉ các phương thức Non-Abstract.",
    ],
    answer: 0,
    explanation:
      "Trình biên dịch kiểm tra kiểu tham chiếu: chỉ có thể gọi các phương thức trong kiểu tham chiếu đã khai báo.",
  },
  {
    id: 1001,
    topic: "Abstract Method",
    question:
      "Mục đích của Abstract Method là định nghĩa 'protocol' (tập hợp hành vi) cho lớp con, hỗ trợ đắc lực cho nguyên tắc OOP nào?",
    options: [
      "Encapsulation (Đóng gói)",
      "Polymorphism (Đa hình)",
      "Single Responsibility Principle (SRP)",
      "Information Hiding (Ẩn thông tin)",
    ],
    answer: 1,
    explanation:
      "Abstract Class/Method là công cụ chính để khai thác Polymorphism.",
  },
  {
    id: 1002,
    topic: "Abstract Class",
    question:
      "Điều gì là đúng về vị trí của Abstract Class trong kiến trúc mã nguồn?",
    options: [
      "Nó thường nằm ở dưới cùng của cây kế thừa.",
      "Nó thường nằm ở trên cùng hoặc giữa cây kế thừa (là Superclass).",
      "Nó luôn là 'final' class.",
      "Nó luôn implement một Interface.",
    ],
    answer: 1,
    explanation:
      "Abstract Class/Superclass là lớp chung (general class) được các lớp con mở rộng.",
  },
  {
    id: 1003,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có constructor có tham số, lớp con B cần làm gì trong constructor của nó?",
    options: [
      "B phải có constructor mặc định.",
      "B phải gọi constructor của A một cách rõ ràng bằng `super()`, vì Java không tự động chèn lệnh gọi đến constructor có tham số của lớp cha.",
      "B không cần làm gì nếu A là Abstract.",
      "B không được phép gọi constructor của A.",
    ],
    answer: 1,
    explanation:
      "Nếu lớp cha không có default constructor, lớp con phải gọi constructor có tham số của lớp cha bằng `super()`, nếu không sẽ bị lỗi biên dịch.",
  },
  {
    id: 1004,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method được định nghĩa là `protected`, điều gì xảy ra?",
    options: [
      "Chỉ các lớp con trong cùng package mới có thể implement.",
      "Nó không thể được implement.",
      "Nó có thể được implement bởi lớp con, kể cả ở package khác.",
      "Nó tự động trở thành `public`.",
    ],
    answer: 2,
    explanation:
      "Thành viên 'protected' có thể truy cập được bởi subclasses ở khác package.",
  },
  {
    id: 1005,
    topic: "Inheritance",
    question:
      "Trong trường hợp nào, một lớp con được phép không cung cấp implementation cho Abstract Method của lớp cha?",
    options: [
      "Khi lớp con cũng là Abstract Class.",
      "Khi lớp con là 'final'.",
      "Khi lớp con implement một Interface khác.",
      "Không có trường hợp nào được phép.",
    ],
    answer: 0,
    explanation:
      "Lớp con có thể chuyển giao trách nhiệm implement nếu nó cũng là Abstract.",
  },
  {
    id: 1006,
    topic: "Abstract Class",
    question: "Điều gì là hợp lệ trong một Abstract Class?",
    options: [
      "Abstract Method với thân hàm (body).",
      "Constructor 'private'.",
      "Khai báo 'final abstract class'.",
      "Static method Abstract.",
    ],
    answer: 1,
    explanation:
      "Abstract Class có thể có constructor. Private constructor chỉ ngăn instantiation trực tiếp (new), nhưng AC vốn đã ngăn điều đó. (Mặc dù tài liệu không đề cập trực tiếp, nhưng constructor có thể là private).",
  },
  {
    id: 1007,
    topic: "Abstract Method",
    question:
      "Nếu bạn muốn ngăn một phương thức Non-Abstract trong Abstract Class bị ghi đè, bạn sử dụng từ khóa nào?",
    options: ["`private`", "`abstract`", "`final`", "`static`"],
    answer: 2,
    explanation: "Từ khóa 'final' ngăn cản việc ghi đè phương thức.",
  },
  {
    id: 1008,
    topic: "Comparison",
    question: "Về mặt concept, Interface được mô tả là gì?",
    options: [
      "Lớp Concrete không có fields.",
      "Lớp Abstract 100% trừu tượng.",
      "Một dạng của Generic Class.",
      "Một tập hợp các 'final methods'.",
    ],
    answer: 1,
    explanation: "Interface là lớp Abstract 100% trừu tượng.",
  },
  {
    id: 1009,
    topic: "Abstract Class",
    question:
      "Việc sử dụng Abstract Class giúp đạt được mục tiêu trừu tượng hóa bằng cách nào?",
    options: [
      "Buộc các lớp con chia sẻ cùng một mã nguồn hoàn toàn.",
      "Tổ chức code bằng cách đưa các Abstract Methods và Non-Abstract Methods (logic chung) vào cùng một nơi.",
      "Chỉ cho phép sử dụng các biến primitive.",
      "Thay thế hoàn toàn cho Interface.",
    ],
    answer: 1,
    explanation:
      "Abstract Class cho phép đặt code chung cần chia sẻ vào đó, giúp trừu tượng hóa.",
  },
  {
    id: 1010,
    topic: "Inheritance",
    question:
      "Điều gì xảy ra nếu một lớp con Concrete cố gắng implement một Abstract Method nhưng thay đổi kiểu trả về (return type) không tương thích?",
    options: [
      "Lỗi Biên dịch.",
      "Lỗi Runtime (ClassCastException).",
      "Phương thức này trở thành một phương thức Overloaded.",
      "Lớp con tự động trở thành Abstract.",
    ],
    answer: 0,
    explanation:
      "Quy tắc ghi đè (bao gồm cả implementation Abstract Method) yêu cầu kiểu trả về phải tương thích. Thay đổi kiểu trả về không tương thích sẽ gây ra lỗi biên dịch.",
  },
  {
    id: 1011,
    topic: "Abstract Method",
    question:
      "Khi implement một Abstract Method, lớp con Concrete đang thực hiện hành động nào?",
    options: [
      "Overloading (Nạp chồng phương thức).",
      "Upcasting (Ép kiểu lên).",
      "Overriding (Ghi đè phương thức).",
      "Calling (Gọi phương thức).",
    ],
    answer: 2,
    explanation:
      "Implementing Abstract Method được coi là Overriding phương thức đó (cung cấp thân hàm).",
  },
  {
    id: 1012,
    topic: "Abstract Class",
    question: "Đâu là ví dụ về Abstract Class được tìm thấy trong Java API?",
    options: ["String", "Integer", "Component (trong GUI library)", "Math"],
    answer: 2,
    explanation:
      "Nhiều lớp trong thư viện GUI như Component là Abstract Class, chỉ cho phép khởi tạo các lớp con cụ thể (như JButton).",
  },
  {
    id: 1013,
    topic: "Abstract Class",
    question:
      "Trong Abstract Class, các phương thức non-abstract được khai báo như thế nào?",
    options: [
      "Phải có từ khóa 'abstract'.",
      "Không cần khai báo gì, chúng là phương thức bình thường.",
      "Phải là 'public' và 'static'.",
      "Phải có từ khóa 'virtual'.",
    ],
    answer: 1,
    explanation:
      "Các phương thức non-abstract (concrete methods) trong Abstract Class được định nghĩa như các phương thức thông thường, với thân hàm.",
  },
  {
    id: 1014,
    topic: "Abstract Method",
    question: "Điều gì là HỢP LỆ trong định nghĩa Abstract Method?",
    options: [
      "Sử dụng từ khóa `final`.",
      "Sử dụng từ khóa `static`.",
      "Sử dụng access modifier `private`.",
      "Sử dụng access modifier `protected`.",
    ],
    answer: 3,
    explanation:
      "Abstract Methods có thể là `protected` để các lớp con truy cập và implement.",
  },
  {
    id: 1015,
    topic: "Inheritance",
    question:
      "Khi lớp con Concrete kế thừa Abstract Class và implement Abstract Method, lớp con có thể gọi implementation của lớp cha bằng từ khóa `super` không?",
    options: [
      "Có, luôn luôn.",
      "Không thể, vì Abstract Method của lớp cha không có thân hàm để gọi.",
      "Chỉ khi Abstract Method đó là 'public'.",
      "Chỉ khi lớp con là Abstract.",
    ],
    answer: 1,
    explanation:
      "Không thể gọi `super.method()` nếu phương thức đó là Abstract vì nó không có thân hàm (dù `super` được dùng cho các phương thức Non-Abstract được override).",
  },
  {
    id: 1016,
    topic: "Abstract Class",
    question:
      "Nếu một lớp chỉ muốn định nghĩa một tập hợp các Abstract Methods (protocol) mà không có bất kỳ implementation code nào, thì nên sử dụng gì?",
    options: [
      "Concrete Class",
      "Abstract Class 100% trừu tượng",
      "Utility Class",
      "Wrapper Class",
    ],
    answer: 1,
    explanation: "Interface là lớp Abstract 100% trừu tượng.",
  },
  {
    id: 1017,
    topic: "Abstract Class",
    question:
      "Khi một lớp con Concrete kế thừa Abstract Class, nó có thể sử dụng từ khóa `super` để làm gì?",
    options: [
      "Khởi tạo Abstract Class Constructor.",
      "Ghi đè Abstract Methods.",
      "Định nghĩa Abstract Methods mới.",
      "Ngăn chặn việc kế thừa.",
    ],
    answer: 0,
    explanation: "Từ khóa `super` được dùng để gọi constructor của lớp cha.",
  },
  {
    id: 1018,
    topic: "Abstract Class",
    question:
      "Mối quan hệ nào mô tả mối quan hệ giữa Abstract Class và lớp con của nó?",
    options: [
      "HAS-A (có một)",
      "IS-A (là một)",
      "USES-A (sử dụng một)",
      "OWNED-BY (thuộc sở hữu của)",
    ],
    answer: 1,
    explanation: "Lớp con mở rộng lớp cha, duy trì mối quan hệ IS-A.",
  },
  {
    id: 1019,
    topic: "Abstract Class",
    question:
      "Điều gì sẽ xảy ra nếu một lớp Abstract không có Abstract Methods?",
    options: [
      "Nó sẽ gây ra lỗi biên dịch.",
      "Nó là hợp lệ, nhưng nó tồn tại chỉ để ngăn việc khởi tạo lớp đó.",
      "Nó tự động trở thành Interface.",
      "Nó phải được khai báo là 'private'.",
    ],
    answer: 1,
    explanation:
      "Một Abstract Class có thể không có Abstract Methods, chỉ cần ngăn chặn khởi tạo.",
  },
  {
    id: 1020,
    topic: "Abstract Class",
    question: "Lớp nào sau đây không thể là Abstract?",
    options: [
      "Lớp không có constructor.",
      "Lớp có Abstract Method.",
      "Lớp được khai báo là 'final'.",
      "Lớp chỉ có fields 'private'.",
    ],
    answer: 2,
    explanation:
      "Không thể là Abstract và 'final' cùng lúc vì chúng mâu thuẫn về mục đích.",
  },
  {
    id: 1021,
    topic: "Inheritance",
    question:
      "Nếu Abstract Class `A` có Abstract Method `m()`, và Abstract Class `B` kế thừa `A` và cũng có Abstract Method `n()`, thì lớp Concrete `C` kế thừa `B` phải làm gì?",
    options: [
      "Implement `m()` và `n()`.",
      "Chỉ implement `n()`.",
      "Chỉ implement `m()`.",
      "Không cần implement gì nếu B không gọi super.",
    ],
    answer: 0,
    explanation:
      "Lớp Concrete đầu tiên phải implement tất cả Abstract Methods được kế thừa (từ A và B).",
  },
  {
    id: 1022,
    topic: "Abstract Class",
    question: "Mục tiêu của Abstract Class là gì, ngoài việc ngăn khởi tạo?",
    options: [
      "Tăng cường đóng gói bằng cách giới hạn truy cập.",
      "Cho phép các lớp liên quan chia sẻ một số đoạn code (logic chung) và định nghĩa các hành vi cần thiết (Abstract Methods).",
      "Chỉ được dùng cho các phép toán tĩnh.",
      "Thay thế hoàn toàn cho Interface.",
    ],
    answer: 1,
    explanation: "Abstract Class cho phép chia sẻ code (logic chung).",
  },
  {
    id: 1023,
    topic: "Abstract Method",
    question:
      "Nếu lớp con `Rectangle` kế thừa Abstract Class `Shape` và implement `area()`, implementation này tương ứng với hành động gì?",
    options: [
      "Tính diện tích chung cho tất cả các hình học.",
      "Tính diện tích cụ thể chỉ cho hình chữ nhật (Rectangle).",
      "Ngăn việc tính diện tích.",
      "Ghi đè phương thức tĩnh.",
    ],
    answer: 1,
    explanation: "Lớp con phải cung cấp logic cụ thể cho Abstract Method.",
  },
  {
    id: 1024,
    topic: "Abstract Class",
    question: "Lớp Abstract có thể implement một Interface không?",
    options: [
      "Không bao giờ.",
      "Có, nhưng nó không bắt buộc phải implement tất cả các phương thức của Interface.",
      "Có, nhưng nó phải khai báo tất cả các phương thức Interface là Abstract.",
      "Có, và nó phải implement tất cả các phương thức Interface.",
    ],
    answer: 1,
    explanation:
      "Nếu lớp Abstract implement Interface, nó có thể chuyển giao trách nhiệm implement phương thức Interface xuống lớp con Concrete tiếp theo.",
  },
  {
    id: 1025,
    topic: "Abstract Method",
    question:
      "Khi khai báo Abstract Method, access modifier nào thường được sử dụng để cho phép truy cập rộng rãi cho các lớp con (kể cả ở package khác)?",
    options: [
      "private",
      "default (package-private)",
      "public hoặc protected",
      "static",
    ],
    answer: 2,
    explanation:
      "Public hoặc protected được sử dụng để định nghĩa protocol cho các lớp con.",
  },
  {
    id: 1026,
    topic: "Inheritance",
    question:
      "Khi một lớp con Concrete implement Abstract Method, điều gì là bắt buộc?",
    options: [
      "Chữ ký phương thức (tên và tham số) phải giống hệt phương thức Abstract.",
      "Nó phải trả về kiểu `Object`.",
      "Nó phải gọi `super()`.",
      "Nó phải là `final`.",
    ],
    answer: 0,
    explanation:
      "Chữ ký phương thức phải giống nhau (cùng tên, cùng tham số) để ghi đè/implement.",
  },
  {
    id: 1027,
    topic: "Abstract Class",
    question:
      "Một biến tham chiếu kiểu Abstract Class trỏ đến một đối tượng Concrete Subclass cho phép điều gì?",
    options: [
      "Truy cập các Abstract Method chưa được implement.",
      "Ép kiểu xuống (Downcasting) tự động.",
      "Thực hiện đa hình tại thời điểm chạy (runtime polymorphism).",
      "Chỉ gọi constructor của Abstract Class.",
    ],
    answer: 2,
    explanation:
      "Polymorphism: Reference kiểu Abstract Class trỏ đến đối tượng lớp con.",
  },
  {
    id: 1028,
    topic: "Abstract Method",
    question: "Tại sao Abstract Method không thể là `private`?",
    options: [
      "Vì phương thức `private` không thể bị ghi đè/kế thừa, mâu thuẫn với mục đích của Abstract Method là bắt buộc lớp con phải implement.",
      "Vì `private` chỉ dành cho fields.",
      "Vì Abstract Method luôn phải là `static`.",
      "Vì Abstract Class chỉ có thể có `public` members.",
    ],
    answer: 0,
    explanation:
      "Phương thức `private` không được kế thừa/ghi đè/implement, mâu thuẫn với quy tắc của Abstract Method.",
  },
  {
    id: 1029,
    topic: "Abstract Class",
    question:
      "Điều gì là mục đích của việc đặt các phương thức Non-Abstract trong Abstract Class?",
    options: [
      "Buộc các lớp con không được ghi đè chúng.",
      "Cung cấp logic chung, có thể tái sử dụng cho tất cả các lớp con.",
      "Giới hạn quyền truy cập vào các fields private.",
      "Kích hoạt Garbage Collector.",
    ],
    answer: 1,
    explanation: "Cung cấp logic chung mà các lớp con có thể kế thừa.",
  },
  {
    id: 1030,
    topic: "Inheritance",
    question:
      "Trong ví dụ `Shape` và `Rectangle`, nếu `Rectangle` là Concrete, nó phải định nghĩa Abstract Method `area()` và `draw()` từ `Shape`. Việc này là để:",
    options: [
      "Đảm bảo rằng `Rectangle` là một kiểu dữ liệu nguyên thủy.",
      "Tuân thủ giao kèo (contract) của Abstract Class và có thể được khởi tạo.",
      "Ngăn chặn Upcasting.",
      "Cho phép Downcasting tự động.",
    ],
    answer: 1,
    explanation:
      "Lớp Concrete phải implement Abstract Methods để tuân thủ contract.",
  },
  {
    id: 1031,
    topic: "Abstract Class",
    question: "Abstract Class có thể có phương thức `static` không?",
    options: [
      "Không, vì `static` không phù hợp với trừu tượng.",
      "Có, vì phương thức `static` thuộc về class, không phải instance, và không liên quan đến khả năng khởi tạo.",
      "Chỉ khi phương thức đó là `private`.",
      "Chỉ khi phương thức đó gọi một Abstract Method.",
    ],
    answer: 1,
    explanation:
      "Static methods thuộc về class, không bị ảnh hưởng bởi Abstract/Concrete.",
  },
  {
    id: 1032,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `A` không có constructor mặc định (default constructor), lớp con Concrete `B` bắt buộc phải:",
    options: [
      "Khai báo `B` là Abstract.",
      "Đảm bảo `B` cũng không có constructor.",
      "Định nghĩa constructor cho `B` và gọi constructor phù hợp của `A` bằng `super()`.",
      "Java tự động xử lý mà không cần `super()`.",
    ],
    answer: 2,
    explanation:
      "Nếu lớp cha không có default constructor, lớp con phải gọi constructor khác, nếu không sẽ bị lỗi biên dịch.",
  },
  {
    id: 1033,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Class A có Abstract Method `m()`, và Abstract Class B kế thừa A, B có thể định nghĩa lại `m()` (gọi là Partially Implement) không?",
    options: [
      "Có, B có thể cung cấp implementation Concrete cho `m()` hoặc giữ nó là Abstract.",
      "Không, nếu B không implement hoàn toàn, nó phải là Abstract.",
      "Có, nếu B sử dụng từ khóa `final`.",
      "Không thể, vì B đã là Abstract.",
    ],
    answer: 0,
    explanation:
      "Abstract Class có thể cung cấp implementation cho một số Abstract Method được kế thừa.",
  },
  {
    id: 1034,
    topic: "Comparison",
    question: "Điểm chung nào giữa Abstract Class và Interface (trước JDK 8)?",
    options: [
      "Cả hai đều không thể được khởi tạo (instantiated).",
      "Cả hai đều có thể có fields Non-Final.",
      "Cả hai đều cho phép đa kế thừa.",
      "Cả hai đều phải có ít nhất một Abstract Method.",
    ],
    answer: 0,
    explanation: "Cả hai đều không thể được tạo instance.",
  },
  {
    id: 1035,
    topic: "Abstract Class",
    question: "Một Abstract Class được thiết kế để giải quyết vấn đề gì?",
    options: [
      "Thay thế hoàn toàn cho Interface.",
      "Cung cấp giải pháp cho vấn đề 'Deadly Diamond of Death'.",
      "Giúp tổ chức mã nguồn bằng cách tập hợp logic chung và giao thức (protocol) ở một cấp độ cao hơn các lớp Concrete.",
      "Hạn chế việc sử dụng fields 'public'.",
    ],
    answer: 2,
    explanation:
      "Abstract Class giúp định nghĩa khuôn mẫu và chia sẻ code chung.",
  },
  {
    id: 1036,
    topic: "Abstract Class",
    question:
      "Điều gì là một hạn chế nghiêm trọng khi sử dụng Abstract Class thay vì Interface?",
    options: [
      "Không thể có constructor.",
      "Không thể có fields.",
      "Không thể implement nhiều Abstract Class.",
      "Không thể kế thừa nhiều Abstract Class.",
    ],
    answer: 3,
    explanation:
      "Abstract Class bị giới hạn chỉ có thể kế thừa một lớp cha, do Java không hỗ trợ đa kế thừa lớp.",
  },
  {
    id: 1037,
    topic: "Inheritance",
    question:
      "Nếu lớp `Dog` kế thừa Abstract Class `Animal` và là lớp Concrete, điều gì là KHÔNG bắt buộc?",
    options: [
      "Cung cấp implementation cho tất cả Abstract Methods của `Animal`.",
      "Sử dụng từ khóa `abstract`.",
      "Khai báo `Dog` là `public`.",
      "Định nghĩa constructor cho `Dog`.",
    ],
    answer: 1,
    explanation: "Lớp Concrete không thể là Abstract.",
  },
  {
    id: 1038,
    topic: "Abstract Class",
    question:
      "Một Abstract Class có thể được sử dụng làm tham số trong một phương thức (Method Parameter) không?",
    options: [
      "Không, vì nó không thể được khởi tạo.",
      "Có, nếu Abstract Class đó không có Abstract Methods.",
      "Có, đây là cách phổ biến để sử dụng Đa hình.",
      "Chỉ khi sử dụng Wildcards.",
    ],
    answer: 2,
    explanation:
      "Abstract Type có thể được sử dụng như reference type, bao gồm cả method arguments.",
  },
  {
    id: 1039,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method `calculate()` trong Abstract Class không có tham số, lớp con khi implement có thể thêm tham số không?",
    options: [
      "Có, nếu đó là Overloading.",
      "Không, vì implementation phải giữ nguyên chữ ký (signature).",
      "Có, nếu lớp con là Abstract.",
      "Chỉ khi sử dụng `super()`.",
    ],
    answer: 1,
    explanation:
      "Chữ ký (tên, tham số) phải được giữ nguyên khi ghi đè/implement.",
  },
  {
    id: 1040,
    topic: "Abstract Class",
    question: "Trong Abstract Class, từ khóa `this` được dùng để làm gì?",
    options: [
      "Để ngăn việc khởi tạo Abstract Class.",
      "Để tham chiếu đến Abstract Method.",
      "Để tham chiếu đến đối tượng hiện tại (là instance của lớp con) bên trong constructor hoặc phương thức.",
      "Để chuyển giao implementation.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `this` tham chiếu đến đối tượng hiện tại, ngay cả khi nó là instance của lớp con kế thừa Abstract Class.",
  },
  {
    id: 1041,
    topic: "Abstract Class",
    question: "Điều gì là đúng về Abstract Class so với Class thông thường?",
    options: [
      "Abstract Class luôn nhanh hơn Class thông thường.",
      "Abstract Class không thể có fields, Class thông thường thì có.",
      "Abstract Class không thể được khởi tạo, Class thông thường thì có.",
      "Abstract Class không thể kế thừa Class khác.",
    ],
    answer: 2,
    explanation: "Sự khác biệt cốt lõi là khả năng khởi tạo.",
  },
  {
    id: 1042,
    topic: "Abstract Class",
    question: "Khi Abstract Class có Constructor, nó được sử dụng để làm gì?",
    options: [
      "Thực thi logic trừu tượng.",
      "Khởi tạo các trường (fields) chung của Abstract Class khi lớp con được tạo.",
      "Bắt buộc tất cả các lớp con phải là Abstract.",
      "Ngăn chặn việc gọi `super()`.",
    ],
    answer: 1,
    explanation:
      "Constructor của Abstract Class được gọi để khởi tạo các trường đã định nghĩa.",
  },
  {
    id: 1043,
    topic: "Abstract Method",
    question: "Tại sao Abstract Method không có thân hàm?",
    options: [
      "Vì nó được thiết kế để chỉ định protocol, không phải implementation.",
      "Vì nó luôn trả về kiểu `void`.",
      "Vì nó không thể có fields.",
      "Vì Abstract Class là 100% trừu tượng.",
    ],
    answer: 0,
    explanation: "Abstract Method không có thân hàm (body).",
  },
  {
    id: 1044,
    topic: "Inheritance",
    question:
      "Nếu lớp `Animal` là Abstract Class, và `Dog` kế thừa `Animal`, việc khai báo `Animal myDog = new Dog();` là ví dụ cho cơ chế nào?",
    options: [
      "Downcasting.",
      "Overloading.",
      "Upcasting (Ép kiểu lên) và Đa hình (Polymorphism).",
      "Khởi tạo Abstract Class.",
    ],
    answer: 2,
    explanation: "Đây là Upcasting (tự động) để sử dụng polymorphism.",
  },
  {
    id: 1045,
    topic: "Abstract Class",
    question:
      "Điều gì là mục đích của việc sử dụng các Abstract Class trong Factory Method Pattern?",
    options: [
      "Để đảm bảo rằng Factory chỉ tạo một loại đối tượng.",
      "Để cung cấp một interface trừu tượng cho việc tạo đối tượng, nhưng giao trách nhiệm xác định lớp cụ thể để khởi tạo cho các lớp con.",
      "Để ngăn chặn các lớp con ghi đè phương thức factory.",
      "Để giới hạn số lượng đối tượng được tạo.",
    ],
    answer: 1,
    explanation:
      "Factory Method Pattern sử dụng Abstract Class để định nghĩa interface tạo đối tượng, nhưng để lớp con quyết định loại nào được khởi tạo.",
  },
  {
    id: 1046,
    topic: "Abstract Method",
    question:
      "Khi lớp con Concrete implement Abstract Method, điều gì là KHÔNG được phép?",
    options: [
      "Thay đổi access modifier từ `protected` thành `public`.",
      "Giữ nguyên tên phương thức.",
      "Thay đổi kiểu tham số (parameter types).",
      "Cung cấp thân hàm (body) cho phương thức.",
    ],
    answer: 2,
    explanation:
      "Không được thay đổi tham số (arguments) khi ghi đè/implement.",
  },
  {
    id: 1047,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `X` có phương thức Non-Abstract `m()`, lớp con `Y` (Concrete) có thể gọi `m()` bằng cách nào nếu không ghi đè nó?",
    options: [
      "Không thể gọi.",
      "Chỉ gọi bằng `this.m()`.",
      "Gọi trực tiếp `m()` như một phương thức được kế thừa.",
      "Chỉ gọi bằng `super.m()`.",
    ],
    answer: 2,
    explanation: "Phương thức Non-Abstract được tự động bao gồm trong lớp con.",
  },
  {
    id: 1048,
    topic: "Comparison",
    question:
      "Trong khi Abstract Class sử dụng từ khóa `extends` cho kế thừa, Interface sử dụng từ khóa nào?",
    options: ["`implements`", "`inherits`", "`abstracts`", "`uses`"],
    answer: 0,
    explanation: "Interface được 'implement' bởi một class.",
  },
  {
    id: 1049,
    topic: "Abstract Class",
    question:
      "Điều gì xảy ra nếu bạn cố gắng gọi một phương thức trên một tham chiếu Abstract Class, nhưng đối tượng thực tế không implement phương thức đó (nếu đó là Abstract Method)?",
    options: [
      "Lỗi Biên dịch (vì lớp con Concrete đầu tiên phải implement) .",
      "Lỗi Runtime (ClassCastException).",
      "Java tự động bỏ qua cuộc gọi phương thức.",
      "Đối tượng tự động bị Garbage Collector thu hồi.",
    ],
    answer: 0,
    explanation:
      "Trình biên dịch đảm bảo rằng tất cả các Abstract Methods được khai báo đều đã được implement bởi lớp Concrete đầu tiên, nếu không sẽ bị lỗi.",
  },
  {
    id: 1050,
    topic: "Abstract Class",
    question:
      "Việc sử dụng Abstract Class hoặc Interface để định nghĩa protocol (giao thức) chung giúp ích gì trong việc mở rộng code?",
    options: [
      "Cho phép mở rộng chương trình mà không cần chạm vào code đã được kiểm tra (Open/Closed Principle).",
      "Giới hạn số lượng đối tượng được tạo ra.",
      "Yêu cầu phải sử dụng `final class`.",
      "Đảm bảo các fields luôn là `private`.",
    ],
    answer: 0,
    explanation:
      "OOP cho phép mở rộng chương trình mà không cần thay đổi code hiện có.",
  },
  {
    id: 1051,
    topic: "Abstract Method",
    question:
      "Nếu một Abstract Method không có access modifier rõ ràng, access modifier mặc định của nó là gì (trong Abstract Class)?",
    options: ["private", "public", "protected", "default (package-private)"],
    answer: 3,
    explanation:
      "Nếu không có modifier nào được chỉ định, access modifier mặc định là default.",
  },
  {
    id: 1052,
    topic: "Abstract Class",
    question: "Một Abstract Class có thể implement nhiều Interface không?",
    options: [
      "Không, Abstract Class chỉ có thể implement một Interface.",
      "Có, Interface cho phép đa implement.",
      "Có, nếu Abstract Class đó không có constructor.",
      "Chỉ Interface không có Abstract Methods.",
    ],
    answer: 1,
    explanation:
      "Class (kể cả Abstract Class) có thể implement nhiều Interface.",
  },
  {
    id: 1053,
    topic: "Comparison",
    question:
      "Lớp nào sau đây là 'Partial Blueprint' (Bản thiết kế một phần), vì nó có thể chứa các chi tiết đã hoàn thiện (logic) và cả các chi tiết chưa hoàn thiện (Abstract Methods)?",
    options: ["Interface", "Concrete Class", "Abstract Class", "Utility Class"],
    answer: 2,
    explanation:
      "Abstract Class có thể chứa cả implementation code (hoàn thiện) và Abstract Methods (chưa hoàn thiện).",
  },
  {
    id: 1054,
    topic: "Abstract Class",
    question:
      "Khi nào việc cố gắng tạo đối tượng từ Abstract Class bị lỗi biên dịch?",
    options: [
      "Khi gọi Abstract Class Constructor bằng `new`.",
      "Khi lớp con Concrete không implement Abstract Methods.",
      "Khi lớp con gọi `super()` quá nhiều lần.",
      "Khi sử dụng Downcasting.",
    ],
    answer: 0,
    explanation: "Không thể gọi constructor của Abstract Class bằng `new`.",
  },
  {
    id: 1055,
    topic: "Inheritance",
    question:
      "Việc Abstract Class ẩn giấu chi tiết phức tạp, chỉ show chức năng cần thiết là ví dụ cho cơ chế OOP nào?",
    options: [
      "Encapsulation.",
      "Polymorphism.",
      "Abstraction.",
      "Inheritance.",
    ],
    answer: 2,
    explanation:
      "Ẩn chi tiết implementation và chỉ show chức năng là Abstraction.",
  },
  {
    id: 1056,
    topic: "Abstract Method",
    question:
      "Abstract Method trong Abstract Class thường được khai báo là `public` hoặc `protected` để làm gì?",
    options: [
      "Để ngăn việc lớp con implement.",
      "Để đảm bảo rằng lớp con có thể truy cập phương thức để ghi đè (implement).",
      "Để giới hạn việc sử dụng chỉ trong class đó.",
      "Để kích hoạt `super()`.",
    ],
    answer: 1,
    explanation: "Cần truy cập để implement/ghi đè.",
  },
  {
    id: 1057,
    topic: "Abstract Class",
    question:
      "Lớp nào thường được coi là Abstract vì việc tạo ra một instance của nó không có ý nghĩa cụ thể (ví dụ: `Food` chung chung)?",
    options: [
      "Lớp Wrapper.",
      "Lớp cần phải là khuôn mẫu cho nhiều lớp con cụ thể.",
      "Lớp Singleton.",
      "Lớp Utility.",
    ],
    answer: 1,
    explanation:
      "Abstract Class được dùng khi đối tượng chung chung không có ý nghĩa cụ thể.",
  },
  {
    id: 1058,
    topic: "Abstract Class",
    question:
      "Nếu một Abstract Class không có constructor mặc định, và lớp con cũng không gọi constructor có tham số bằng `super()`, thì lỗi nào xảy ra?",
    options: [
      "Lỗi Biên dịch.",
      "Lỗi Runtime.",
      "Ngoại lệ NullPointerException.",
      "Ngoại lệ ClassCastException.",
    ],
    answer: 0,
    explanation:
      "Trình biên dịch tự động chèn lệnh gọi `super()` đến constructor mặc định. Nếu không có constructor mặc định, lỗi biên dịch.",
  },
  {
    id: 1059,
    topic: "Inheritance",
    question:
      "Sự khác biệt giữa việc ghi đè phương thức Non-Abstract và implement Abstract Method là gì?",
    options: [
      "Cả hai đều giống nhau.",
      "Ghi đè thay đổi logic hiện có; implement cung cấp logic lần đầu tiên cho phương thức chưa có thân hàm.",
      "Ghi đè cần từ khóa `abstract`; implement thì không.",
      "Ghi đè chỉ áp dụng cho fields.",
    ],
    answer: 1,
    explanation:
      "Implement cung cấp thân hàm (body) lần đầu tiên cho Abstract Method.",
  },
  {
    id: 1060,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `Shape` có phương thức `moveTo(x, y)` Non-Abstract, phương thức này có thể được gọi từ một tham chiếu `Shape` trỏ đến đối tượng `Circle` không?",
    options: [
      "Không, chỉ Abstract Methods mới được gọi.",
      "Có, nếu phương thức đó là `public`.",
      "Chỉ khi phương thức đó là `private`.",
      "Chỉ khi `Circle` không ghi đè `moveTo()`.",
    ],
    answer: 1,
    explanation:
      "Phương thức Non-Abstract (concrete) có thể được gọi nếu nó được định nghĩa trong Abstract Class.",
  },
  {
    id: 1061,
    topic: "Comparison",
    question: "Điều gì là ĐÚNG về fields trong Abstract Class và Interface?",
    options: [
      "Fields trong Abstract Class luôn là `public static final`, còn Interface thì không.",
      "Fields trong Interface luôn là `public static final`, còn Abstract Class có thể có fields thường.",
      "Cả hai đều không thể có fields.",
      "Cả hai đều chỉ có thể có fields 'private'.",
    ],
    answer: 1,
    explanation:
      "Fields Interface là implicit public static final; Abstract Class có fields bình thường.",
  },
  {
    id: 1062,
    topic: "Abstract Class",
    question: "Một Abstract Class có thể implement nhiều Interface không?",
    options: [
      "Không, chỉ một Interface.",
      "Có.",
      "Chỉ khi tất cả các Abstract Methods đều được implement.",
      "Chỉ khi không có constructor.",
    ],
    answer: 1,
    explanation: "Lớp có thể implement nhiều Interface.",
  },
  {
    id: 1063,
    topic: "Abstract Method",
    question: "Tại sao Abstract Method KHÔNG thể có thân hàm?",
    options: [
      "Vì nó chỉ là tuyên bố về hành vi cần có.",
      "Vì nó là `static`.",
      "Vì nó là `final`.",
      "Vì nó là `private`.",
    ],
    answer: 0,
    explanation: "Abstract Method không có thân hàm.",
  },
  {
    id: 1064,
    topic: "Inheritance",
    question:
      "Nếu Abstract Class `A` có Non-Abstract Method `log()` gọi một Abstract Method `process()`, lớp con Concrete `B` gọi `log()`, thì điều gì xảy ra?",
    options: [
      "Lỗi Biên dịch, vì `log()` gọi Abstract Method.",
      "Lớp `B` sẽ thực thi logic của `log()`, và `process()` sẽ là phiên bản được `B` implement.",
      "Chương trình bị crash.",
      "Java tự động bỏ qua `process()`.",
    ],
    answer: 1,
    explanation:
      "Đây là thiết kế phổ biến: Abstract Class cung cấp logic chung (`log`), gọi Abstract Method (`process`) để lớp con cung cấp chi tiết cụ thể. (Nguyên tắc Template Method).",
  },
  {
    id: 1065,
    topic: "Abstract Class",
    question:
      "Điều gì thể hiện sự linh hoạt của Abstract Class so với Interface (trước JDK 8)?",
    options: [
      "Nó có thể khai báo Abstract Methods.",
      "Nó có thể khai báo Fields.",
      "Nó có thể cung cấp implementation cho một số phương thức.",
      "Nó cho phép đa kế thừa.",
    ],
    answer: 2,
    explanation:
      "Abstract Class có thể chứa code thực thi, trong khi Interface (trước JDK 8) không thể.",
  },
  {
    id: 1066,
    topic: "Abstract Class",
    question:
      "Sự khác biệt về cách đặt tên giữa Abstract Class và Interface là gì?",
    options: [
      "Cả hai đều dùng CamelCase (bắt đầu bằng chữ hoa).",
      "Abstract Class dùng chữ hoa, Interface dùng chữ thường.",
      "Abstract Class dùng PascalCase, Interface dùng tiền tố 'I'.",
      "Abstract Class dùng snake_case.",
    ],
    answer: 0,
    explanation:
      "Cả Class và Interface đều tuân theo quy ước CamelCase (bắt đầu bằng chữ hoa).",
  },
  {
    id: 1067,
    topic: "Abstract Method",
    question:
      "Một Abstract Method trong Abstract Class có thể có thân hàm nếu thân hàm đó chỉ là một khối rỗng (`{}`) không?",
    options: [
      "Có, nếu nó được khai báo là `protected`.",
      "Không, nếu có thân hàm, nó không còn là Abstract Method nữa và sẽ gây lỗi biên dịch.",
      "Chỉ khi nó là `final`.",
      "Có, đó là cách implement mặc định.",
    ],
    answer: 1,
    explanation: "Abstract Method không có thân hàm.",
  },
  {
    id: 1068,
    topic: "Abstract Class",
    question:
      "Nếu một lớp con Concrete kế thừa Abstract Class A, lớp con có được phép thay đổi access modifier của Abstract Method từ `protected` trong A thành `public` trong lớp con không?",
    options: [
      "Không, access modifier phải giữ nguyên hoặc trở nên ít hạn chế hơn.",
      "Có, luôn luôn.",
      "Chỉ khi sử dụng `super()`.",
      "Không, access modifier phải giữ nguyên hoặc trở nên hạn chế hơn.",
    ],
    answer: 0,
    explanation:
      "Khi ghi đè, access modifier phải giữ nguyên hoặc nới lỏng hơn (ít hạn chế hơn).",
  },
  {
    id: 1069,
    topic: "Abstract Class",
    question:
      "Lợi ích của việc sử dụng Abstract Class là chia sẻ code, điều này giúp tránh vấn đề nào?",
    options: [
      "Overloading methods.",
      "Lỗi cú pháp (Syntax errors).",
      "Lỗi logic (Bugs).",
      "Code trùng lặp (Duplicate code).",
    ],
    answer: 3,
    explanation:
      "Inheritance giúp loại bỏ code trùng lặp bằng cách trừu tượng hóa logic chung.",
  },
  {
    id: 1070,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có constructor `A(int x)`, và lớp con `B` không gọi `super(x)`, thì lỗi biên dịch sẽ xảy ra vì:",
    options: [
      "Không tìm thấy constructor mặc định của A.",
      "Không tìm thấy constructor có tham số của B.",
      "A không thể có constructor.",
      "B phải là Abstract.",
    ],
    answer: 0,
    explanation:
      "Nếu lớp cha chỉ có constructor có tham số, và lớp con không gọi `super()` rõ ràng, trình biên dịch sẽ cố gắng gọi default constructor (không tồn tại).",
  },
  {
    id: 1071,
    topic: "Abstract Method",
    question: "Điều gì là sai khi khai báo Abstract Method?",
    options: [
      "Khai báo tham số.",
      "Khai báo kiểu trả về (return type).",
      "Khai báo với từ khóa `abstract`.",
      "Khai báo `private abstract void m();` .",
    ],
    answer: 3,
    explanation: "Abstract Method không thể là `private` .",
  },
  {
    id: 1072,
    topic: "Abstract Class",
    question:
      "Abstract Class có thể kế thừa (extends) một Concrete Class không?",
    options: [
      "Không, Abstract Class chỉ có thể kế thừa Abstract Class.",
      "Có, nếu Concrete Class đó không phải là 'final'.",
      "Chỉ khi Concrete Class không có constructor.",
      "Chỉ khi Abstract Class đó không có Abstract Methods.",
    ],
    answer: 1,
    explanation:
      "Abstract Class vẫn là một class bình thường về mặt kế thừa (trừ việc không thể khởi tạo) và có thể kế thừa bất kỳ class nào không phải là 'final'.",
  },
  {
    id: 1073,
    topic: "Abstract Class",
    question: "Điều gì là không thể đối với một Abstract Class?",
    options: [
      "Có mảng fields.",
      "Có phương thức non-abstract.",
      "Khai báo biến instance.",
      "Tạo một thể hiện trực tiếp (direct instance).",
    ],
    answer: 3,
    explanation: "Không thể tạo đối tượng trực tiếp.",
  },
  {
    id: 1074,
    topic: "Comparison",
    question: "Abstract Class và Interface khác nhau chủ yếu ở khả năng nào?",
    options: [
      "Khả năng định nghĩa fields.",
      "Khả năng định nghĩa Constructor và cung cấp implementation code.",
      "Khả năng được kế thừa.",
      "Khả năng định nghĩa Abstract Methods.",
    ],
    answer: 1,
    explanation:
      "Abstract Class có constructor và implementation code; Interface thì không (trước JDK 8).",
  },
  {
    id: 1075,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `Shape` có phương thức Non-Abstract `getColor()` và lớp con `Circle` không ghi đè, `Circle` sẽ sử dụng logic nào khi gọi `getColor()`?",
    options: [
      "Lớp `Circle` phải tự định nghĩa `getColor()`.",
      "Logic của phương thức `getColor()` trong lớp `Shape`.",
      "Nó sẽ gây ra lỗi biên dịch.",
      "Nó sẽ trả về `null`.",
    ],
    answer: 1,
    explanation: "Phương thức Non-Abstract được tự động kế thừa.",
  },
  {
    id: 1076,
    topic: "Inheritance",
    question:
      "Một Abstract Class được thiết kế để 'hợp lý hóa' các lớp con bằng cách nào?",
    options: [
      "Bắt buộc tất cả các lớp con phải có cùng tên fields.",
      "Định nghĩa các Abstract Methods để thống nhất protocol cho các lớp con.",
      "Giới hạn số lượng phương thức.",
      "Ngăn chặn sử dụng kiểu dữ liệu String.",
    ],
    answer: 1,
    explanation:
      "Định nghĩa protocol (Abstract Methods) là mục đích chính của Abstract Class trong kiến trúc kế thừa.",
  },
  {
    id: 1077,
    topic: "Abstract Method",
    question:
      "Khi một lớp con Concrete implement Abstract Method, điều gì là KHÔNG cần thiết?",
    options: [
      "Cung cấp thân hàm (body).",
      "Sử dụng chú thích `@Override` (Khuyến nghị nhưng không bắt buộc).",
      "Giữ nguyên tên phương thức.",
      "Khai báo lớp con đó là Abstract.",
    ],
    answer: 3,
    explanation: "Lớp con đã là Concrete, không cần khai báo Abstract.",
  },
  {
    id: 1078,
    topic: "Abstract Class",
    question: "Điều gì ngăn cản việc khởi tạo Abstract Class?",
    options: [
      "Sự hiện diện của Abstract Methods.",
      "Từ khóa `abstract` trong khai báo class.",
      "Constructor `private`.",
      "Việc nó kế thừa lớp `Object`.",
    ],
    answer: 1,
    explanation: "Từ khóa `abstract` cấm sử dụng `new`.",
  },
  {
    id: 1079,
    topic: "Comparison",
    question:
      "Tại sao Java cấm đa kế thừa (Multiple Inheritance) đối với các Class (bao gồm cả Abstract Class)?",
    options: [
      "Để tiết kiệm bộ nhớ.",
      "Vì nó có thể gây ra mơ hồ (ambiguity) nếu các lớp cha có phương thức giống nhau (Deadly Diamond of Death).",
      "Vì Abstract Class không thể có constructor.",
      "Vì Interface không thể có fields.",
    ],
    answer: 1,
    explanation: "Vấn đề mơ hồ (Deadly Diamond of Death).",
  },
  {
    id: 1080,
    topic: "Abstract Class",
    question:
      "Trong Abstract Class, một phương thức `static` có thể gọi một Abstract Method không?",
    options: [
      "Có, nếu Abstract Method đó được implement trong lớp con.",
      "Không, vì phương thức `static` không liên quan đến instance, nhưng Abstract Method yêu cầu instance để gọi implementation của lớp con.",
      "Chỉ khi Abstract Method là `public`.",
      "Chỉ khi Abstract Class không có fields.",
    ],
    answer: 1,
    explanation:
      "Static method không thể gọi Abstract Method (vì nó không biết implement nào để gọi).",
  },
  {
    id: 1081,
    topic: "Abstract Class",
    question: "Điều gì là một hạn chế đối với Abstract Class?",
    options: [
      "Nó không thể có constructor.",
      "Nó không thể được sử dụng làm kiểu tham chiếu.",
      "Nó phải chứa ít nhất một Abstract Method.",
      "Nó không thể được khởi tạo trực tiếp.",
    ],
    answer: 3,
    explanation: "Abstract Class không thể được khởi tạo trực tiếp.",
  },
  {
    id: 1082,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method được khai báo là `public abstract double getPrice();`, lớp con có thể implement nó bằng cách khai báo là `public float getPrice()` không?",
    options: [
      "Có, nếu `float` tương thích với `double`.",
      "Không, kiểu trả về phải tương thích, nhưng không thể thay đổi thành kiểu không tương thích (primitive types thường không được nới lỏng theo cách này khi ghi đè).",
      "Chỉ khi lớp con là Abstract.",
      "Chỉ khi `getPrice()` là `static`.",
    ],
    answer: 1,
    explanation:
      "Kiểu trả về phải tương thích. Primitive types cần khớp hoặc là subclass của nhau (trong trường hợp đối tượng), float/double không tương thích hoàn toàn khi ghi đè.",
  },
  {
    id: 1083,
    topic: "Inheritance",
    question:
      "Khi lớp con Concrete kế thừa Abstract Class A, nó có thể sử dụng phương thức Non-Abstract của A để xử lý logic chung và sử dụng Abstract Method (đã implement) để xử lý logic cụ thể. Đây là mẫu thiết kế nào?",
    options: [
      "Singleton.",
      "Factory Method.",
      "Strategy.",
      "Template Method (Conceptual).",
    ],
    answer: 3,
    explanation:
      "Đây là khái niệm của Template Method Pattern (dù Pattern này không được đặt tên trực tiếp trong nguồn, nhưng logic sử dụng Abstract/Non-Abstract Method chung khớp với nó) .",
  },
  {
    id: 1084,
    topic: "Abstract Class",
    question: "Điều gì là hợp lệ về cấu trúc của Abstract Class?",
    options: [
      "Nó có thể có cả fields `static` và `non-static`.",
      "Nó không thể có constructor.",
      "Nó phải kế thừa một Interface.",
      "Nó phải implement tất cả các phương thức của lớp cha.",
    ],
    answer: 0,
    explanation: "Abstract Class có thể có fields.",
  },
  {
    id: 1085,
    topic: "Comparison",
    question:
      "Nếu một Abstract Class không có Abstract Methods, mục đích duy nhất của nó là gì?",
    options: [
      "Buộc ghi đè phương thức.",
      "Ngăn chặn việc khởi tạo class đó.",
      "Cung cấp đa kế thừa.",
      "Cung cấp hằng số.",
    ],
    answer: 1,
    explanation: "Dùng Abstract Class để ngăn khởi tạo.",
  },
  {
    id: 1086,
    topic: "Abstract Class",
    question:
      "Trong Abstract Class, các phương thức Non-Abstract có thể truy cập Abstract Methods không?",
    options: [
      "Không, vì Abstract Method chưa có implementation.",
      "Có, thông qua cơ chế gọi phương thức ảo (Virtual Method Invocation), nó sẽ gọi implementation của lớp con khi chạy.",
      "Chỉ khi Abstract Method được khai báo là `private`.",
      "Chỉ khi phương thức Non-Abstract là `static`.",
    ],
    answer: 1,
    explanation:
      "Đây là bản chất của Template Method, cho phép logic chung (Non-Abstract) gọi hành vi cụ thể (Abstract).",
  },
  {
    id: 1087,
    topic: "Inheritance",
    question:
      "Nếu lớp con Concrete `C` không implement Abstract Method `m()` từ Abstract Class `A`, trình biên dịch sẽ báo lỗi. Điều này là để kiểm tra vấn đề gì?",
    options: [
      "Kiểm tra tính an toàn kiểu (Type Safety).",
      "Đảm bảo rằng đối tượng `C` sẽ không bị thiếu hành vi (chức năng) đã cam kết trong `A`.",
      "Buộc `C` phải là `private`.",
      "Buộc `C` phải gọi `super()`.",
    ],
    answer: 1,
    explanation:
      "Lớp Concrete phải implement tất cả Abstract Methods để hoàn thành giao kèo.",
  },
  {
    id: 1088,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `X` có constructor, lớp con `Y` (Concrete) có thể không cần định nghĩa constructor của riêng nó không?",
    options: [
      "Có, Java sẽ cung cấp constructor mặc định cho `Y` và gọi constructor mặc định của `X`.",
      "Không, `Y` phải có constructor.",
      "Chỉ khi `Y` là Abstract.",
      "Chỉ khi `X` không có Abstract Methods.",
    ],
    answer: 0,
    explanation:
      "Nếu lớp con không định nghĩa constructor, Java cung cấp default constructor và cố gắng gọi default constructor của lớp cha.",
  },
  {
    id: 1089,
    topic: "Abstract Method",
    question: "Cú pháp nào mô tả Abstract Method?",
    options: [
      "Khai báo chữ ký, theo sau là khối `{}`.",
      "Khai báo chữ ký, không có `{}` và kết thúc bằng `;`.",
      "Khai báo `final` và `static`.",
      "Khai báo `private` và `abstract`.",
    ],
    answer: 1,
    explanation: "Abstract Method không có thân hàm.",
  },
  {
    id: 1090,
    topic: "Comparison",
    question:
      "Trong trường hợp nào, Abstract Class có thể được coi là linh hoạt hơn Interface?",
    options: [
      "Khi cần định nghĩa các hằng số `public static final`.",
      "Khi cần xác định một phần implementation (thân hàm) cho các lớp con sử dụng chung.",
      "Khi cần đa kế thừa.",
      "Khi cần ngăn chặn hoàn toàn việc kế thừa.",
    ],
    answer: 1,
    explanation: "Abstract Class có thể cung cấp implementation code.",
  },
  {
    id: 1091,
    topic: "Abstract Class",
    question: "Điều gì là KHÔNG thể đối với Abstract Class?",
    options: [
      "Khai báo mảng chứa tham chiếu đến các đối tượng lớp con.",
      "Có phương thức `private`.",
      "Có constructor `protected`.",
      "Khởi tạo chính nó.",
    ],
    answer: 3,
    explanation: "Không thể được khởi tạo trực tiếp.",
  },
  {
    id: 1092,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `A` có Abstract Method `m()`, và lớp con Abstract `B` kế thừa `A`, `B` nên làm gì để tiếp tục 'hoãn' trách nhiệm implement `m()`?",
    options: [
      "Khai báo `m()` là `final` trong `B`.",
      "Không cần làm gì, `m()` vẫn là Abstract trong `B`.",
      "Khai báo `B` là Concrete.",
      "Cung cấp thân hàm rỗng cho `m()`.",
    ],
    answer: 1,
    explanation:
      "Nếu B là Abstract, nó không cần implement Abstract Methods được kế thừa.",
  },
  {
    id: 1093,
    topic: "Abstract Method",
    question:
      "Nếu lớp Concrete `C` implement Abstract Method `m()`, và trong thân hàm của `m()`, `C` gọi `super.m()`, điều gì xảy ra?",
    options: [
      "Lỗi Biên dịch, vì `m()` Abstract không có thân hàm để `super` gọi .",
      "Chương trình chạy bình thường.",
      "Nó gọi constructor của lớp cha.",
      "Nó gọi phương thức tĩnh của lớp cha.",
    ],
    answer: 0,
    explanation:
      "Abstract Method không có thân hàm nên không thể gọi bằng `super` .",
  },
  {
    id: 1094,
    topic: "Abstract Class",
    question:
      "Việc Abstract Class ẩn giấu chi tiết implementation phức tạp được gọi là gì?",
    options: [
      "Encapsulation (Đóng gói).",
      "Information Hiding (Ẩn thông tin).",
      "Polymorphism.",
      "Binding.",
    ],
    answer: 1,
    explanation:
      "Ẩn giấu chi tiết implementation là Information Hiding/Abstraction.",
  },
  {
    id: 1095,
    topic: "Comparison",
    question:
      "Lớp nào có thể implement nhiều Interface để đạt được đa kế thừa về kiểu (Type Multiple Inheritance)?",
    options: [
      "Chỉ Abstract Class.",
      "Chỉ Interface.",
      "Cả Abstract Class và Concrete Class.",
      "Chỉ Concrete Class.",
    ],
    answer: 2,
    explanation: "Cả hai đều có thể implement nhiều Interface.",
  },
  {
    id: 1096,
    topic: "Abstract Class",
    question:
      "Nếu một lớp chỉ có các phương thức `static` và `final`, có cần thiết phải khai báo nó là Abstract không?",
    options: [
      "Có, luôn luôn.",
      "Không, vì mục đích của nó là cung cấp các hàm tiện ích, không phải làm khuôn mẫu đa hình.",
      "Chỉ khi nó có Abstract Fields.",
      "Chỉ khi nó có Constructor.",
    ],
    answer: 1,
    explanation:
      "Các lớp tiện ích (Utility classes) như Math class thường chỉ có static methods, không cần thiết phải là Abstract.",
  },
  {
    id: 1097,
    topic: "Abstract Class",
    question: "Đâu là một yêu cầu hợp lý cho Abstract Class?",
    options: [
      "Phải có ít nhất một constructor.",
      "Phải kế thừa từ lớp `Object`.",
      "Phải có ít nhất một Abstract Method.",
      "Phải là `final`.",
    ],
    answer: 1,
    explanation: "Mọi class trong Java đều là subclass của `Object`.",
  },
  {
    id: 1098,
    topic: "Abstract Method",
    question: "Tại sao Abstract Method không thể là `static`?",
    options: [
      "Vì nó không thể được gọi từ lớp con.",
      "Vì phương thức `static` không thể bị ghi đè/thực thi lại (overridden/reimplemented) ở cấp độ instance, mâu thuẫn với mục đích của Abstract Method.",
      "Vì nó không thể có kiểu trả về.",
      "Vì Abstract Class không thể có phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "Mâu thuẫn về mục đích: Abstract Method yêu cầu implementation đa hình, Static Method thì không thể bị ghi đè theo cách đó.",
  },
  {
    id: 1099,
    topic: "Abstract Class",
    question:
      "Nếu bạn muốn mô hình hóa một khái niệm không tồn tại trong thế giới thực nhưng cần thiết cho cấu trúc lập trình, bạn có thể sử dụng Abstract Class hoặc Interface. Điều này hỗ trợ cho việc tổ chức code theo mô hình nào?",
    options: [
      "Procedural Programming.",
      "Unstructured Programming.",
      "Object-Oriented Programming (Mô hình hóa thực thể thế giới thực hoặc khái niệm).",
      "Logic Programming.",
    ],
    answer: 2,
    explanation:
      "OOP tổ chức code bằng cách mô hình hóa các thực thể hoặc khái niệm trong thế giới thực.",
  },
  {
    id: 1100,
    topic: "Abstract Class",
    question: "Điều gì là yêu cầu bắt buộc đối với một Abstract Class?",
    options: [
      "Nó phải có ít nhất một Abstract Method.",
      "Nó phải có ít nhất một constructor.",
      "Nó phải có từ khóa `abstract`.",
      "Nó phải implement `Serializable`.",
    ],
    answer: 2,
    explanation: "Phải có từ khóa `abstract` trong khai báo class.",
  },
  {
    id: 1101,
    topic: "Abstract Class",
    question:
      "Khi nào một lớp con của Abstract Class sẽ tự động trở thành Abstract Class?",
    options: [
      "Khi nó không implement tất cả các Abstract Methods được kế thừa.",
      "Khi nó sử dụng từ khóa `super`.",
      "Khi nó có Constructor có tham số.",
      "Khi nó là một Utility Class.",
    ],
    answer: 0,
    explanation:
      "Nếu không implement hết, nó vẫn còn Abstract Methods chưa được xử lý, buộc nó phải là Abstract.",
  },
  {
    id: 1102,
    topic: "Abstract Method",
    question:
      "Việc implement Abstract Method trong lớp con Concrete là bắt buộc để đảm bảo điều gì?",
    options: [
      "Tính linh hoạt của fields.",
      "Tính toàn vẹn logic: đối tượng có thể thực hiện tất cả các hành vi đã hứa.",
      "Ngăn chặn lỗi NullPointerException.",
      "Cho phép Downcasting.",
    ],
    answer: 1,
    explanation:
      "Đảm bảo đối tượng có thể thực hiện tất cả các hành vi (methods).",
  },
  {
    id: 1103,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có `public void m() {}`, và lớp con Concrete B kế thừa A, B có thể ghi đè `m()` không?",
    options: [
      "Không, vì A là Abstract.",
      "Có, nếu B muốn thay đổi hoặc mở rộng hành vi của `m()`.",
      "Chỉ khi `m()` là Abstract.",
      "Chỉ khi B là Abstract.",
    ],
    answer: 1,
    explanation: "Phương thức Non-Abstract vẫn có thể bị ghi đè.",
  },
  {
    id: 1104,
    topic: "Comparison",
    question:
      "Trong khi Interface chỉ định các hành vi (methods), Abstract Class có thể cung cấp thêm gì?",
    options: [
      "Constructor và trạng thái khởi tạo chung (fields).",
      "Đa kế thừa.",
      "Fields `private` không được kế thừa.",
      "Các phương thức `final` không thể gọi.",
    ],
    answer: 0,
    explanation: "Abstract Class có constructor và fields.",
  },
  {
    id: 1105,
    topic: "Abstract Class",
    question: "Điều gì KHÔNG thể được khai báo là Abstract?",
    options: ["Class", "Method", "Constructor", "Field"],
    answer: 2,
    explanation:
      "Constructor không có kiểu trả về nên không thể là Abstract Method.",
  },
  {
    id: 1106,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method được khai báo trong Abstract Class, access modifier nào là hạn chế nhất mà nó có thể có (hợp lệ)?",
    options: ["private", "default (package-private) ", "public", "protected"],
    answer: 1,
    explanation:
      "Nó không thể là private. Default là hạn chế nhất nhưng vẫn cho phép lớp con trong cùng package truy cập/implement .",
  },
  {
    id: 1107,
    topic: "Inheritance",
    question:
      "Nếu lớp `Vehicle` là Abstract Class, và `Car` kế thừa `Vehicle`, khi tạo `Car c = new Car();`, constructor nào được gọi trước?",
    options: [
      "Constructor của `Car`.",
      "Constructor của `Vehicle`.",
      "Constructor của `Object`.",
      "Không có constructor nào được gọi.",
    ],
    answer: 1,
    explanation: "Constructor của lớp cha luôn được gọi trước lớp con.",
  },
  {
    id: 1108,
    topic: "Abstract Class",
    question: "Một Abstract Class có thể có constructor `private` không?",
    options: [
      "Không, vì không thể gọi từ bên ngoài.",
      "Có, nhưng điều này chỉ có ý nghĩa nếu nó có các constructor khác (public/protected) hoặc là Factory class.",
      "Chỉ khi nó không có Abstract Methods.",
      "Chỉ khi nó là `final`.",
    ],
    answer: 1,
    explanation: "Abstract Class có thể có constructor.",
  },
  {
    id: 1109,
    topic: "Abstract Class",
    question: "Lớp nào sau đây không thể là lớp Abstract?",
    options: [
      "Lớp có constructor `private`.",
      "Lớp có phương thức `final`.",
      "Lớp được khai báo là `final`.",
      "Lớp có fields `static`.",
    ],
    answer: 2,
    explanation: "Không thể là Abstract và final cùng lúc.",
  },
  {
    id: 1110,
    topic: "Abstract Class",
    question:
      "Khi Abstract Class được sử dụng, nó có thể được mô tả như là việc trừu tượng hóa các khái niệm để tổ chức mã. Lợi ích chính là:",
    options: [
      "Cho phép đa kế thừa giữa các lớp.",
      "Mã trở nên có tổ chức và dễ hiểu hơn.",
      "Giảm thiểu việc sử dụng fields `private`.",
      "Buộc tất cả các phương thức phải là `static`.",
    ],
    answer: 1,
    explanation: "Abstract Class hỗ trợ tổ chức code (khái niệm Abstraction).",
  },
  {
    id: 1111,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `A` không có Abstract Methods, và `B` kế thừa `A`, `B` là Concrete Class. Khi khởi tạo `B`, lỗi biên dịch xảy ra nếu:",
    options: [
      "A có constructor có tham số và B không gọi `super()`.",
      "A có fields `static`.",
      "B không ghi đè bất kỳ phương thức nào.",
      "B không có constructor.",
    ],
    answer: 0,
    explanation:
      "Nếu lớp cha chỉ có constructor có tham số, lớp con phải gọi nó.",
  },
  {
    id: 1112,
    topic: "Abstract Method",
    question:
      "Nếu lớp con Concrete không implement Abstract Method, điều này vi phạm nguyên tắc nào?",
    options: [
      "Nguyên tắc của Polymorphism.",
      "Nguyên tắc của Inheritance (Phải hoàn thành giao kèo của lớp cha).",
      "Nguyên tắc của Encapsulation.",
      "Nguyên tắc DRY (Don't Repeat Yourself).",
    ],
    answer: 1,
    explanation:
      "Vi phạm quy tắc kế thừa: lớp con Concrete đầu tiên phải implement.",
  },
  {
    id: 1113,
    topic: "Abstract Class",
    question:
      "Một Abstract Class có thể implement một Interface và để lại một số phương thức của Interface đó là Abstract không?",
    options: [
      "Không, nó phải implement tất cả.",
      "Có, nếu Abstract Class không cung cấp implementation cho một phương thức Interface, phương thức đó vẫn là Abstract, và lớp con Concrete tiếp theo phải implement nó.",
      "Chỉ khi Interface đó là `final`.",
      "Chỉ khi sử dụng `this()`.",
    ],
    answer: 1,
    explanation:
      "Lớp Abstract có thể hoãn trách nhiệm implement Interface Method xuống lớp con Concrete.",
  },
  {
    id: 1114,
    topic: "Abstract Class",
    question: "Điều gì là hợp lệ trong Abstract Class?",
    options: [
      "Field được khai báo là `abstract`.",
      "Constructor được khai báo là `abstract`.",
      "Method được khai báo là `abstract`.",
      "Class được khai báo là `final`.",
    ],
    answer: 2,
    explanation: "Chỉ có Method mới có thể là Abstract.",
  },
  {
    id: 1115,
    topic: "Comparison",
    question:
      "Nếu bạn muốn thiết kế một khuôn mẫu mà CẢM KẾT các lớp con sẽ có một hành vi, nhưng KHÔNG CẦN CUNG CẤP implementation code nào, bạn nên dùng gì?",
    options: [
      "Concrete Class",
      "Abstract Class với Non-Abstract Methods",
      "Interface",
      "Lớp Utility",
    ],
    answer: 2,
    explanation: "Interface là 100% Abstract, chỉ định nghĩa protocol.",
  },
  {
    id: 1116,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `A` có Abstract Method `m()`, và lớp con Concrete `B` implement `m()`, nếu ta gọi `A ref = new B(); ref.m();`, phiên bản nào của `m()` được gọi?",
    options: [
      "Phiên bản trong `A`.",
      "Phiên bản đã implement trong `B` (Polymorphism).",
      "Lỗi Biên dịch.",
      "Phương thức tĩnh.",
    ],
    answer: 1,
    explanation:
      "Virtual Method Invocation: Phiên bản của đối tượng thực tế được gọi.",
  },
  {
    id: 1117,
    topic: "Abstract Class",
    question:
      "Một Abstract Class không thể được khởi tạo, nhưng nó có thể có bao nhiêu fields?",
    options: [
      "0",
      "Chỉ fields `static`.",
      "Bất kỳ số lượng fields nào (như một class bình thường).",
      "Chỉ fields được khai báo là `private`.",
    ],
    answer: 2,
    explanation: "Abstract Class có thể có fields.",
  },
  {
    id: 1118,
    topic: "Abstract Method",
    question:
      "Khi implement Abstract Method, lớp con có được phép nới lỏng access modifier (ví dụ: từ `protected` trong lớp cha thành `public` trong lớp con) không?",
    options: [
      "Không, phải giữ nguyên.",
      "Có, access modifier có thể nới lỏng hơn (ít hạn chế hơn).",
      "Chỉ khi Abstract Method là `final`.",
      "Chỉ khi lớp cha không có fields.",
    ],
    answer: 1,
    explanation: "Access modifier phải giữ nguyên hoặc nới lỏng hơn.",
  },
  {
    id: 1119,
    topic: "Abstract Class",
    question:
      "Nếu một Abstract Class không có Abstract Methods, tại sao nó vẫn được khai báo là Abstract?",
    options: [
      "Để ngăn chặn việc kế thừa.",
      "Để cung cấp một cách tổ chức fields `static`.",
      "Để đảm bảo nó không được tạo instance, ngay cả khi nó có logic hoàn chỉnh.",
      "Để buộc các lớp con phải implement constructor.",
    ],
    answer: 2,
    explanation: "Mục đích chính: ngăn khởi tạo.",
  },
  {
    id: 1120,
    topic: "Abstract Method",
    question: "Abstract Method có thể có kiểu trả về là gì?",
    options: [
      "Chỉ `void` hoặc `int`.",
      "Bất kỳ kiểu dữ liệu hợp lệ nào (primitive hoặc Object).",
      "Chỉ kiểu dữ liệu `final`.",
      "Chỉ kiểu dữ liệu `static`.",
    ],
    answer: 1,
    explanation: "Bất kỳ kiểu dữ liệu nào (ví dụ: `double area()`).",
  },
  {
    id: 1121,
    topic: "Abstract Class",
    question: "Điều gì là SAI khi nói về Abstract Class?",
    options: [
      "Nó là kiểu dữ liệu cơ bản (Primitive type).",
      "Nó có thể có constructor.",
      "Nó có thể có fields.",
      "Nó không thể được khởi tạo.",
    ],
    answer: 0,
    explanation: "Abstract Class là reference type, không phải primitive type.",
  },
  {
    id: 1122,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `A` có `public` fields, lớp con Concrete `B` kế thừa `A` sẽ làm gì với fields đó?",
    options: [
      "Tự động kế thừa và có thể truy cập trực tiếp fields.",
      "Phải khai báo lại fields đó.",
      "Không thể truy cập fields đó.",
      "Fields đó tự động trở thành `private`.",
    ],
    answer: 0,
    explanation: "Fields được kế thừa.",
  },
  {
    id: 1123,
    topic: "Abstract Method",
    question:
      "Khi lớp con Concrete implement Abstract Method, điều gì là KHÔNG được phép thay đổi?",
    options: [
      "Logic bên trong thân hàm.",
      "Access modifier (có thể nới lỏng).",
      "Tên phương thức.",
      "Thêm tham số mới (thành Overloading, không phải Overriding/Implementing).",
    ],
    answer: 2,
    explanation: "Không được thay đổi tên phương thức.",
  },
  {
    id: 1124,
    topic: "Abstract Class",
    question:
      "Mục đích của việc sử dụng Abstract Class như là một loại tham chiếu trong một mảng (`AbstractClass[] array`) là gì?",
    options: [
      "Để lưu trữ các instance của Abstract Class.",
      "Để tạo một mảng đa hình (polymorphic array) có khả năng chứa các đối tượng của các lớp con Concrete khác nhau.",
      "Để ép kiểu tự động.",
      "Để ngăn việc sử dụng bộ nhớ Heap.",
    ],
    answer: 1,
    explanation: "Sử dụng Abstract Class làm kiểu tham chiếu cho đa hình.",
  },
  {
    id: 1125,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method được khai báo là `public abstract int getValue(int x);`, lớp con có thể implement nó bằng cách khai báo là `public int getValue(int x) { return 0; }` không?",
    options: [
      "Không, vì thiếu `@Override`.",
      "Có, đây là cách implement hợp lệ.",
      "Chỉ khi lớp con là Abstract.",
      "Không, vì không gọi `super()`.",
    ],
    answer: 1,
    explanation: "Hợp lệ, miễn là cung cấp thân hàm.",
  },
  {
    id: 1126,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có `private` fields, lớp con B có thể truy cập trực tiếp fields đó không?",
    options: [
      "Có, nếu B là Concrete.",
      "Không, fields `private` chỉ truy cập được trong chính class đó.",
      "Chỉ qua phương thức `super.getters()`.",
      "Chỉ qua Downcasting.",
    ],
    answer: 1,
    explanation:
      "Fields `private` không thể truy cập trực tiếp, ngay cả khi kế thừa.",
  },
  {
    id: 1127,
    topic: "Abstract Class",
    question:
      "Lớp nào sau đây được coi là hoàn toàn trừu tượng (100% abstract) và được Java sử dụng để đạt được đa kế thừa về kiểu?",
    options: ["Abstract Class", "Concrete Class", "Interface", "Wrapper Class"],
    answer: 2,
    explanation: "Interface là 100% Abstract.",
  },
  {
    id: 1128,
    topic: "Inheritance",
    question:
      "Nếu lớp con Concrete không gọi `super()` trong constructor, điều gì sẽ xảy ra nếu lớp cha là Abstract và chỉ có constructor mặc định?",
    options: [
      "Lỗi Biên dịch.",
      "Trình biên dịch tự động chèn lệnh gọi `super()` đến constructor mặc định của lớp cha.",
      "Lớp con sẽ không được khởi tạo.",
      "Lỗi Runtime (NullPointerException).",
    ],
    answer: 1,
    explanation: "Java tự động chèn `super()` đến default constructor.",
  },
  {
    id: 1129,
    topic: "Abstract Method",
    question: "Tại sao Abstract Method không thể là `private`?",
    options: [
      "Vì nó không thể được kế thừa/ghi đè/implement bởi lớp con .",
      "Vì nó luôn được gọi từ `main()`.",
      "Vì nó không thể trả về giá trị.",
      "Vì nó là `static`.",
    ],
    answer: 0,
    explanation:
      "Mục đích của Abstract Method là để lớp con implement, mâu thuẫn với `private` .",
  },
  {
    id: 1130,
    topic: "Abstract Class",
    question:
      "Abstract Class có thể khai báo mảng fields (e.g., `String[] names;`) không?",
    options: [
      "Không.",
      "Có, như một class bình thường.",
      "Chỉ khi mảng đó là `static`.",
      "Chỉ khi mảng đó là `final`.",
    ],
    answer: 1,
    explanation: "Abstract Class có thể có fields bình thường.",
  },
  {
    id: 1131,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có Abstract Method `m()`, và lớp con Abstract B kế thừa A, B có thể khai báo thêm Abstract Method `n()` không?",
    options: [
      "Không, chỉ một Abstract Class duy nhất có thể khai báo Abstract Methods.",
      "Có, B vẫn là Abstract Class và có thể định nghĩa thêm protocol.",
      "Chỉ khi A không có constructor.",
      "Chỉ khi A có fields `static`.",
    ],
    answer: 1,
    explanation: "Abstract Class có thể có nhiều Abstract Methods.",
  },
  {
    id: 1132,
    topic: "Inheritance",
    question: "Điều gì là đúng về việc kế thừa Abstract Class?",
    options: [
      "Chỉ cần kế thừa Abstract Class nếu nó không có constructor.",
      "Lớp con có thể mở rộng (extends) Abstract Class.",
      "Lớp con phải implement (implements) Abstract Class.",
      "Không thể kế thừa Abstract Class.",
    ],
    answer: 1,
    explanation: "Lớp con mở rộng (extends) Abstract Class.",
  },
  {
    id: 1133,
    topic: "Abstract Class",
    question:
      "Lớp Abstract là một công cụ giúp tổ chức code bằng cách mô hình hóa các thực thể thế giới thực hoặc các khái niệm. Điều này thuộc về Lập trình hướng đối tượng (OOP):",
    options: [
      "Chỉ là các thủ tục.",
      "Là các mô hình vật lý.",
      "Là các đối tượng (Object).",
      "Chỉ là các fields.",
    ],
    answer: 2,
    explanation: "OOP mô hình hóa thành objects.",
  },
  {
    id: 1134,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có Non-Abstract Method `m()`, và B kế thừa A, B không ghi đè `m()`. Nếu gọi `B b = new B(); b.m();`, thì phương thức `m()` nào được gọi?",
    options: [
      "Phương thức `m()` trong lớp A.",
      "Lỗi Biên dịch.",
      "Phương thức tĩnh.",
      "Phương thức `main()`.",
    ],
    answer: 0,
    explanation: "Phương thức được kế thừa từ lớp A được gọi.",
  },
  {
    id: 1135,
    topic: "Abstract Method",
    question: "Abstract Method không có thân hàm. Lợi ích của việc này là gì?",
    options: [
      "Giảm dung lượng bộ nhớ.",
      "Cho phép lớp con Concrete quyết định chi tiết implementation, hỗ trợ đa hình.",
      "Ngăn chặn lỗi logic.",
      "Bắt buộc sử dụng `final`.",
    ],
    answer: 1,
    explanation: "Lớp con cung cấp implementation cụ thể.",
  },
  {
    id: 1136,
    topic: "Comparison",
    question: "Interface có thể kế thừa (extends) Interface khác không?",
    options: [
      "Không.",
      "Có, và có thể kế thừa nhiều Interface.",
      "Chỉ Abstract Class có thể kế thừa Interface.",
      "Chỉ Interface không có Abstract Methods.",
    ],
    answer: 1,
    explanation: "Interface có thể kế thừa một hoặc nhiều Interface khác.",
  },
  {
    id: 1137,
    topic: "Abstract Class",
    question: "Điều gì là ĐÚNG về Abstract Class?",
    options: [
      "Nó là bắt buộc để có Abstract Methods.",
      "Nó có thể không có Abstract Methods, miễn là nó được khai báo là `abstract`.",
      "Nó luôn là `public`.",
      "Nó chỉ có thể có `private` constructor.",
    ],
    answer: 1,
    explanation: "Không bắt buộc phải có Abstract Methods.",
  },
  {
    id: 1138,
    topic: "Inheritance",
    question:
      "Khi lớp con Concrete implement Abstract Method, điều gì xảy ra với Abstract Method gốc trong Abstract Class?",
    options: [
      "Nó bị xóa khỏi Abstract Class.",
      "Nó vẫn tồn tại, định nghĩa protocol, nhưng implementation chỉ có trong lớp con.",
      "Nó tự động trở thành `final`.",
      "Nó trở thành một field.",
    ],
    answer: 1,
    explanation:
      "Abstract Method vẫn là định nghĩa protocol (giao kèo) trong Abstract Class.",
  },
  {
    id: 1139,
    topic: "Abstract Class",
    question:
      "Nếu một lớp là Abstract Class, nó có thể được sử dụng làm kiểu trong `ArrayList<T>` không?",
    options: [
      "Không.",
      "Có, ví dụ: `ArrayList<Animal>` có thể chứa `Dog` và `Cat` (lớp con).",
      "Chỉ khi sử dụng `wildcards`.",
      "Chỉ khi Abstract Class là `final`.",
    ],
    answer: 1,
    explanation: "Abstract Type được dùng như reference type cho polymorphism.",
  },
  {
    id: 1140,
    topic: "Abstract Method",
    question: "Abstract Method có thể có access modifier `private` không?",
    options: [
      "Có.",
      "Không .",
      "Chỉ trong Interface.",
      "Chỉ khi nó là `static`.",
    ],
    answer: 1,
    explanation: "Không thể là `private` .",
  },
  {
    id: 1141,
    topic: "Abstract Class",
    question:
      "Cơ chế Abstract Class được sử dụng để định nghĩa protocol (giao thức) chung cho một nhóm các lớp con. Khái niệm này còn được gọi là gì?",
    options: [
      "Class Blueprint.",
      "Supertype Contract.",
      "Static Binding.",
      "Downcasting.",
    ],
    answer: 1,
    explanation:
      "Abstract Class định nghĩa giao kèo (contract) cho các lớp con.",
  },
  {
    id: 1142,
    topic: "Abstract Class",
    question:
      "Nếu bạn muốn thiết kế một lớp mà các lớp con có thể kế thừa code và cả giao thức, Abstract Class là lựa chọn tối ưu hơn Interface vì:",
    options: [
      "Nó cho phép đa kế thừa.",
      "Nó có thể cung cấp constructor để khởi tạo trạng thái chung.",
      "Fields của nó luôn là `static final`.",
      "Nó không cần từ khóa `abstract`.",
    ],
    answer: 1,
    explanation: "Abstract Class có thể có constructor.",
  },
  {
    id: 1143,
    topic: "Abstract Method",
    question:
      "Việc implement Abstract Method được thực hiện bằng cách nào trong lớp con Concrete?",
    options: [
      "Bằng cách sử dụng từ khóa `final`.",
      "Bằng cách ghi đè phương thức (Overriding) với cùng chữ ký và cung cấp thân hàm.",
      "Bằng cách gọi `this()`.",
      "Bằng cách khai báo lại là Abstract.",
    ],
    answer: 1,
    explanation: "Implement Abstract Method là Overriding.",
  },
  {
    id: 1144,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có constructor `A()`, và B kế thừa A. Khi `new B()`, thứ tự gọi constructor là gì?",
    options: [
      "A(), B().",
      "B(), A().",
      "Chỉ B() được gọi.",
      "Không có gì được gọi.",
    ],
    answer: 0,
    explanation: "Constructor lớp cha được gọi trước.",
  },
  {
    id: 1145,
    topic: "Abstract Class",
    question:
      "Điều gì là đúng về Abstract Class so với Interface (trước JDK 8)?",
    options: [
      "Abstract Class cho phép khai báo `private` fields.",
      "Interface cho phép khai báo `private` fields.",
      "Cả hai đều có thể khai báo `protected` fields.",
      "Cả hai đều phải có Abstract Methods.",
    ],
    answer: 0,
    explanation: "Abstract Class có thể có fields, kể cả private.",
  },
  {
    id: 1146,
    topic: "Inheritance",
    question:
      "Nếu lớp `Vehicle` là Abstract Class và có phương thức Non-Abstract `brake()`, lớp con `Car` có thể mở rộng hành vi của `brake()` bằng cách nào?",
    options: [
      "Ghi đè `brake()` và gọi logic gốc bằng `super.brake()`.",
      "Khai báo `brake()` là Abstract trong `Car`.",
      "Sử dụng `this()`.",
      "Chỉ sử dụng `static`.",
    ],
    answer: 0,
    explanation: "Sử dụng `super` để gọi phương thức lớp cha đã bị ghi đè.",
  },
  {
    id: 1147,
    topic: "Abstract Method",
    question:
      "Khi Abstract Method được định nghĩa, nó cam kết điều gì với lớp con?",
    options: [
      "Giá trị của nó không thay đổi.",
      "Lớp con phải có khả năng thực hiện hành vi đó.",
      "Nó phải là `final`.",
      "Nó phải là `private`.",
    ],
    answer: 1,
    explanation: "Cam kết rằng lớp con phải thực hiện hành vi đó.",
  },
  {
    id: 1148,
    topic: "Abstract Class",
    question: "Điều gì xảy ra nếu bạn đánh dấu một Abstract Class là `final`?",
    options: [
      "Lỗi Biên dịch, vì mâu thuẫn về mục đích.",
      "Nó trở thành một Interface.",
      "Nó trở thành một Concrete Class.",
      "Nó được phép khởi tạo.",
    ],
    answer: 0,
    explanation: "Lỗi Biên dịch.",
  },
  {
    id: 1149,
    topic: "Abstract Class",
    question:
      "Trong Abstract Class, từ khóa `this` có thể được sử dụng trong constructor để làm gì?",
    options: [
      "Gọi Abstract Method.",
      "Gọi một constructor khác của chính Abstract Class đó.",
      "Khởi tạo fields `static`.",
      "Chỉ định rằng class là Abstract.",
    ],
    answer: 1,
    explanation:
      "Sử dụng `this()` để gọi constructor khác của chính class hiện tại.",
  },
  {
    id: 1150,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method được khai báo là `protected abstract void draw();`, lớp con phải implement nó với access modifier nào tối thiểu?",
    options: [
      "`private`",
      "`protected` (hoặc `public`)",
      "`default`",
      "`final`",
    ],
    answer: 1,
    explanation: "Phải giữ nguyên hoặc nới lỏng hơn (Protected hoặc Public).",
  },
  {
    id: 1151,
    topic: "Abstract Class",
    question:
      "Mục đích của việc ẩn giấu chi tiết implementation trong Abstract Class là:",
    options: [
      "Tăng cường tính đa hình.",
      "Tăng cường tính kế thừa.",
      "Hạn chế sự phức tạp (Complexity) và chỉ hiển thị giao diện cần thiết.",
      "Buộc sử dụng fields `static`.",
    ],
    answer: 2,
    explanation: "Abstraction/Information Hiding: ẩn chi tiết phức tạp.",
  },
  {
    id: 1152,
    topic: "Abstract Class",
    question:
      "Trong Abstract Class, fields có thể là `public`, `protected`, `private` không?",
    options: [
      "Không, chỉ `public static final`.",
      "Có, như một class bình thường.",
      "Chỉ `private`.",
      "Chỉ `protected`.",
    ],
    answer: 1,
    explanation: "Abstract Class có fields với access modifier thông thường.",
  },
  {
    id: 1153,
    topic: "Abstract Class",
    question:
      "Sự khác biệt về cách sử dụng giữa Abstract Class và Interface là:",
    options: [
      "Interface dùng cho IS-A, Abstract Class dùng cho HAS-A.",
      "Abstract Class dùng cho IS-A (extends), Interface dùng cho định nghĩa vai trò (implements).",
      "Interface không thể kế thừa.",
      "Abstract Class không thể có constructor.",
    ],
    answer: 1,
    explanation: "Abstract Class cho IS-A, Interface cho vai trò/kiểu (role).",
  },
  {
    id: 1154,
    topic: "Abstract Method",
    question:
      "Nếu lớp con Concrete không implement Abstract Method, điều gì là kết quả trực tiếp?",
    options: [
      "Lỗi Biên dịch .",
      "Lỗi Runtime NullPointerException.",
      "Lỗi Runtime ClassCastException.",
      "Phương thức này được tự động gán giá trị `null`.",
    ],
    answer: 0,
    explanation: "Lỗi Biên dịch .",
  },
  {
    id: 1155,
    topic: "Abstract Class",
    question:
      "Khi Abstract Class được sử dụng làm kiểu tham chiếu đa hình, đây là cách để:",
    options: [
      "Buộc Downcasting.",
      "Cho phép đối tượng lớp con được coi là đối tượng Abstract Class.",
      "Ngăn chặn hoàn toàn truy cập phương thức.",
      "Chỉ sử dụng fields `static`.",
    ],
    answer: 1,
    explanation: "Đa hình: Lớp con là Abstract Class (IS-A).",
  },
  {
    id: 1156,
    topic: "Abstract Class",
    question: "Một Abstract Class có thể được khai báo là `public` không?",
    options: [
      "Không, luôn là `private`.",
      "Có.",
      "Chỉ khi nó không có Abstract Methods.",
      "Chỉ khi nó không có constructor.",
    ],
    answer: 1,
    explanation: "Class có thể là `public`.",
  },
  {
    id: 1157,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class `X` không có constructor mặc định và lớp con `Y` không gọi `super()`, trình biên dịch cố gắng gọi constructor nào?",
    options: [
      "Constructor `Y()`.",
      "Constructor mặc định của `X` (gây lỗi).",
      "Constructor có tham số của `X`.",
      "Constructor của lớp `Object`.",
    ],
    answer: 1,
    explanation: "Cố gắng gọi default constructor của lớp cha.",
  },
  {
    id: 1158,
    topic: "Abstract Method",
    question:
      "Trong Abstract Class, phương thức được khai báo là `abstract` có phải là `public` hoặc `protected` không?",
    options: [
      "Không, nó có thể là `private`.",
      "Có, nếu là `default` thì lớp con ở package khác không thể implement.",
      "Chỉ nếu nó trả về `Object`.",
      "Chỉ nếu nó là `final`.",
    ],
    answer: 1,
    explanation:
      "Thường là `public` hoặc `protected` để cho phép lớp con truy cập/implement.",
  },
  {
    id: 1159,
    topic: "Abstract Class",
    question: "Điều gì là SAI khi nói về việc sử dụng Abstract Class?",
    options: [
      "Nó giúp tránh code trùng lặp.",
      "Nó cho phép các lớp con thay đổi giao kèo (protocol).",
      "Nó được dùng để định nghĩa Abstract Factory Pattern.",
      "Nó không thể được khởi tạo.",
    ],
    answer: 1,
    explanation:
      "Abstract Class định nghĩa giao kèo, lớp con phải tuân theo (implement).",
  },
  {
    id: 1160,
    topic: "Abstract Method",
    question:
      "Nếu lớp con Concrete `C` muốn implement Abstract Method `m()`, nó phải cung cấp gì?",
    options: [
      "Từ khóa `abstract`.",
      "Danh sách tham số mới.",
      "Thân hàm (body).",
      "Từ khóa `final`.",
    ],
    answer: 2,
    explanation: "Phải cung cấp thân hàm.",
  },
  {
    id: 1161,
    topic: "Abstract Class",
    question:
      "Một Abstract Class có thể được sử dụng làm kiểu dữ liệu cho một biến cục bộ (Local Variable) không?",
    options: [
      "Không.",
      "Có, miễn là biến đó không được khởi tạo bằng `new` Abstract Class đó (ví dụ: `AbstractClass ref = null;`).",
      "Chỉ khi biến đó là `static`.",
      "Chỉ khi biến đó là `final`.",
    ],
    answer: 1,
    explanation: "Có thể sử dụng làm kiểu tham chiếu.",
  },
  {
    id: 1162,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Method được khai báo là `public abstract int getId()`, lớp con Concrete có thể implement nó bằng cách khai báo là `public String getId()` không?",
    options: [
      "Có, nếu `String` là lớp con của `int`.",
      "Không, vì kiểu trả về không tương thích, gây lỗi biên dịch.",
      "Chỉ khi lớp con là Abstract.",
      "Chỉ khi `getId()` là `private`.",
    ],
    answer: 1,
    explanation: "Kiểu trả về phải tương thích khi ghi đè.",
  },
  {
    id: 1163,
    topic: "Inheritance",
    question: "Lớp nào sau đây là bắt buộc phải được khai báo là Abstract?",
    options: [
      "Lớp có constructor có tham số.",
      "Lớp không kế thừa lớp nào.",
      "Lớp không có fields.",
      "Lớp có Abstract Methods.",
    ],
    answer: 3,
    explanation: "Nếu có Abstract Methods, phải là Abstract Class.",
  },
  {
    id: 1164,
    topic: "Abstract Class",
    question: "Điều gì là hợp lệ trong Abstract Class?",
    options: [
      "Khai báo `abstract` fields.",
      "Khai báo `abstract` constructor.",
      "Khai báo `final` methods.",
      "Khai báo `static abstract` methods.",
    ],
    answer: 2,
    explanation: "Abstract Class có thể có final methods.",
  },
  {
    id: 1165,
    topic: "Comparison",
    question:
      "Trong Abstract Factory Pattern, các Factory trừu tượng thường được định nghĩa bằng cấu trúc nào?",
    options: [
      "Concrete Class.",
      "Abstract Class hoặc Interface.",
      "Lớp Utility.",
      "Lớp `final`.",
    ],
    answer: 1,
    explanation:
      "Abstract Factory Pattern sử dụng Abstract Class hoặc Interface.",
  },
  {
    id: 1166,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class A có constructor `A(String name)`, lớp con B (Concrete) phải gọi constructor này bằng `super(name)` trong constructor của B. Điều này là để:",
    options: [
      "Tránh lỗi biên dịch do thiếu default constructor.",
      "Khởi tạo fields Abstract.",
      "Thực hiện đa kế thừa.",
      "Ngăn chặn ghi đè.",
    ],
    answer: 0,
    explanation: "Phải gọi constructor cha nếu không có default constructor.",
  },
  {
    id: 1167,
    topic: "Abstract Class",
    question:
      "Lớp nào sau đây thường được đặt tên chung chung và nằm ở vị trí cao trong cây kế thừa?",
    options: [
      "Interface.",
      "Abstract Class.",
      "Concrete Class.",
      "Lớp `main()`.",
    ],
    answer: 1,
    explanation: "Abstract Class (Super class/general class) nằm ở vị trí cao.",
  },
  {
    id: 1168,
    topic: "Abstract Method",
    question:
      "Nếu Abstract Class `A` có Abstract Method `m()`, và lớp con Abstract `B` kế thừa `A`, `B` có thể làm cho `m()` trở nên `protected` thay vì `public` không?",
    options: [
      "Không, không được phép hạn chế access modifier.",
      "Có, nếu `A` cho phép.",
      "Chỉ khi `m()` là `static`.",
      "Chỉ khi `B` là `final`.",
    ],
    answer: 0,
    explanation: "Không được hạn chế access modifier.",
  },
  {
    id: 1169,
    topic: "Abstract Class",
    question:
      "Nếu Abstract Class có phương thức `public abstract void process()`, lớp con Concrete phải implement nó bằng cách nào?",
    options: [
      "Bằng cách sử dụng cùng chữ ký và access modifier tối thiểu là `public`.",
      "Bằng cách khai báo nó là `private`.",
      "Bằng cách sử dụng từ khóa `final`.",
      "Bằng cách sử dụng `this.process()`.",
    ],
    answer: 0,
    explanation: "Phải giữ nguyên hoặc nới lỏng access modifier.",
  },
  {
    id: 1170,
    topic: "Abstract Class",
    question: "Điều gì là đúng về Abstract Class so với Interface?",
    options: [
      "Abstract Class có thể có constructor.",
      "Interface có thể có constructor.",
      "Abstract Class cho phép đa kế thừa.",
      "Interface không thể có fields.",
    ],
    answer: 0,
    explanation: "Abstract Class có thể có constructor.",
  },
  {
    id: 1171,
    topic: "Interface",
    type: "radio",
    question: "Trong Java, mục đích chính của Interface là gì?",
    options: [
      "Giải quyết vấn đề đa kế thừa (Multiple Inheritance) bị Java cấm đối với các class.",
      "Cung cấp một bản thiết kế với các phương thức có implementation mặc định.",
      "Giới hạn khả năng hiển thị của các thành viên trong gói (package).",
      "Đảm bảo rằng chỉ có một thể hiện (instance) của class tồn tại.",
    ],
    answer: 0,
    explanation:
      "Java giới thiệu các interface để giải quyết vấn đề đa kế thừa (Multiple Inheritance) [1, 2]. Interface được sử dụng để đạt được đa kế thừa [3, 4].",
  },
  {
    id: 1172,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một class cố gắng 'extend' nhiều hơn một class trong Java?",
    options: [
      "Nó được phép nếu các class đó đều là abstract.",
      "Lỗi thời gian chạy (Runtime error) do xung đột tên.",
      "Không được phép, gây ra lỗi biên dịch (Compile error).",
      "Được phép nếu sử dụng từ khóa 'interface'.",
    ],
    answer: 2,
    explanation:
      "Một hạn chế lớn trong Java là một class không thể mở rộng nhiều hơn một class. Nói cách khác, đa kế thừa (multiple inheritance) không được phép trong Java [5, 6].",
  },
  {
    id: 1173,
    topic: "Interface",
    type: "radio",
    question:
      "Vấn đề 'Deadly Diamond of Death' (DDD) mà Interface giúp giải quyết liên quan đến điều gì?",
    options: [
      "Vấn đề về quản lý bộ nhớ Heap.",
      "Khả năng tạo ra mơ hồ (ambiguity) nếu các lớp cơ sở có các phương thức tương tự.",
      "Vấn đề xung đột giữa các hằng số static.",
      "Vấn đề không thể tạo đối tượng từ abstract class.",
    ],
    answer: 1,
    explanation:
      "Đa kế thừa có thể gây ra sự mơ hồ (ambiguity) nếu các lớp cơ sở có các phương thức tương tự [6]. Interface giải quyết vấn đề DDD bằng cách làm cho tất cả các phương thức là abstract [7, 8].",
  },
  {
    id: 1174,
    topic: "Interface",
    type: "radio",
    question: "Interface được mô tả như là một loại class như thế nào?",
    options: [
      "Một class có thể được khởi tạo nhưng không thể được kế thừa.",
      "Một class trừu tượng 100% (100% abstract class).",
      "Một class chỉ chứa các phương thức static.",
      "Một class chỉ chứa các trường private.",
    ],
    answer: 1,
    explanation:
      "Interface là một class trừu tượng 100% [9-11]. Nó giống như một mặt tiền (façade) hoặc một dàn ý (outline) của một class tưởng tượng [12].",
  },
  {
    id: 1175,
    topic: "Interface",
    type: "radio",
    question:
      "Interface chủ yếu định nghĩa 'cái gì' (what) mà class nên làm, nhưng không định nghĩa 'cách làm' (how to do it). Điều này có nghĩa là gì?",
    options: [
      "Interface chỉ chứa các constructor.",
      "Interface chỉ liệt kê các phương thức mà không cung cấp code implementation.",
      "Các fields trong interface phải là mutable.",
      "Interface không thể chứa bất kỳ phương thức nào.",
    ],
    answer: 1,
    explanation:
      "Interface chỉ định nghĩa những gì cần phải làm nhưng không định nghĩa cách làm. Tức là interface liệt kê các phương thức mà phải được bao gồm trong class nhưng không cung cấp bất kỳ code implementation nào [12, 13].",
  },
  {
    id: 1176,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Java, một class có thể triển khai (implement) bao nhiêu interface?",
    options: [
      "Tối đa một interface.",
      "Tối đa hai interface.",
      "Bất kỳ số lượng interface nào.",
      "Chỉ khi nó không kế thừa bất kỳ class nào.",
    ],
    answer: 2,
    explanation: "Một class có thể triển khai nhiều interface [8, 14].",
  },
  {
    id: 1177,
    topic: "Interface",
    type: "radio",
    question:
      "Sự khác biệt cơ bản giữa việc 'extend' một class và 'implement' một interface trong Java là gì?",
    options: [
      "Có thể extend nhiều class nhưng chỉ implement một interface.",
      "Chỉ có thể extend một class, nhưng có thể implement nhiều interface.",
      "Cả hai đều bị hạn chế chỉ một lần sử dụng.",
      "Extend liên quan đến polymorphism, còn implement thì không.",
    ],
    answer: 1,
    explanation:
      "Java class chỉ có thể extend một class, nhưng có thể implement nhiều interface [8, 14, 15].",
  },
  {
    id: 1178,
    topic: "Interface",
    type: "radio",
    question:
      "Khi một class triển khai một interface, điều gì phải được đảm bảo?",
    options: [
      "Class đó phải được khai báo là abstract.",
      "Class đó phải là final.",
      "Class đó phải triển khai tất cả các phương thức trừu tượng trong interface.",
      "Class đó không được có bất kỳ trường (field) nào.",
    ],
    answer: 2,
    explanation:
      "Một class triển khai một interface phải triển khai tất cả các phương thức trong interface đó [4, 16].",
  },
  {
    id: 1179,
    topic: "Interface",
    type: "radio",
    question:
      "Interface được sử dụng để định nghĩa 'vai trò' (role) mà các class có thể đảm nhận, bất kể class đó nằm ở đâu trong cây kế thừa. Đây là ví dụ về tính chất nào?",
    options: ["Encapsulation", "Abstraction", "Tight Coupling", "Polymorphism"],
    answer: 3,
    explanation:
      "Interfaces là công cụ tối ưu cho tính đa hình (polymorphism), cho phép bạn đối xử với một đối tượng bằng vai trò mà nó đảm nhận, thay vì kiểu class mà nó được khởi tạo [17-19].",
  },
  {
    id: 1180,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `Caravan` cần có khả năng di chuyển (Movable) và sinh sống (Habitable), cú pháp nào là đúng để class Caravan làm được điều đó?",
    options: [
      "class Caravan extends Movable, Habitable",
      "class Caravan implements Movable, Habitable",
      "class Caravan extends Movable implements Habitable",
      "class Caravan extends Movable and Habitable",
    ],
    answer: 1,
    explanation:
      "Ví dụ về việc triển khai nhiều interface sử dụng từ khóa 'implements' và liệt kê các interface cách nhau bằng dấu phẩy: `public class Caravan implements Habitable, Movable` [13].",
  },
  {
    id: 1181,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa nào được sử dụng để chỉ ra rằng một class đang sử dụng các định nghĩa của một interface?",
    options: ["extends", "uses", "implements", "interface"],
    answer: 2,
    explanation:
      "Để triển khai một interface, ta sử dụng từ khóa `implements` [7, 8, 13].",
  },
  {
    id: 1182,
    topic: "Interface",
    type: "radio",
    question:
      "Trong cú pháp `class MyClass implements Interface1, Interface2`, điều gì xảy ra nếu `MyClass` không triển khai tất cả các phương thức của `Interface1` và `Interface2`?",
    options: [
      "Trình biên dịch Java sẽ tự động thêm các phương thức thiếu.",
      "Chương trình chạy bình thường nhưng có thể ném ra lỗi runtime.",
      "Gây ra lỗi biên dịch, trừ khi `MyClass` là một abstract class.",
      "Chỉ cần triển khai một trong hai interface.",
    ],
    answer: 2,
    explanation:
      "Một class triển khai một interface phải triển khai tất cả các phương thức trừu tượng của interface đó. Nếu không, class đó phải được khai báo là abstract [4, 16].",
  },
  {
    id: 1183,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class kế thừa một class (A) và triển khai một interface (B), thứ tự khai báo nào là đúng?",
    options: [
      "class MyClass implements B extends A",
      "class MyClass extends A implements B",
      "class MyClass implements A, B",
      "class MyClass extends A and B",
    ],
    answer: 1,
    explanation:
      "Thứ tự đúng là `extends` trước, sau đó là `implements`. Ví dụ: `public class Dog extends Canine implements Pet` [7, 20].",
  },
  {
    id: 1184,
    topic: "Interface",
    type: "radio",
    question: "Một interface có thể 'extend' (mở rộng) những gì?",
    options: [
      "Một class trừu tượng (abstract class).",
      "Một hoặc nhiều interface khác.",
      "Một class cụ thể (concrete class).",
      "Nó không thể extend bất cứ thứ gì.",
    ],
    answer: 1,
    explanation:
      "Một interface có thể extend một hoặc nhiều interface khác [4, 21].",
  },
  {
    id: 1185,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là SAI khi nói về Interface?",
    options: [
      "Interface định nghĩa hành vi mà một class cam kết thực hiện.",
      "Bạn không thể tạo một thể hiện (instance) của một interface.",
      "Interface có thể chứa các constructor.",
      "Interface giúp đạt được sự phân ly (decoupling) tốt hơn.",
    ],
    answer: 2,
    explanation:
      "Interface không thể được khởi tạo [4, 22]. Interface là 100% abstract class [9, 10] và không có constructors.",
  },
  {
    id: 1186,
    topic: "Interface",
    type: "radio",
    question:
      "Mặc dù Java không cho phép đa kế thừa giữa các class, nhưng việc triển khai nhiều interface giúp đạt được lợi ích nào của đa kế thừa?",
    options: [
      "Tái sử dụng code cơ sở.",
      "Sự linh hoạt trong định nghĩa vai trò và hành vi (polymorphism).",
      "Khởi tạo đối tượng mà không cần constructor.",
      "Chia sẻ các trường dữ liệu non-static.",
    ],
    answer: 1,
    explanation:
      "Interface cung cấp nhiều lợi ích đa hình (polymorphic benefits) của đa kế thừa [11]. Interface là công cụ tối ưu cho tính đa hình [17].",
  },
  {
    id: 1187,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, để chỉ định rằng một kiểu T phải là một subtype của một class hoặc interface, ta sử dụng từ khóa nào?",
    options: ["implements", "super", "is", "extends"],
    answer: 3,
    explanation:
      "Trong Generics, từ khóa 'extends' thực sự có nghĩa là 'is-a', và hoạt động cho CẢ class và interface. Ví dụ, `<T extends Comparable<T>>` [23, 24].",
  },
  {
    id: 1188,
    topic: "Interface",
    type: "radio",
    question:
      "Interface được mô tả là một 'hợp đồng' (contract). Hợp đồng này ràng buộc điều gì đối với class triển khai?",
    options: [
      "Định nghĩa tất cả các trường là private.",
      "Phải cung cấp định nghĩa cho tất cả các phương thức trừu tượng của interface.",
      "Chỉ sử dụng static methods.",
      "Không được kế thừa bất kỳ class nào khác.",
    ],
    answer: 1,
    explanation:
      "Class triển khai interface phải cung cấp implementation cho tất cả các phương thức abstract, đó là hợp đồng của nó [16, 20, 25].",
  },
  {
    id: 1189,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface được định nghĩa, nhưng không có class nào triển khai nó, điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Lỗi runtime.",
      "Không có vấn đề gì, nhưng interface đó không hữu ích.",
      "Interface được tự động chuyển đổi thành abstract class.",
    ],
    answer: 2,
    explanation:
      "Interface là một khai báo hợp lệ độc lập [26]. Mặc dù nó không hữu ích cho đến khi được triển khai, nhưng nó không gây ra lỗi.",
  },
  {
    id: 1190,
    topic: "Interface",
    type: "radio",
    question:
      "Trong ngữ cảnh của Pattern Design, Interface được sử dụng rộng rãi trong những mẫu nào?",
    options: [
      "Singleton, Builder.",
      "Adapter, Strategy, Abstract Factory.",
      "Constructor, Copy Constructor.",
      "Exception Handling.",
    ],
    answer: 1,
    explanation:
      "Interface xuất hiện trong Abstract Factory Pattern (interface `Car`, `Truck`, `VehicleFactory`) [27, 28], Adapter Pattern [29], Composite Pattern (`FileSystemItem`) [30], Decorator (`Coffee`) [31], và Strategy Pattern (`PaymentStrategy`) [32, 33].",
  },
  {
    id: 1191,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng một interface như kiểu tham chiếu (reference type) là gì?",
    options: [
      "Để giới hạn tính đa hình.",
      "Để đảm bảo class đó chỉ có thể kế thừa từ một class.",
      "Để cho phép tham chiếu đó trỏ đến bất kỳ đối tượng nào của class triển khai interface đó.",
      "Để ngăn chặn việc tạo ra các phương thức trùng lặp.",
    ],
    answer: 2,
    explanation:
      "Interface là công cụ tối ưu cho polymorphism. Khi sử dụng interface làm kiểu polymorphic, đối tượng có thể đến từ bất cứ đâu trong cây kế thừa miễn là nó implement interface đó [18, 19].",
  },
  {
    id: 1192,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `List` là một interface, và `ArrayList` là một class triển khai `List`, khai báo nào sau đây là hợp lệ (Upcasting)?",
    options: [
      "ArrayList<String> list = new List<String>();",
      "List<String> list = new ArrayList<String>();",
      "List list = new Interface();",
      "ArrayList list = new List();",
    ],
    answer: 1,
    explanation:
      "List là một interface, ArrayList là một class triển khai nó. Khai báo `List<String> list = new ArrayList<String>()` là hợp lệ (Polymorphic reference) [34, 35].",
  },
  {
    id: 1193,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Collection` trong Java Collection Framework đóng vai trò gì?",
    options: [
      "Một class cụ thể để lưu trữ dữ liệu.",
      "Một abstract class cơ sở cho tất cả các map.",
      "Một root interface định nghĩa các hoạt động cơ bản cho tất cả các kiểu collection.",
      "Một lớp wrapper cho kiểu dữ liệu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Collection là một root interface trong Java collection framework. Nó định nghĩa các hoạt động cơ bản mà tất cả các kiểu collection (như lists, sets, queues) nên triển khai [36].",
  },
  {
    id: 1194,
    topic: "Interface",
    type: "radio",
    question: "Interface `Iterator` trong Java có mục đích gì?",
    options: [
      "Đảm bảo sự an toàn luồng (thread safety).",
      "Cho phép một chương trình duyệt qua một collection và loại bỏ các phần tử trong khi duyệt.",
      "Định nghĩa các hàm toán học tĩnh.",
      "Cung cấp các phương thức I/O cơ bản.",
    ],
    answer: 1,
    explanation:
      "Iterator cho phép một chương trình duyệt qua một collection và loại bỏ các phần tử khỏi nó trong quá trình lặp [37].",
  },
  {
    id: 1195,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `java.io.Serializable` là một 'marker interface'. Điều gì xảy ra khi một class implement nó?",
    options: [
      "Class đó phải triển khai phương thức `serialize()`.",
      "Class đó có thể được chuyển đổi trạng thái thành byte stream (Serialization).",
      "Class đó phải khai báo tất cả các trường là `transient`.",
      "Class đó tự động kế thừa tất cả các phương thức của `Object`.",
    ],
    answer: 1,
    explanation:
      "Để làm cho một đối tượng Java có thể tuần tự hóa, ta cần triển khai marker interface `java.io.Serializable`. Việc này chuyển đổi trạng thái của đối tượng thành byte stream [38, 39].",
  },
  {
    id: 1196,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng interface để đạt được đa kế thừa trong Java?",
    options: [
      "Nó cho phép class con kế thừa implementation code từ nhiều class cha.",
      "Nó chỉ cho phép class con kế thừa các định nghĩa phương thức (chứ không phải implementation) từ nhiều nguồn.",
      "Nó bị hạn chế chỉ sử dụng cho các trường dữ liệu.",
      "Nó chỉ hoạt động khi sử dụng Generics.",
    ],
    answer: 1,
    explanation:
      "Interface giải quyết vấn đề đa kế thừa bằng cách định nghĩa các phương thức trừu tượng, buộc lớp triển khai phải cung cấp implementation, tránh xung đột [7, 12].",
  },
  {
    id: 1197,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `A` implement interface `I`, và class `B` extend `A`. Thì `B` có ngầm định implement `I` không?",
    options: [
      "Có, thông qua kế thừa.",
      "Không, `B` phải khai báo implement `I` rõ ràng.",
      "Chỉ khi `A` là abstract.",
      "Chỉ khi `I` là abstract.",
    ],
    answer: 0,
    explanation:
      "Nếu class cha implement một interface, class con kế thừa hợp đồng đó và ngầm định implement interface đó (Do class con 'IS-A' class cha) [40, 41].",
  },
  {
    id: 1198,
    topic: "Interface",
    type: "radio",
    question:
      "Việc thiết kế và mã hóa theo interface (designing and coding to interfaces) mang lại lợi ích gì?",
    options: [
      "Giảm tính linh hoạt và khả năng mở rộng.",
      "Tăng cường sự kết nối chặt chẽ giữa các modules.",
      "Tối ưu hóa bộ nhớ cho các trường static.",
      "Tạo ra code linh hoạt hơn và dễ dàng mở rộng trong tương lai.",
    ],
    answer: 3,
    explanation:
      "Interfaces được sử dụng để đạt được tính linh hoạt và khả năng mở rộng cao hơn [9, 17, 42].",
  },
  {
    id: 1199,
    topic: "Interface",
    type: "radio",
    question:
      "Trong cú pháp `List<? extends Number> list`, dấu wildcard `?` được sử dụng để làm gì?",
    options: [
      "Chỉ ra rằng List chỉ có thể chứa các đối tượng của kiểu Number.",
      "Chỉ ra một kiểu chưa biết phải là kiểu con của Number (Upper bounded wildcard).",
      "Yêu cầu List phải triển khai interface `Number`.",
      "Tạo một List không thể thay đổi.",
    ],
    answer: 1,
    explanation:
      "Wildcard `?` theo sau `extends` và `BoundingType` (ví dụ: List<? extends Number>) chỉ ra rằng kiểu chưa biết phải là kiểu con của BoundingType [43, 44].",
  },
  {
    id: 1200,
    topic: "Interface",
    type: "radio",
    question: "Interface `Comparable<T>` được sử dụng để làm gì?",
    options: [
      "Đảm bảo class đó có thể được tuần tự hóa.",
      "Định nghĩa cách thức so sánh giữa hai đối tượng của cùng một class.",
      "Đảm bảo class đó có thể được chạy trên một luồng (thread) riêng.",
      "Định nghĩa các hàm toán học.",
    ],
    answer: 1,
    explanation:
      "Interface Comparable bao gồm phương thức CompareTo(), được sử dụng để cho phép bất kỳ class nào mô tả cách so sánh hai đối tượng của class đó với nhau [22, 45-47].",
  },
  {
    id: 1201,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `compareTo()` trong interface `Comparable` trả về một số nguyên dương khi nào?",
    options: [
      "Đối tượng 'this' được coi là nhỏ hơn đối tượng được chỉ định.",
      "Đối tượng 'this' được coi là bằng đối tượng được chỉ định.",
      "Đối tượng 'this' được coi là lớn hơn đối tượng được chỉ định.",
      "Luôn luôn.",
    ],
    answer: 2,
    explanation:
      "Nếu đối tượng 'This' được coi là lớn hơn đối tượng 'specified', phương thức nên trả về một số nguyên dương [48].",
  },
  {
    id: 1202,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `compareTo()` trong interface `Comparable` trả về số 0 khi nào?",
    options: [
      "Đối tượng 'this' được coi là bằng đối tượng được chỉ định.",
      "Đối tượng 'this' là null.",
      "Đối tượng 'specified' là null.",
      "Luôn luôn.",
    ],
    answer: 0,
    explanation:
      "Nếu đối tượng 'This' được coi là bằng đối tượng 'specified', phương thức nên trả về Zero [48].",
  },
  {
    id: 1203,
    topic: "Interface",
    type: "radio",
    question:
      "Tại sao việc triển khai `Comparable` lại hữu ích, đặc biệt là khi làm việc với Collections?",
    options: [
      "Nó cho phép Collections có thể lưu trữ các kiểu dữ liệu nguyên thủy.",
      "Nó cho phép Collections có thể được sắp xếp (sorting) hoặc tìm kiếm (searching) các đối tượng của kiểu đó.",
      "Nó đảm bảo rằng Collections luôn sử dụng Generics.",
      "Nó ngăn chặn ngoại lệ `NullPointerException`.",
    ],
    answer: 1,
    explanation:
      "Việc này trở nên đặc biệt hữu ích khi sắp xếp hoặc tìm kiếm các đối tượng của kiểu đó [45, 47, 49].",
  },
  {
    id: 1204,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Comparator` (khác với `Comparable`) có phương thức chính là gì?",
    options: ["run()", "equals()", "compare()", "sort()"],
    answer: 2,
    explanation: "Interface Comparator có phương thức `compare()` [50, 51].",
  },
  {
    id: 1205,
    topic: "Interface",
    type: "radio",
    question: "Cú pháp để khai báo một interface mới trong Java là gì?",
    options: [
      "public abstract interface MyInterface {}",
      "public class MyInterface {}",
      "public interface MyInterface {}",
      "public new interface MyInterface {}",
    ],
    answer: 2,
    explanation:
      "Khai báo interface sử dụng từ khóa `interface` thay vì `class` [8, 20, 52].",
  },
  {
    id: 1206,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai một interface nhưng không triển khai hết các phương thức trừu tượng, điều gì xảy ra?",
    options: [
      "Lớp đó được tự động đặt là `final`.",
      "Lớp đó phải được khai báo là `abstract`.",
      "Lỗi thời gian chạy.",
      "Phương thức thiếu sẽ được bỏ qua.",
    ],
    answer: 1,
    explanation:
      "Nếu một class có dù chỉ một phương thức abstract, nó phải được đánh dấu là `abstract` [53]. Nếu không triển khai hết các phương thức của interface thì các phương thức còn lại là abstract [4, 16].",
  },
  {
    id: 1207,
    topic: "Interface",
    type: "radio",
    question:
      "Lớp `DListImpStack` trong nguồn tài liệu được định nghĩa để làm gì trong ví dụ Adapter Pattern?",
    options: [
      "Kế thừa `Stack` và triển khai `DList`.",
      "Triển khai cả `DList` và `Stack`.",
      "Triển khai `Stack` interface bằng cách sử dụng chức năng của class `DList`.",
      "Chỉ sử dụng các phương thức của `DList`.",
    ],
    answer: 2,
    explanation:
      "Ví dụ Adapter Pattern: `class DListImpStack extends DList implements Stack`. Class này thích ứng class DList với interface Stack [29, 54].",
  },
  {
    id: 1208,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class `A` implement `I1` và `I2`, và cả hai interface đều có phương thức trừu tượng `void process()`. Điều gì xảy ra?",
    options: [
      "Lỗi biên dịch.",
      "Class `A` phải triển khai hai phiên bản của `process()`, mỗi phiên bản cho một interface.",
      "Class `A` chỉ cần triển khai một phiên bản của `process()` để đáp ứng cả hai hợp đồng.",
      "Class `A` phải khai báo `process()` là `default`.",
    ],
    answer: 2,
    explanation:
      "Đây là lợi ích của interface: tránh DDD. Class `A` cung cấp một implementation duy nhất cho phương thức trừu tượng đó, đáp ứng hợp đồng của cả hai interface [7, 25].",
  },
  {
    id: 1209,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, `Pair<Animal>` và `Pair<Cat>` có mối quan hệ kế thừa nào không?",
    options: [
      "Có, `Pair<Cat>` là subtype của `Pair<Animal>`.",
      "Có, `Pair<Animal>` là subtype của `Pair<Cat>`.",
      "Không có mối quan hệ kế thừa nào giữa hai kiểu generic khác nhau này.",
      "Chỉ khi cả hai đều implement một interface chung.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: `Pair<Animal>` và `Pair<Cat>`) [55].",
  },
  {
    id: 1210,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là mục tiêu của việc sử dụng Interface trong Design Patterns như Strategy Pattern?",
    options: [
      "Định nghĩa các trường `static final`.",
      "Cho phép thay đổi thuật toán (behavior) của một đối tượng một cách linh hoạt tại thời điểm chạy.",
      "Bắt buộc tất cả các phương thức phải là private.",
      "Hạn chế class khỏi việc kế thừa.",
    ],
    answer: 1,
    explanation:
      "Strategy Pattern định nghĩa một nhóm các thuật toán, đóng gói mỗi thuật toán trong một class triển khai interface, cho phép chọn hành vi linh hoạt tại runtime [32, 33, 56].",
  },
  {
    id: 1211,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa `implements` có thể được sử dụng trong khai báo của những loại entity nào trong Java?",
    options: [
      "Chỉ Class.",
      "Chỉ Interface.",
      "Class và Abstract Class.",
      "Class, Interface và Enum.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `implements` được sử dụng bởi các class hoặc abstract class để cam kết thực hiện hợp đồng của một hoặc nhiều interface [7, 8, 13].",
  },
  {
    id: 1212,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng một interface để định nghĩa các hằng số là gì?",
    options: [
      "Để các hằng số đó được chia sẻ bởi tất cả các class mà implement interface đó.",
      "Để đảm bảo rằng các hằng số có thể được thay đổi trong runtime.",
      "Để giới hạn phạm vi của các hằng số.",
      "Đây là một cách làm tồi và nên tránh.",
    ],
    answer: 0,
    explanation:
      "Tất cả các trường trong interface đều ngầm định là `public static final` [4, 57], do đó chúng là các hằng số được chia sẻ bởi bất kỳ class nào sử dụng interface đó.",
  },
  {
    id: 1213,
    topic: "Interface",
    type: "radio",
    question: "Điều gì KHÔNG được phép đối với một interface trong Java?",
    options: [
      "Khai báo các phương thức trừu tượng.",
      "Mở rộng nhiều interface khác.",
      "Chứa các trường dữ liệu non-static.",
      "Chứa các phương thức `default` (từ JDK 8).",
    ],
    answer: 2,
    explanation:
      "Tất cả các trường trong interface đều ngầm định là `static` (cùng với `public` và `final`) [4, 57]. Do đó, nó không thể chứa trường dữ liệu non-static.",
  },
  {
    id: 1214,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, một class được phép triển khai một interface mà không cần khai báo là abstract?",
    options: [
      "Chỉ khi interface đó không có phương thức trừu tượng nào.",
      "Chỉ khi nó triển khai tất cả các phương thức trừu tượng được định nghĩa trong interface.",
      "Chỉ khi nó sử dụng `default` method.",
      "Không bao giờ.",
    ],
    answer: 1,
    explanation:
      "Class triển khai interface phải triển khai tất cả các phương thức trừu tượng trong interface đó [4, 16].",
  },
  {
    id: 1215,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu hai interface, `I1` và `I2`, đều có một trường `MAX_VALUE` (là `public static final`), và class `C` implement cả `I1` và `I2`. Làm thế nào để truy cập `MAX_VALUE`?",
    options: [
      "Chỉ cần gọi `C.MAX_VALUE`.",
      "Phải sử dụng tên interface đủ điều kiện, ví dụ: `I1.MAX_VALUE`.",
      "Lỗi biên dịch do xung đột tên.",
      "Chỉ truy cập được bên trong class `C`.",
    ],
    answer: 1,
    explanation:
      "Mặc dù các trường trong interface là static và có thể được truy cập thông qua class triển khai, nhưng nếu có xung đột tên từ hai interface (xung đột là không thể tránh khỏi vì cả hai đều là `static`), bạn phải sử dụng tên interface để phân biệt rõ ràng, ví dụ: `I1.MAX_VALUE` (Suy luận từ tính chất `static` và yêu cầu giải quyết ambiguity).",
  },
  {
    id: 1216,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất của Interface mà cho phép các class không liên quan về mặt kế thừa vẫn có thể được đối xử như cùng một kiểu (type) thông qua polymorphism là gì?",
    options: [
      "Sử dụng `final` methods.",
      "Định nghĩa một hợp đồng hành vi chung (common contract).",
      "Yêu cầu các trường là `private`.",
      "Hạn chế việc ép kiểu.",
    ],
    answer: 1,
    explanation:
      "Interfaces cho phép các class từ các cây kế thừa khác nhau (`Dog` và `RoboDog`) được đối xử như cùng một kiểu (`Pet`) thông qua việc triển khai interface [18, 58].",
  },
  {
    id: 1217,
    topic: "Interface",
    type: "radio",
    question: "Interface `List` trong Java là một ví dụ về gì?",
    options: [
      "Một class concrete.",
      "Một kiểu dữ liệu nguyên thủy.",
      "Một interface định nghĩa cấu trúc mảng động (dynamic array structure).",
      "Một lớp wrapper.",
    ],
    answer: 2,
    explanation:
      "List trong Java là một interface hoạt động tương tự như một mảng [36]. Nó là một trong nhiều interface mà Java Collection Framework cung cấp [59].",
  },
  {
    id: 1218,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Queue` định nghĩa những phương thức quan trọng nào mà các class triển khai nó phải thực hiện?",
    options: [
      "push() và pop()",
      "hasNext() và next()",
      "add() và poll()",
      "get() và set()",
    ],
    answer: 2,
    explanation:
      "Interface Queue định nghĩa hai phương thức quan trọng phải được triển khai bởi tất cả các class triển khai Queue: `add(E element)` (chèn phần tử) và `poll()` (truy xuất và loại bỏ đầu hàng đợi) [60].",
  },
  {
    id: 1219,
    topic: "Interface",
    type: "radio",
    question:
      "Lớp nào sau đây là lớp phổ biến triển khai cả interface `Queue` và `Deque`?",
    options: ["Array", "String", "LinkedList", "HashMap"],
    answer: 2,
    explanation:
      "Java cung cấp một số class triển khai interface Queue và Deque, phổ biến nhất là ArrayDeque hoặc LinkedList [61].",
  },
  {
    id: 1220,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng interface làm kiểu tham chiếu cho các tham số phương thức?",
    options: [
      "Nó giới hạn phương thức đó chỉ chấp nhận một kiểu đối tượng duy nhất.",
      "Nó cho phép phương thức đó chấp nhận bất kỳ đối tượng nào triển khai interface đó.",
      "Nó yêu cầu ép kiểu thủ công (manual casting) trước khi gọi phương thức.",
      "Nó chỉ hoạt động với các class trong cùng một package.",
    ],
    answer: 1,
    explanation:
      "Nếu bạn sử dụng interface làm kiểu polymorphic, bạn có thể truyền bất cứ thứ gì implement interface đó [17].",
  },
  {
    id: 1221,
    topic: "Interface",
    type: "radio",
    question: "Keyword `implements` được sử dụng để làm gì?",
    options: [
      "Để kế thừa các phương thức trừu tượng và không trừu tượng từ một abstract class.",
      "Để chỉ định rằng class cam kết cung cấp định nghĩa cho các phương thức trừu tượng của interface.",
      "Để gọi constructor của interface.",
      "Để khai báo một trường là hằng số.",
    ],
    answer: 1,
    explanation:
      "Sử dụng từ khóa `implements` để chỉ định rằng một class đang triển khai một interface [7, 8].",
  },
  {
    id: 1222,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `I` là một interface và `C` là một class. Khai báo nào là ví dụ cho việc `C` triển khai `I`?",
    options: [
      "class C extends I {}",
      "class C includes I {}",
      "class C implements I {}",
      "interface C implements I {}",
    ],
    answer: 2,
    explanation:
      "Cú pháp để triển khai interface là sử dụng từ khóa `implements`, ví dụ: `Dog implements Pet` [8].",
  },
  {
    id: 1223,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một class triển khai hai interface khác nhau có cùng một phương thức trừu tượng (cùng tên, cùng chữ ký)?",
    options: [
      "Class đó phải triển khai phương thức đó hai lần.",
      "Chỉ cần triển khai phương thức đó một lần để đáp ứng cả hai interface.",
      "Lỗi thời gian chạy (Runtime Exception).",
      "Cần sử dụng từ khóa `super` để phân biệt.",
    ],
    answer: 1,
    explanation:
      "Class chỉ cần triển khai phương thức đó một lần, tránh được sự mơ hồ (ambiguity) mà đa kế thừa bằng class gây ra [7].",
  },
  {
    id: 1224,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa `implements` có thể xuất hiện bao nhiêu lần trong khai báo một class?",
    options: [
      "Một lần, theo sau là danh sách các interface được phân tách bằng dấu phẩy.",
      "Nhiều lần, mỗi lần cho một interface.",
      "Không thể xuất hiện nếu class đó đã extend một class khác.",
      "Chỉ xuất hiện nếu class đó là abstract.",
    ],
    answer: 0,
    explanation:
      "Cú pháp chuẩn cho phép một lần sử dụng `implements` theo sau là danh sách các interface [13, 14].",
  },
  {
    id: 1225,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `A` implement `I`, và ta khai báo `I ref = new A()`. Đây là ví dụ về kiểu tham chiếu nào?",
    options: [
      "Primitive type.",
      "Object reference of superclass type.",
      "Polymorphic reference of interface type.",
      "Local variable.",
    ],
    answer: 2,
    explanation:
      "Đây là Polymorphism: sử dụng một tham chiếu kiểu interface để trỏ đến một đối tượng của class triển khai nó [18, 62].",
  },
  {
    id: 1226,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, nếu ta có `ArrayList<? extends I>`, điều này có nghĩa là `ArrayList` có thể chứa các đối tượng có kiểu là gì?",
    options: [
      "Chỉ kiểu `I`.",
      "Kiểu `I` hoặc bất kỳ kiểu siêu lớp nào của `I`.",
      "Kiểu `I` hoặc bất kỳ kiểu con nào của `I`.",
      "Bất kỳ kiểu nào.",
    ],
    answer: 2,
    explanation:
      "`? extends I` (Upper bounded wildcard) cho phép kiểu đó là `I` hoặc bất kỳ kiểu con nào của `I` [43, 44]. (Lưu ý: trong generics, 'extends' được dùng cho cả class và interface) [24].",
  },
  {
    id: 1227,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` triển khai interface `I` và `I` có phương thức trừu tượng `void action()`. Việc triển khai `action()` trong `C` nên có access modifier nào?",
    options: ["private", "protected", "package-private (default)", "public"],
    answer: 3,
    explanation:
      "Tất cả các phương thức trừu tượng trong interface đều ngầm định là `public` [4, 16]. Khi triển khai, phương thức không được giới hạn quyền truy cập hơn so với trong interface, do đó nó phải là `public`.",
  },
  {
    id: 1228,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là KHÔNG THỂ xảy ra khi sử dụng từ khóa `implements`?",
    options: [
      "Một class implement nhiều interface.",
      "Một class implement một interface và extend một class.",
      "Một interface implement một interface khác.",
      "Một class concrete implement một interface nhưng không override một phương thức trừu tượng.",
    ],
    answer: 2,
    explanation:
      "Interface chỉ có thể `extend` một hoặc nhiều interface khác [4]. Chỉ class mới sử dụng `implements`.",
  },
  {
    id: 1229,
    topic: "Interface",
    type: "radio",
    question: "Interface `Runnable` trong Java được dùng để làm gì?",
    options: [
      "Đảm bảo đối tượng có thể so sánh được.",
      "Cho phép đối tượng chạy phương thức của nó trong một luồng (thread) thực thi riêng.",
      "Định nghĩa các hàm I/O.",
      "Đại diện cho một collection không có thứ tự.",
    ],
    answer: 1,
    explanation:
      "Để tạo một job cho thread của bạn, hãy implement interface `Runnable`. Nó có phương thức `run()` [18, 63].",
  },
  {
    id: 1230,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `java.io.Serializable`, nó thường được gọi là gì?",
    options: [
      "An Abstract class.",
      "A Polymorphic class.",
      "A Marker class.",
      "A Runnable class.",
    ],
    answer: 2,
    explanation:
      "`java.io.Serializable` là một 'marker interface' [38, 39] (Dù nguồn không gọi class là 'Marker Class', nhưng interface là 'Marker Interface').",
  },
  {
    id: 1231,
    topic: "Interface",
    type: "radio",
    question:
      "Keyword `implements` cho phép các class làm gì liên quan đến Generics?",
    options: [
      "Định nghĩa các kiểu dữ liệu nguyên thủy.",
      "Sử dụng wildcards cho các tham số kiểu.",
      "Hạn chế tham số kiểu `T` trong Generics methods.",
      "Khuyến khích sử dụng Object thay vì Generics.",
    ],
    answer: 2,
    explanation:
      "Trong Bounded Type Parameters, cú pháp `<T extends superClassName & Interface>` cho phép giới hạn kiểu `T` phải implement một interface cụ thể [23, 24].",
  },
  {
    id: 1232,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `A` implement `I1` và `B` implement `I1`. Ta có thể làm gì với các đối tượng `a` và `b`?",
    options: [
      "Ta có thể gán `a = b` (polymorphism).",
      "Ta có thể coi cả `a` và `b` là kiểu `I1`.",
      "Ta phải sử dụng Downcasting.",
      "Không có mối quan hệ nào giữa `a` và `b`.",
    ],
    answer: 1,
    explanation:
      "Vì cả hai đều triển khai cùng một interface, chúng có thể được đối xử như cùng một kiểu polymorphic `I1` [17, 18].",
  },
  {
    id: 1233,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG khi một interface extend một interface khác?",
    options: [
      "Interface con chỉ kế thừa các trường `static final`.",
      "Interface con kế thừa tất cả các phương thức và hằng số của interface cha.",
      "Interface con phải triển khai tất cả các phương thức của interface cha.",
      "Interface con phải định nghĩa lại tất cả các hằng số.",
    ],
    answer: 1,
    explanation:
      "Interface con kế thừa tất cả các khai báo phương thức trừu tượng và các trường hằng số. (Kế thừa hợp đồng, không phải implementation code) [4].",
  },
  {
    id: 1234,
    topic: "Interface",
    type: "radio",
    question: "Sự khác biệt về mục đích giữa `implements` và `extends` là gì?",
    options: [
      "`implements` cho phép kế thừa code, `extends` định nghĩa hợp đồng.",
      "`extends` cho phép kế thừa code, `implements` định nghĩa hợp đồng hành vi (role).",
      "Cả hai đều dùng để kế thừa code.",
      "Cả hai đều dùng để định nghĩa hằng số.",
    ],
    answer: 1,
    explanation:
      "`extends` dùng để kế thừa code và định nghĩa quan hệ IS-A [15]. `implements` định nghĩa vai trò (role) mà class có thể chơi, thông qua một hợp đồng [15].",
  },
  {
    id: 1235,
    topic: "Interface",
    type: "radio",
    question:
      "Khi một class C implement interface I, và I có một `default` method `dm()`. Class C có bắt buộc phải override `dm()` không?",
    options: [
      "Có, luôn luôn.",
      "Không, vì phương thức `default` đã có implementation.",
      "Chỉ khi phương thức đó là `public`.",
      "Chỉ khi phương thức đó là `static`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` (từ JDK 8) đã có implementation, nên class triển khai không bắt buộc phải override [4, 64].",
  },
  {
    id: 1236,
    topic: "Interface",
    type: "radio",
    question:
      "Cú pháp cho một class triển khai đồng thời class `A` và interface `I` là gì?",
    options: [
      "class C implements I, A",
      "class C extends A implements I",
      "class C implements A extends I",
      "class C uses A, I",
    ],
    answer: 1,
    explanation: "Thứ tự khai báo là `extends` sau đó là `implements` [7, 14].",
  },
  {
    id: 1237,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class `C` triển khai một interface `I`, và ta cần gọi một phương thức trên đối tượng `c` của `C`. Trình biên dịch sẽ kiểm tra điều gì?",
    options: [
      "Nó kiểm tra class `C` có phải là `final` không.",
      "Nó kiểm tra phương thức có tồn tại trong interface `I` hay không (nếu tham chiếu là kiểu `I`).",
      "Nó chỉ kiểm tra các trường `static`.",
      "Nó kiểm tra tất cả các phương thức trong `Object`.",
    ],
    answer: 1,
    explanation:
      "Bạn chỉ có thể gọi các phương thức trên một đối tượng nếu các phương thức đó nằm trong class (hoặc interface) được sử dụng làm kiểu biến tham chiếu [65, 66].",
  },
  {
    id: 1238,
    topic: "Interface",
    type: "radio",
    question:
      "Sử dụng interface thay vì abstract class để định nghĩa một tập hợp hành vi chung có lợi ích gì khi lớp triển khai muốn kế thừa từ một nguồn khác?",
    options: [
      "Abstract class cho phép kế thừa nhiều nguồn, interface thì không.",
      "Java chỉ cho phép kế thừa một class (abstract hoặc concrete), nhưng cho phép triển khai nhiều interface.",
      "Interface không thể có các phương thức abstract.",
      "Abstract class không thể có các trường static final.",
    ],
    answer: 1,
    explanation:
      "Java chỉ cho phép kế thừa một class duy nhất, nhưng cho phép triển khai nhiều interface, giúp linh hoạt hơn trong việc định nghĩa hành vi [8, 14, 15].",
  },
  {
    id: 1239,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `Comparable`, nó sẽ được sử dụng đặc biệt khi nào trong các cấu trúc dữ liệu như `TreeSet`?",
    options: [
      "Khi lưu trữ các kiểu dữ liệu nguyên thủy.",
      "Khi cần xác định thứ tự tự nhiên (natural ordering) của các phần tử.",
      "Khi cần lưu trữ các cặp key-value.",
      "Khi cần sử dụng các phương thức `default`.",
    ],
    answer: 1,
    explanation:
      "`Comparable` được dùng để xác định thứ tự tự nhiên (natural ordering). `TreeSet` sử dụng `Comparable` (hoặc `Comparator`) để sắp xếp các phần tử [47, 67].",
  },
  {
    id: 1240,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa `implements` giúp lớp triển khai đạt được tính chất OOP nào liên quan đến việc che giấu chi tiết triển khai?",
    options: [
      "Polymorphism.",
      "Encapsulation (Đóng gói).",
      "Abstraction (Trừu tượng).",
      "Inheritance (Kế thừa).",
    ],
    answer: 2,
    explanation:
      "Interface định nghĩa 'cái gì' (what) mà không định nghĩa 'cách làm' (how) [12], đó là một hình thức mạnh mẽ của Abstraction, che giấu chi tiết triển khai bên dưới [68].",
  },
  {
    id: 1241,
    topic: "Interface",
    type: "radio",
    question:
      "Điều kiện nào sau đây phải được thỏa mãn khi một class triển khai một interface?",
    options: [
      "Nó phải khai báo constructor `private`.",
      "Nó phải khai báo tất cả các trường là `public`.",
      "Nó phải cung cấp implementation cho tất cả các phương thức abstract kế thừa.",
      "Nó phải sử dụng annotation `@Override` cho tất cả các phương thức.",
    ],
    answer: 2,
    explanation:
      "Một class triển khai một interface phải triển khai tất cả các phương thức trong interface đó [4, 16].",
  },
  {
    id: 1242,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu Interface `I` có phương thức `void print()`, và class `C` implement `I` nhưng định nghĩa `print()` là `protected void print()`. Điều gì xảy ra?",
    options: [
      "Chạy bình thường.",
      "Lỗi biên dịch vì `print()` trong `C` giảm quyền truy cập so với `public` trong `I`.",
      "Lỗi biên dịch vì `protected` và `public` là tương đương.",
      "Nó chỉ hoạt động nếu `C` là abstract.",
    ],
    answer: 1,
    explanation:
      "Phương thức Interface là ngầm định `public` [4]. Ghi đè phương thức không được phép giảm quyền truy cập [69], do đó `protected` là không hợp lệ (vì `protected` hạn chế hơn `public`) [70].",
  },
  {
    id: 1243,
    topic: "Interface",
    type: "radio",
    question:
      "Khi sử dụng từ khóa `implements`, liệu class đó có thể truy cập trực tiếp các trường `static final` của interface không?",
    options: [
      "Không, phải sử dụng getter.",
      "Có, vì chúng là `public`.",
      "Chỉ khi các trường đó không được khai báo `final`.",
      "Chỉ khi class đó là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Các trường là `public static final` [4, 57], nên có thể được truy cập trực tiếp bằng tên interface hoặc tên class triển khai (nếu không có xung đột tên).",
  },
  {
    id: 1244,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `List` là một interface, và ta muốn truyền một `ArrayList<String>` vào một phương thức chấp nhận `List<?>`. Điều này có được không?",
    options: [
      "Có, vì `List<?>` là unbounded wildcard và chấp nhận list của mọi kiểu.",
      "Không, vì kiểu `String` không phải là `Object`.",
      "Chỉ khi phương thức đó sử dụng `super`.",
      "Chỉ khi `String` là abstract.",
    ],
    answer: 0,
    explanation:
      "`List<?>` (Unbounded wildcard) chấp nhận một list thuộc bất kỳ kiểu nào, cho phép phương thức in các phần tử hoặc gọi các phương thức không phụ thuộc vào tham số kiểu (như `size()` hoặc `clear()`) [71, 72].",
  },
  {
    id: 1245,
    topic: "Interface",
    type: "radio",
    question:
      "Việc sử dụng interface giúp giải quyết vấn đề gì trong lập trình đa luồng (multithreading)?",
    options: [
      "Giới hạn số lượng luồng.",
      "Cung cấp cách định nghĩa 'job' (phương thức `run()`) cho các luồng thông qua interface `Runnable`.",
      "Đảm bảo tất cả các phương thức là `synchronized`.",
      "Ngăn chặn deadlock.",
    ],
    answer: 1,
    explanation:
      "Interface `Runnable` được sử dụng để tạo một job cho luồng thực thi, bằng cách triển khai phương thức `run()` [18, 63].",
  },
  {
    id: 1246,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về mối quan hệ giữa một class và các interface mà nó implement?",
    options: [
      "Quan hệ `HAS-A`.",
      "Quan hệ `IS-A`.",
      "Quan hệ `Composition`.",
      "Quan hệ `Association`.",
    ],
    answer: 1,
    explanation:
      "Nếu một class implement một interface, nó được coi là có quan hệ `IS-A` với interface đó (ví dụ: `Dog IS-A Pet` thông qua implement) [14, 17].",
  },
  {
    id: 1247,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface `I` chỉ có các `default` methods (từ JDK 8), và class `C` implement `I`. Điều gì xảy ra?",
    options: [
      "Class `C` phải là abstract.",
      "Class `C` vẫn là class concrete mà không cần override bất kỳ phương thức nào.",
      "Lỗi biên dịch.",
      "Trình biên dịch tự động loại bỏ interface `I`.",
    ],
    answer: 1,
    explanation:
      "Nếu interface chỉ chứa các phương thức `default` và `static`, nó không có phương thức trừu tượng nào. Class triển khai nó không cần phải override [4, 64].",
  },
  {
    id: 1248,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface `I` được khai báo, và ta cố gắng tạo đối tượng `I obj = new I()`. Điều gì xảy ra?",
    options: [
      "Khởi tạo thành công.",
      "Lỗi biên dịch, không thể tạo instance từ interface.",
      "Lỗi runtime, ngoại lệ `InstantiationException`.",
      "Nó tạo ra một đối tượng `Object`.",
    ],
    answer: 1,
    explanation:
      "Bạn không thể tạo một instance (đối tượng) từ một interface [4, 8, 22].",
  },
  {
    id: 1249,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, từ khóa `extends` được sử dụng cho cả interface và class. Điều này có ý nghĩa gì đối với tính nhất quán của ngôn ngữ?",
    options: [
      "Nó gây ra sự mơ hồ về mặt ngữ nghĩa.",
      "Nó đơn giản hóa cú pháp bằng cách sử dụng một từ khóa chung cho quan hệ `IS-A`.",
      "Nó bị phản đối (deprecated) từ JDK 9.",
      "Nó chỉ áp dụng cho các kiểu wrapper.",
    ],
    answer: 1,
    explanation:
      "Trong Generics, `extends` có nghĩa là 'extends hoặc implements' (is-a), đơn giản hóa cú pháp [24].",
  },
  {
    id: 1250,
    topic: "Interface",
    type: "radio",
    question:
      "Để triển khai interface `List<E>`, class phải cung cấp định nghĩa cho phương thức nào để thêm phần tử vào cuối danh sách?",
    options: [
      "push(E element)",
      "add(E element)",
      "poll(E element)",
      "insert(E element)",
    ],
    answer: 1,
    explanation:
      "Phương thức `add(E element)` được dùng để nối phần tử vào cuối list [34, 73].",
  },
  {
    id: 1251,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất ẩn giấu chi tiết triển khai của interface là ví dụ cho khái niệm OOP nào?",
    options: ["Encapsulation", "Polymorphism", "Abstraction", "Inheritance"],
    answer: 2,
    explanation:
      "Interface chỉ định nghĩa 'cái gì' (what) mà không định nghĩa 'cách làm' (how) [12], đây là cơ chế chính của Abstraction [68, 74].",
  },
  {
    id: 1252,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, việc sử dụng interface là bắt buộc trong Java?",
    options: [
      "Khi cần định nghĩa các hằng số.",
      "Khi một class cần được tuần tự hóa (`Serializable`).",
      "Khi cần định nghĩa một phương thức `static`.",
      "Khi class đó có constructor `private`.",
    ],
    answer: 1,
    explanation:
      "Để lưu một đối tượng Java sang byte stream (serialization), class phải implement interface `java.io.Serializable` [38, 39].",
  },
  {
    id: 1253,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `A` implement interface `I`, và `I` có phương thức `default void start()`. Nếu `A` không override `start()`, làm thế nào để gọi `start()` trên đối tượng `a` của `A`?",
    options: [
      "Chỉ có thể gọi `I.start()`.",
      "Gọi trực tiếp `a.start()`.",
      "Phải sử dụng từ khóa `super`.",
      "Không thể gọi được.",
    ],
    answer: 1,
    explanation:
      "Phương thức default được kế thừa bởi class triển khai và có thể được gọi trực tiếp trên đối tượng đó (`a.start()`) [64].",
  },
  {
    id: 1254,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class `C` implement interface `I`, và ta muốn class `C` kế thừa implementation mặc định từ một class `A`. Cú pháp nào là đúng?",
    options: [
      "class C implements I extends A",
      "class C extends I implements A",
      "class C extends A implements I",
      "class C uses I and A",
    ],
    answer: 2,
    explanation: "Thứ tự khai báo là `extends` sau đó là `implements` [7, 14].",
  },
  {
    id: 1255,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng interface `PaymentStrategy` trong Strategy Pattern là gì?",
    options: [
      "Định nghĩa cách thức thanh toán (ví dụ: CreditCardPayment, PayPalPayment).",
      "Chứa logic xử lý thanh toán thực tế.",
      "Ngăn chặn việc thay đổi thuật toán.",
      "Buộc class Context phải là abstract.",
    ],
    answer: 0,
    explanation:
      "Interface `PaymentStrategy` định nghĩa hợp đồng chung `pay(double amount)` cho các chiến lược thanh toán cụ thể [32].",
  },
  {
    id: 1256,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Iterator` định nghĩa phương thức nào để kiểm tra xem còn phần tử tiếp theo để duyệt không?",
    options: ["get(index)", "hasNext()", "poll()", "size()"],
    answer: 1,
    explanation:
      "Interface Iterator có các phương thức `hasNext()`, `next()`, `remove()` [34, 37].",
  },
  {
    id: 1257,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, `implements` là cách duy nhất để đạt được tính đa hình với các class không thuộc cùng một cây kế thừa?",
    options: [
      "Khi các class đó không kế thừa từ `Object`.",
      "Khi các class đó đều là `final`.",
      "Khi cần định nghĩa một vai trò chung (common role).",
      "Khi cần sử dụng đa kế thừa code.",
    ],
    answer: 2,
    explanation:
      "Interface định nghĩa một vai trò chung, cho phép các class từ các cây kế thừa khác nhau (ví dụ: `Dog` và `RoboDog`) được đối xử như cùng một kiểu [17, 18, 58].",
  },
  {
    id: 1258,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `java.io.Serializable`, và class đó có một trường mà bạn KHÔNG muốn tuần tự hóa. Bạn nên sử dụng từ khóa nào cho trường đó?",
    options: ["static", "final", "private", "transient"],
    answer: 3,
    explanation:
      "Sử dụng biến `transient` để loại trừ một trường khỏi quá trình tuần tự hóa [75].",
  },
  {
    id: 1259,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Comparable` sử dụng phương thức `compareTo(T o)` để so sánh. Tham số `T` là gì trong cú pháp này?",
    options: [
      "Kiểu dữ liệu nguyên thủy.",
      "Đối tượng của chính class implement `Comparable`.",
      "Bất kỳ đối tượng nào.",
      "Chỉ kiểu `Object`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `CompareTo()` lấy một đối tượng của cùng một kiểu làm tham số và so sánh hai đối tượng [22].",
  },
  {
    id: 1260,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class `C` implement interface `I`, và `I` có phương thức trừu tượng `void action(int a)`. Class `C` phải triển khai phương thức với chữ ký nào?",
    options: [
      "public void action()",
      "public void action(int a)",
      "private void action(int a)",
      "static void action(int a)",
    ],
    answer: 1,
    explanation:
      "Phương thức phải được triển khai với cùng chữ ký (đối số) và access modifier không được giảm quyền truy cập (`public`) [4, 76].",
  },
  {
    id: 1261,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một interface `I1` extend `I2`, và class `C` implement `I1`?",
    options: [
      "`C` chỉ cần triển khai các phương thức của `I1`.",
      "`C` phải triển khai tất cả các phương thức của cả `I1` và `I2`.",
      "`C` phải là `abstract`.",
      "`C` không thể truy cập các hằng số của `I2`.",
    ],
    answer: 1,
    explanation:
      "Kế thừa interface là kế thừa hợp đồng. `C` phải triển khai tất cả các phương thức trừu tượng trong cây kế thừa của interface [4, 16].",
  },
  {
    id: 1262,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, một class triển khai interface được phép không phải là concrete class?",
    options: [
      "Nếu nó khai báo constructor `private`.",
      "Nếu nó không triển khai tất cả các phương thức trừu tượng và được khai báo là `abstract`.",
      "Nếu nó chỉ triển khai một interface.",
      "Nếu nó là `final`.",
    ],
    answer: 1,
    explanation:
      "Nếu một class triển khai một interface nhưng không triển khai hết các phương thức trừu tượng, nó phải là abstract [4, 53].",
  },
  {
    id: 1263,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa `implements` có thể được sử dụng cùng với từ khóa `extends` trong cùng một khai báo class. Đúng hay Sai?",
    options: ["Đúng.", "Sai."],
    answer: 0,
    explanation:
      "Đúng. Cú pháp cho phép: `class C extends A implements I` [7, 14].",
  },
  {
    id: 1264,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `List<E>` trong khai báo phương thức là gì?",
    options: [
      "Giảm thiểu sự cần thiết của Generics.",
      "Bắt buộc tham số phải là `ArrayList`.",
      "Tăng tính linh hoạt, cho phép truyền bất kỳ đối tượng nào triển khai `List` (ví dụ: `ArrayList`, `LinkedList`).",
      "Chỉ cho phép các đối tượng `Object`.",
    ],
    answer: 2,
    explanation:
      "Sử dụng kiểu interface trong khai báo phương thức là một phần của polymorphism, cho phép chấp nhận bất kỳ đối tượng nào implement interface đó [17, 18, 36].",
  },
  {
    id: 1265,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Java 8+, nếu hai interface mà class `C` implement có cùng một phương thức `default` (gây xung đột), `C` phải làm gì?",
    options: [
      "Class `C` phải override phương thức đó và cung cấp implementation riêng.",
      "Class `C` phải chọn một trong hai phương thức `default` để sử dụng.",
      "Lỗi biên dịch không thể giải quyết.",
      "Chỉ cần sử dụng từ khóa `super`.",
    ],
    answer: 0,
    explanation:
      "Khi có xung đột phương thức `default`, class triển khai phải override phương thức đó và cung cấp implementation để giải quyết ambiguity.",
  },
  {
    id: 1266,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `MyInterface` có `final int a = 100`, class `TestClass` implement `MyInterface`. Làm thế nào để truy cập giá trị của `a`?",
    options: [
      "Gọi `TestClass.a` hoặc `MyInterface.a`.",
      "Phải khởi tạo `TestClass` trước.",
      "Chỉ gọi `a`.",
      "Không thể truy cập vì `a` là `final`.",
    ],
    answer: 0,
    explanation:
      "Vì `a` là `public static final` [4, 57, 64], nó có thể được truy cập thông qua tên class triển khai hoặc tên interface.",
  },
  {
    id: 1267,
    topic: "Interface",
    type: "radio",
    question: "Từ khóa `implements` KHÔNG xuất hiện trong khai báo nào?",
    options: [
      "Khai báo một interface extend interface khác.",
      "Khai báo một class extend abstract class.",
      "Khai báo một class implement nhiều interface.",
      "Khai báo một abstract class implement một interface.",
    ],
    answer: 1,
    explanation:
      "Khai báo một class extend class khác sử dụng từ khóa `extends` [15, 77].",
  },
  {
    id: 1268,
    topic: "Interface",
    type: "radio",
    question:
      "Việc sử dụng interface để định nghĩa một 'job' cho thread trong `Runnable` tuân theo nguyên tắc thiết kế nào?",
    options: [
      "Giảm thiểu sự cần thiết của polymorphism.",
      "Khuyến khích lập trình hướng đối tượng.",
      "Khuyến khích lập trình dựa trên giao diện (interface-based programming).",
      "Buộc các lớp phải là `final`.",
    ],
    answer: 2,
    explanation:
      "Sử dụng interface như `Runnable` là ví dụ điển hình của việc thiết kế và mã hóa theo interface (coding to interface specifications) [17, 78].",
  },
  {
    id: 1269,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Java, điều gì là ĐÚNG về việc một class implement `Comparable` và `Comparator`?",
    options: [
      "Không thể, vì chúng xung đột.",
      "Được phép, vì chúng phục vụ các mục đích sắp xếp khác nhau.",
      "Chỉ khi class đó là abstract.",
      "Chỉ khi các phương thức đó là `default`.",
    ],
    answer: 1,
    explanation:
      "Class có thể implement nhiều interface [14]. `Comparable` định nghĩa thứ tự tự nhiên, còn `Comparator` định nghĩa thứ tự tùy chỉnh.",
  },
  {
    id: 1270,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` triển khai interface `I` và `I` chỉ chứa các phương thức trừu tượng, điều gì xảy ra nếu ta bỏ từ khóa `public` khi khai báo các phương thức trong `C`?",
    options: [
      "Lỗi biên dịch, vì phương thức triển khai không được giảm quyền truy cập so với phương thức abstract (ngầm định `public`).",
      "Lỗi biên dịch, vì phương thức triển khai phải là `static`.",
      "Nó được coi là `public` tự động.",
      "Nó được coi là `default` (package-private).",
    ],
    answer: 0,
    explanation:
      "Phương thức interface là ngầm định `public` [4, 16]. Nếu bạn bỏ `public`, nó sẽ trở thành `default` (package-private) [70], làm giảm quyền truy cập và gây lỗi biên dịch.",
  },
  {
    id: 1271,
    topic: "Interface",
    type: "radio",
    question:
      "Tất cả các trường (fields) được khai báo trong một interface đều ngầm định có các modifiers nào?",
    options: [
      "private, static, final",
      "public, static, final",
      "protected, abstract, static",
      "public, private, final",
    ],
    answer: 1,
    explanation:
      "Tất cả các trường trong một interface đều ngầm định là public, static, final [4, 57].",
  },
  {
    id: 1272,
    topic: "Interface",
    type: "radio",
    question:
      "Do tính chất `final` của các trường trong interface, điều gì là đúng về khả năng thay đổi giá trị của chúng?",
    options: [
      "Có thể thay đổi bằng setter method.",
      "Chỉ có thể thay đổi trong constructor.",
      "Không thể thay đổi sau khi khởi tạo.",
      "Chỉ có thể thay đổi nếu được khai báo là `private`.",
    ],
    answer: 2,
    explanation:
      "`final` field là một hằng số, chỉ được thiết lập một lần và không được phép thay đổi lại theo thời gian [79, 80]. Do đó, trường trong interface không thể thay đổi sau khi khởi tạo [4, 57].",
  },
  {
    id: 1273,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất `static` của các trường trong interface có ý nghĩa gì?",
    options: [
      "Mỗi đối tượng có một bản sao riêng của trường đó.",
      "Các trường đó thuộc về class (hoặc interface) chứ không phải đối tượng, và được chia sẻ.",
      "Các trường đó phải được khởi tạo bằng từ khóa `new`.",
      "Giá trị của chúng có thể thay đổi trong runtime.",
    ],
    answer: 1,
    explanation:
      "`static` field thuộc về class thay vì đối tượng và được chia sẻ bởi tất cả các đối tượng của class đó [81-83].",
  },
  {
    id: 1274,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về các phương thức trừu tượng (abstract methods) trong Interface (trước JDK 8)?",
    options: [
      "Chúng phải được khai báo với từ khóa `abstract` và `private`.",
      "Chúng ngầm định là `public` và `abstract`.",
      "Chúng phải có thân hàm (body).",
      "Chúng có thể bị ghi đè thành `private` trong class con.",
    ],
    answer: 1,
    explanation:
      "Tất cả các phương thức trong một interface đều ngầm định là `public` và `abstract`, trừ khi chúng là `default` hoặc `static` [4, 16, 84].",
  },
  {
    id: 1275,
    topic: "Interface",
    type: "radio",
    question:
      "Khi khai báo một trường trong interface, ví dụ `int SIZE = 10;`, điều gì xảy ra nếu ta không viết `public static final`?",
    options: [
      "Lỗi biên dịch.",
      "Trình biên dịch tự động thêm các modifiers đó.",
      "Trường đó sẽ trở thành `private` và `non-static`.",
      "Trường đó sẽ trở thành `default` (package-private).",
    ],
    answer: 1,
    explanation:
      "Các modifiers `public`, `static`, `final` là ngầm định (implicitly) [4, 57]. Trình biên dịch sẽ tự động thêm chúng.",
  },
  {
    id: 1276,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface được khai báo với phương thức `void calculate()`, access modifier của phương thức này là gì?",
    options: ["private", "default (package-private)", "public", "protected"],
    answer: 2,
    explanation:
      "Tất cả các phương thức trừu tượng trong interface đều ngầm định là `public` [4, 16, 84].",
  },
  {
    id: 1277,
    topic: "Interface",
    type: "radio",
    question:
      "Tại sao các phương thức trừu tượng trong interface không có thân hàm (body)?",
    options: [
      "Để chúng có thể được gọi tĩnh.",
      "Vì implementation của chúng là trách nhiệm của class triển khai.",
      "Vì chúng không thể trả về giá trị.",
      "Vì chúng luôn là `private`.",
    ],
    answer: 1,
    explanation:
      "Interface chỉ định nghĩa 'cái gì' cần làm. Implementation của các phương thức này là trách nhiệm của các class implement interface đó [12, 25].",
  },
  {
    id: 1278,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một class `C` triển khai một interface có trường `public static final int CONST = 5` và `C` cố gắng gán `CONST = 10`?",
    options: [
      "Gán thành công.",
      "Lỗi biên dịch, vì trường `final` không thể thay đổi.",
      "Giá trị thay đổi chỉ trong `C`.",
      "Lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Trường `final` không cho phép thay đổi giá trị sau khi thiết lập [79, 80]. Lỗi biên dịch sẽ xảy ra.",
  },
  {
    id: 1279,
    topic: "Interface",
    type: "radio",
    question:
      "Một phương thức được khai báo trong interface cần phải kết thúc bằng dấu nào?",
    options: [
      "Dấu ngoặc nhọn `{}`.",
      "Dấu ngoặc đơn `()`.",
      "Dấu chấm phẩy `;`.",
      "Dấu chấm `.`.",
    ],
    answer: 2,
    explanation:
      "Các phương thức interface là abstract và không có thân hàm, vì vậy chúng phải kết thúc bằng dấu chấm phẩy [25, 53].",
  },
  {
    id: 1280,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất nào cho phép các hằng số trong interface được truy cập mà không cần tạo đối tượng?",
    options: ["public", "final", "static", "abstract"],
    answer: 2,
    explanation:
      "Tính chất `static` cho phép truy cập trực tiếp từ class/interface mà không cần object [18, 81]. Các trường interface ngầm định là `static` [4, 57].",
  },
  {
    id: 1281,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một phương thức trong interface là `default` (JDK 8+), điều gì là đúng về modifiers của nó?",
    options: [
      "Nó ngầm định là `abstract`.",
      "Nó có thể không phải là `public`.",
      "Nó vẫn là ngầm định `public` nhưng có thân hàm.",
      "Nó phải là `final`.",
    ],
    answer: 2,
    explanation:
      "Các phương thức trong interface là ngầm định `public` trừ khi là `default` hoặc `static` [4]. Phương thức `default` vẫn là `public` và có implementation [64].",
  },
  {
    id: 1282,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là SAI về các trường (fields) trong interface?",
    options: [
      "Chúng là `public`.",
      "Chúng là `static`.",
      "Chúng là `final`.",
      "Chúng cần được khởi tạo trong constructor của class triển khai.",
    ],
    answer: 3,
    explanation:
      "Các trường interface là `public static final` và phải được khởi tạo ngay trong khai báo của interface, không phải trong constructor của class triển khai (vì chúng không phải là instance fields) [4, 57].",
  },
  {
    id: 1283,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất `public` của các phương thức trừu tượng trong interface đảm bảo điều gì?",
    options: [
      "Chỉ các lớp con mới có thể truy cập chúng.",
      "Chúng có thể được truy cập từ bất cứ đâu, làm cho hợp đồng có thể được thực thi rộng rãi.",
      "Chúng không thể bị ghi đè.",
      "Chúng không thể là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `public` có thể được truy cập bởi các class khác [85]. Interface là một hợp đồng công khai [4, 16].",
  },
  {
    id: 1284,
    topic: "Interface",
    type: "radio",
    question:
      "Trong cú pháp `interface MyInterface { int VALUE = 10; }`, làm thế nào để khai báo `VALUE` là `private`?",
    options: [
      "Sử dụng từ khóa `private`.",
      "Sử dụng từ khóa `protected`.",
      "Không thể, các trường interface luôn là `public`.",
      "Không thể, vì nó sẽ mâu thuẫn với `static`.",
    ],
    answer: 2,
    explanation:
      "Tất cả các trường trong interface đều ngầm định là `public` [4, 57]. Không thể làm cho chúng trở thành `private`.",
  },
  {
    id: 1285,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface `I` có phương thức trừu tượng `void process()`. Khi class `C` implement `I`, `C` phải khai báo `process()` với chữ ký nào để tuân thủ quyền truy cập?",
    options: [
      "private void process()",
      "protected void process()",
      "public void process()",
      "void process()",
    ],
    answer: 2,
    explanation:
      "Phương thức trừu tượng trong interface là ngầm định `public` [4, 16]. Việc triển khai không được giảm quyền truy cập [69], nên phải là `public`.",
  },
  {
    id: 1286,
    topic: "Interface",
    type: "radio",
    question:
      "Tại sao các trường trong interface KHÔNG THỂ là instance fields (non-static)?",
    options: [
      "Vì instance fields yêu cầu một constructor, nhưng interface không có constructor.",
      "Vì interface không thể được khởi tạo, do đó không có đối tượng để giữ instance fields.",
      "Vì chúng là `final`.",
      "Vì chúng là `public`.",
    ],
    answer: 1,
    explanation:
      "Interface không thể được khởi tạo [4, 22], do đó không thể có đối tượng. Instance fields phụ thuộc vào sự tồn tại của một thể hiện của class [86, 87]. Do đó, các trường phải là `static` (thuộc về kiểu, không phải thể hiện).",
  },
  {
    id: 1287,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `MyInterface` có khai báo `void action(String s);`, đây là một phương thức gì?",
    options: [
      "Static method.",
      "Default method.",
      "Abstract method.",
      "Private method.",
    ],
    answer: 2,
    explanation:
      "Trước JDK 8, phương thức không có thân hàm trong interface là phương thức trừu tượng, ngầm định là `public` và `abstract` [4, 16, 84].",
  },
  {
    id: 1288,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc khởi tạo các trường trong Interface?",
    options: [
      "Chúng phải được khởi tạo khi khai báo.",
      "Chúng có thể được khởi tạo trong các phương thức trừu tượng.",
      "Chúng chỉ được khởi tạo bởi class triển khai.",
      "Chúng không cần được khởi tạo.",
    ],
    answer: 0,
    explanation:
      "Các trường là `final` [4, 57] và phải được khởi tạo ngay lập tức (thường trong khai báo).",
  },
  {
    id: 1289,
    topic: "Interface",
    type: "radio",
    question:
      'Nếu ta khai báo `interface I { public static final String NAME = "I"; }`, liệu có thể lược bỏ `public static final` không?',
    options: [
      "Không, phải khai báo rõ ràng.",
      "Có, vì chúng là ngầm định.",
      "Chỉ lược bỏ `public` và `static`.",
      "Chỉ lược bỏ `final`.",
    ],
    answer: 1,
    explanation:
      "Các modifiers `public`, `static`, `final` là ngầm định (implicitly) [4, 57]. Trình biên dịch sẽ tự động thêm chúng.",
  },
  {
    id: 1290,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một phương thức trong interface là `static` (JDK 8+), điều gì là đúng?",
    options: [
      "Nó phải là `abstract`.",
      "Nó phải được override bởi class triển khai.",
      "Nó có thể được gọi mà không cần tạo đối tượng.",
      "Nó có thể truy cập các trường non-static.",
    ],
    answer: 2,
    explanation:
      "Phương thức static thuộc về interface (class) chứ không phải object và có thể được gọi trực tiếp bằng tên interface [18, 81].",
  },
  {
    id: 1291,
    topic: "Interface",
    type: "radio",
    question:
      "Một phương thức `static` trong interface có cần phải là `final` không?",
    options: [
      "Có, luôn luôn.",
      "Không, nhưng nó không thể bị override.",
      "Có, nếu nó là `public`.",
      "Chỉ khi nó là `default`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `static` không thể bị override trong Java [88]. Mặc dù nó không cần từ khóa `final` để ngăn chặn việc override, nhưng nó có hành vi tương tự như `final`.",
  },
  {
    id: 1292,
    topic: "Interface",
    type: "radio",
    question:
      "Trong interface, phương thức `static` khác với phương thức `default` ở điểm nào?",
    options: [
      "Phương thức `default` không thể có thân hàm.",
      "Phương thức `static` không thể được gọi trên object của class triển khai.",
      "Phương thức `default` không thể bị override.",
      "Phương thức `static` không phải là `public`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `static` thuộc về interface và không thể được gọi trên instance object [18, 81]. Phương thức `default` được kế thừa và có thể được gọi trên object của class triển khai [64].",
  },
  {
    id: 1293,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng khai báo một phương thức `private` trong Interface (trước JDK 9)?",
    options: [
      "Khởi tạo thành công.",
      "Lỗi biên dịch, vì các phương thức ngầm định là `public` và `abstract`.",
      "Nó tự động trở thành `default`.",
      "Nó tự động trở thành `static`.",
    ],
    answer: 1,
    explanation:
      "Trước JDK 9, phương thức interface là ngầm định `public` và `abstract` [4, 16]. (Private methods được thêm vào từ JDK 9, nhưng tài liệu chỉ đề cập đến Default và Static từ JDK 8+).",
  },
  {
    id: 1294,
    topic: "Interface",
    type: "radio",
    question:
      "Các hằng số trong interface thường được viết bằng quy ước đặt tên nào?",
    options: [
      "camelCase (ví dụ: myConstant)",
      "PascalCase (ví dụ: MyConstant)",
      "SCREAMING_SNAKE_CASE (ví dụ: MAX_VALUE)",
      "snake_case (ví dụ: max_value)",
    ],
    answer: 2,
    explanation:
      "Hằng số (constant variable - `static final`) thường được đặt tên bằng chữ in hoa, cách nhau bằng dấu gạch dưới (SCREAMING_SNAKE_CASE) [80, 89].",
  },
  {
    id: 1295,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface được sử dụng để định nghĩa hằng số, làm thế nào để truy cập chúng trong một class khác mà KHÔNG implement interface đó?",
    options: [
      "Không thể.",
      "Sử dụng `InterfaceName.CONSTANT_NAME`.",
      "Chỉ thông qua `default` method.",
      "Chỉ thông qua `static` method.",
    ],
    answer: 1,
    explanation:
      "Vì các trường là `public static final` [4, 57], chúng có thể được truy cập trực tiếp bằng tên interface.",
  },
  {
    id: 1296,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng các phương thức `static` trong interface?",
    options: [
      "Chúng có thể được gọi bằng tham chiếu đối tượng của class triển khai.",
      "Chúng phải được gọi bằng tên interface.",
      "Chúng có thể truy cập các trường non-static.",
      "Chúng phải là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Các phương thức static thuộc về class/interface và có thể được gọi trực tiếp bằng tên interface (ví dụ: `Calculator.add(3,3)`) [18, 90].",
  },
  {
    id: 1297,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất `final` của các trường trong interface đảm bảo gì về mặt thiết kế?",
    options: [
      "Encapsulation (Đóng gói).",
      "Tính bất biến (Immutability).",
      "Tính đa hình (Polymorphism).",
      "Tính trừu tượng (Abstraction).",
    ],
    answer: 1,
    explanation:
      "`final` fields là hằng số, đảm bảo tính bất biến (immutable) [79, 80].",
  },
  {
    id: 1298,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một interface chỉ có một phương thức duy nhất `abstract`?",
    options: [
      "Nó được gọi là Functional Interface.",
      "Nó bị lỗi biên dịch.",
      "Nó phải được triển khai bởi một abstract class.",
      "Nó phải là `public`.",
    ],
    answer: 0,
    explanation:
      "Interface chỉ có một phương thức abstract là Functional Interface (cần thêm `@FunctionalInterface` từ JDK 8, nhưng khái niệm này là đúng).",
  },
  {
    id: 1299,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` trong interface được giới thiệu để giải quyết vấn đề gì?",
    options: [
      "Cho phép class implement nhiều interface.",
      "Cho phép thêm phương thức mới vào interface mà không làm hỏng các class đã triển khai trước đó.",
      "Buộc class phải override tất cả các phương thức.",
      "Thay thế hoàn toàn abstract class.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` cho phép bổ sung chức năng vào interface mà không bắt buộc các class triển khai phải thay đổi [4].",
  },
  {
    id: 1300,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về phương thức `public abstract` trong interface?",
    options: [
      "Từ khóa `public` và `abstract` là tùy chọn (optional) và có thể lược bỏ.",
      "Cả hai từ khóa đều là bắt buộc.",
      "Chỉ có thể sử dụng nếu interface đó extend một interface khác.",
      "Chúng phải có thân hàm.",
    ],
    answer: 0,
    explanation:
      "Các phương thức trừu tượng trong interface ngầm định là `public` và `abstract`, nên việc gõ chúng vào là tùy chọn và không được coi là 'good style' [58].",
  },
  {
    id: 1301,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` khai báo `int MAX = 100`, và class `C` implement `I`. `MAX` được coi là gì trong `C`?",
    options: [
      "Trường instance có thể thay đổi.",
      "Hằng số chia sẻ cấp class.",
      "Biến cục bộ (local variable).",
      "Trường private.",
    ],
    answer: 1,
    explanation:
      "`MAX` là `public static final` [4, 57]. Nó là hằng số cấp class được chia sẻ.",
  },
  {
    id: 1302,
    topic: "Interface",
    type: "radio",
    question:
      "Trong interface, một phương thức được khai báo không có từ khóa `abstract`, `default`, hoặc `static` sẽ được coi là gì?",
    options: [
      "Phương thức trừu tượng.",
      "Phương thức `default`.",
      "Lỗi biên dịch.",
      "Phương thức `private`.",
    ],
    answer: 0,
    explanation:
      "Nó ngầm định là phương thức trừu tượng (`public abstract`) [4, 16, 84].",
  },
  {
    id: 1303,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc khai báo `final` đối với các trường trong interface?",
    options: [
      "Từ khóa `final` là tùy chọn, nhưng nên thêm vào cho rõ ràng.",
      "Từ khóa `final` là bắt buộc, nếu không sẽ lỗi.",
      "Từ khóa `final` là ngầm định và không cần thiết.",
      "Từ khóa `final` chỉ áp dụng nếu trường đó là `private`.",
    ],
    answer: 2,
    explanation:
      "Các trường là ngầm định `final` [4, 57], nên không cần thiết phải gõ từ khóa này.",
  },
  {
    id: 1304,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất `public` của các trường trong interface có ý nghĩa gì đối với Encapsulation?",
    options: [
      "Nó tăng cường Encapsulation.",
      "Nó vi phạm Encapsulation, nhưng được chấp nhận vì chúng là hằng số.",
      "Nó không liên quan đến Encapsulation.",
      "Nó khiến chúng không thể được khởi tạo.",
    ],
    answer: 1,
    explanation:
      "Encapsulation thường yêu cầu các trường là private [91, 92]. Mặc dù các trường interface là `public`, chúng là hằng số (`final`) nên không thể thay đổi trạng thái, làm cho việc truy cập trực tiếp được chấp nhận (vi phạm quy tắc ẩn dữ liệu mutable).",
  },
  {
    id: 1305,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu ta khai báo `interface I { final int a = 1; }`, khi truy cập `a` từ class `C` implement `I`, `a` có kiểu nào?",
    options: [
      "instance variable",
      "static constant",
      "local variable",
      "abstract field",
    ],
    answer: 1,
    explanation:
      "`final int a = 1` là ngầm định `public static final` [4, 57]. Nó là static constant.",
  },
  {
    id: 1306,
    topic: "Interface",
    type: "radio",
    question:
      "Trong cú pháp interface, điều gì có thể được lược bỏ khỏi khai báo phương thức trừu tượng `public abstract void run();`?",
    options: [
      "Chỉ `public`.",
      "Chỉ `abstract`.",
      "Cả `public` và `abstract`.",
      "Không thể lược bỏ gì.",
    ],
    answer: 2,
    explanation:
      "Cả `public` và `abstract` đều là ngầm định và có thể lược bỏ [4, 16, 58].",
  },
  {
    id: 1307,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface `I` có phương thức `default void execute()`. Điều gì xảy ra nếu class `C` triển khai `I` và ghi đè `execute()` thành `private`?",
    options: [
      "Lỗi biên dịch.",
      "Triển khai thành công.",
      "Phương thức `private` sẽ tự động trở thành `public`.",
      "Phương thức `default` sẽ bị loại bỏ.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` là `public` [4]. Ghi đè phương thức không được phép giảm quyền truy cập [69]. `private` giảm quyền truy cập so với `public`, gây lỗi biên dịch [70].",
  },
  {
    id: 1308,
    topic: "Interface",
    type: "radio",
    question:
      "Để truy cập một hằng số `MAX_COUNT` trong interface `Config`, ta nên sử dụng cú pháp nào?",
    options: [
      "new Config().MAX_COUNT",
      "Config.MAX_COUNT",
      "super.MAX_COUNT",
      "this.MAX_COUNT",
    ],
    answer: 1,
    explanation:
      "Vì hằng số là `static` [4, 57], nên truy cập bằng tên interface là cách chuẩn [81].",
  },
  {
    id: 1309,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về `public static final` trong interface?",
    options: [
      "Nó là cách duy nhất để định nghĩa các biến.",
      "Nó cho phép các biến đó có giá trị khác nhau giữa các object.",
      "Nó chỉ hoạt động khi sử dụng `default` method.",
      "Nó chỉ áp dụng cho các phương thức.",
    ],
    answer: 0,
    explanation:
      "Tất cả các trường trong interface đều ngầm định là `public static final` [4, 57], đây là cách duy nhất để định nghĩa các trường.",
  },
  {
    id: 1310,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất `abstract` của các phương thức trong interface được sử dụng để làm gì?",
    options: [
      "Đảm bảo rằng phương thức đó có implementation cơ sở.",
      "Buộc các lớp triển khai phải cung cấp implementation.",
      "Ngăn chặn việc đa kế thừa.",
      "Làm cho phương thức đó trở thành `static`.",
    ],
    answer: 1,
    explanation:
      "Phương thức abstract không có thân hàm [53], buộc lớp concrete đầu tiên phải implement nó [66, 93].",
  },
  {
    id: 1311,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface được khai báo với `static` method, phương thức này được kế thừa bởi class triển khai không?",
    options: [
      "Có, và có thể bị override.",
      "Có, nhưng không thể bị override.",
      "Không, nó chỉ thuộc về interface.",
      "Chỉ khi class triển khai là abstract.",
    ],
    answer: 2,
    explanation:
      "Phương thức static không bị ghi đè [88] và thuộc về class/interface [18, 81]. Nó không được xem là một phần của hợp đồng để được kế thừa bởi object.",
  },
  {
    id: 1312,
    topic: "Interface",
    type: "radio",
    question:
      "Giả sử interface `I` có `int SIZE = 10`. Khai báo nào là hợp lệ để truy cập `SIZE`?",
    options: ["I.SIZE;", "new I().SIZE;", "SIZE;", "this.SIZE;"],
    answer: 0,
    explanation:
      "Vì `SIZE` là `public static final` [4, 57], truy cập bằng tên interface là hợp lệ. (Lựa chọn `SIZE` cũng có thể hợp lệ nếu nó được truy cập trong một class implement `I`, nhưng `I.SIZE` là chính xác nhất).",
  },
  {
    id: 1313,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một abstract class `A` implement interface `I`, `A` có bắt buộc phải triển khai tất cả các phương thức trừu tượng của `I` không?",
    options: [
      "Có, vì nó là một class.",
      "Không, vì nó là `abstract` và có thể để lại implementation cho class con.",
      "Chỉ các phương thức `default`.",
      "Không, vì `I` là interface.",
    ],
    answer: 1,
    explanation:
      "Chỉ class concrete đầu tiên mới phải triển khai tất cả các phương thức abstract. Abstract class có thể để lại các phương thức trừu tượng chưa được triển khai [66].",
  },
  {
    id: 1314,
    topic: "Interface",
    type: "radio",
    question:
      "Trong interface `I`, nếu ta khai báo `void action();` và `void action(int x);`. Điều này được gọi là gì?",
    options: [
      "Method Overriding.",
      "Method Overloading.",
      "Xung đột đa kế thừa.",
      "Lỗi cú pháp.",
    ],
    answer: 1,
    explanation:
      "Khai báo nhiều phương thức cùng tên nhưng khác tham số được gọi là Method Overloading [94, 95].",
  },
  {
    id: 1315,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc sử dụng `static` field trong interface?",
    options: [
      "Nó là một biến có tuổi thọ gắn với đối tượng.",
      "Nó giúp theo dõi số lượng đối tượng được tạo.",
      "Nó cho phép định nghĩa các hằng số không thể thay đổi được chia sẻ.",
      "Nó yêu cầu khởi tạo sau khi đối tượng được tạo.",
    ],
    answer: 2,
    explanation:
      "Các trường là `static` và `final` [4, 57], tạo ra các hằng số chia sẻ.",
  },
  {
    id: 1316,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `static` trong interface có thể truy cập các trường nào?",
    options: [
      "Chỉ các trường `final`.",
      "Chỉ các trường `static` của interface đó.",
      "Bất kỳ trường nào, miễn là chúng là `public`.",
      "Chỉ các trường `default`.",
    ],
    answer: 1,
    explanation:
      "Phương thức static chỉ có thể truy cập các trường static [82, 88].",
  },
  {
    id: 1317,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `int SIZE = 10`. Để class `C` (implement `I`) thay đổi giá trị này, điều gì là cần thiết?",
    options: [
      "Sử dụng `setter` method.",
      "Sử dụng `default` method.",
      "Sử dụng từ khóa `transient`.",
      "Không thể, vì nó là `final`.",
    ],
    answer: 3,
    explanation:
      "Vì trường là `final` [4, 57], không thể thay đổi giá trị sau khi khởi tạo [79, 80].",
  },
  {
    id: 1318,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng interface để định nghĩa các phương thức `abstract` là để đảm bảo rằng các class triển khai có được tính chất nào?",
    options: [
      "Tính trừu tượng (Abstraction).",
      "Tính đóng gói (Encapsulation).",
      "Tính kế thừa (Inheritance).",
      "Tính đa hình (Polymorphism).",
    ],
    answer: 0,
    explanation:
      "Interface chỉ định nghĩa 'cái gì' cần làm [12], đó là cơ chế của Abstraction [68, 74].",
  },
  {
    id: 1319,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là SAI về các phương thức trong interface trước JDK 8?",
    options: [
      "Chúng có thể được khai báo là `static`.",
      "Chúng ngầm định là `public`.",
      "Chúng ngầm định là `abstract`.",
      "Chúng không được có thân hàm.",
    ],
    answer: 0,
    explanation:
      "Phương thức static và default được thêm vào interface từ JDK 8 trở đi [4, 64].",
  },
  {
    id: 1320,
    topic: "Interface",
    type: "radio",
    question:
      "Trong interface, `public static final` là sự kết hợp của những khái niệm cơ bản nào?",
    options: [
      "Tính đa hình, Lập trình hướng đối tượng, Hằng số.",
      "Kiểm soát truy cập, Cấp độ class, Bất biến.",
      "Kế thừa, Interface, Generics.",
      "Trừu tượng, Đóng gói, Luồng.",
    ],
    answer: 1,
    explanation:
      "`public` (kiểm soát truy cập) [4], `static` (thuộc về class) [4], `final` (bất biến) [4, 57].",
  },
  {
    id: 1321,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` trong interface được giới thiệu từ phiên bản JDK nào?",
    options: ["JDK 5.0", "JDK 7", "JDK 8", "JDK 11"],
    answer: 2,
    explanation:
      "Từ JDK 8 trở đi, bạn có thể implement phương thức `default` trong interface [4, 64].",
  },
  {
    id: 1322,
    topic: "Interface",
    type: "radio",
    question: "Mục đích chính của phương thức `default` là gì?",
    options: [
      "Cho phép khởi tạo interface.",
      "Cung cấp implementation cơ sở cho phương thức mà các class triển khai không bắt buộc phải override.",
      "Thay thế hoàn toàn phương thức trừu tượng.",
      "Đảm bảo rằng phương thức đó là `static`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` cho phép cung cấp implementation [64] mà không phá vỡ tính tương thích ngược với các class đã triển khai trước đó [4, 64, 96].",
  },
  {
    id: 1323,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` trong interface có thể truy cập các trường nào trong interface?",
    options: [
      "Chỉ các trường `public static final`.",
      "Bất kỳ trường nào, bao gồm cả instance fields.",
      "Nó không thể truy cập bất kỳ trường nào.",
      "Chỉ các trường `private`.",
    ],
    answer: 0,
    explanation:
      "Các trường trong interface đều là `public static final` [4, 57]. Phương thức `default` có thể truy cập các hằng số này (vì chúng là `static`).",
  },
  {
    id: 1324,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là bắt buộc đối với một phương thức `default` trong interface?",
    options: [
      "Phải có từ khóa `default` và thân hàm (body).",
      "Phải là `abstract`.",
      "Phải là `final`.",
      "Phải được override bởi class triển khai.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` cần từ khóa `default` và implementation (thân hàm) [64].",
  },
  {
    id: 1325,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` triển khai interface `I` và `I` có `default void action()`. Nếu `C` muốn gọi implementation mặc định của `I`, cú pháp nào là đúng?",
    options: [
      "I.super.action()",
      "I.action()",
      "super.action()",
      "Không thể gọi implementation mặc định.",
    ],
    answer: 0,
    explanation:
      "Cú pháp để gọi phương thức `default` của interface từ class triển khai là `InterfaceName.super.methodName()` (Suy luận từ cách gọi super method trong abstract class).",
  },
  {
    id: 1326,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement hai interface `I1` và `I2`, cả hai đều có `default void process()`. Class `C` phải làm gì để biên dịch thành công?",
    options: [
      "Khai báo `C` là `abstract`.",
      "Chỉ cần gọi một trong hai `default` methods.",
      "Ghi đè `process()` để cung cấp implementation riêng.",
      "Sử dụng `super` để chỉ định implementation của `I1`.",
    ],
    answer: 2,
    explanation:
      "Xung đột phương thức `default` phải được giải quyết bằng cách override phương thức đó trong class triển khai.",
  },
  {
    id: 1327,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` trong interface có access modifier mặc định là gì?",
    options: ["private", "protected", "public", "default (package-private)"],
    answer: 2,
    explanation:
      "Tất cả các phương thức trong interface đều ngầm định là `public`, trừ khi là `default` hoặc `static` [4]. Phương thức `default` vẫn là `public`.",
  },
  {
    id: 1328,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc ghi đè (override) phương thức `default` trong class triển khai?",
    options: [
      "Không thể override.",
      "Là tùy chọn, nhưng có thể được thực hiện để cung cấp implementation cụ thể hơn.",
      "Là bắt buộc, nếu không sẽ lỗi biên dịch.",
      "Chỉ được phép nếu class đó là abstract.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` đã có implementation cơ sở, nên việc override là tùy chọn [64].",
  },
  {
    id: 1329,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng phương thức `default` trong interface là để làm gì?",
    options: [
      "Cung cấp code tái sử dụng (code reuse) cho nhiều class.",
      "Giới hạn khả năng kế thừa.",
      "Buộc các trường phải là `private`.",
      "Giải quyết vấn đề deadlock.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` cho phép các class triển khai chia sẻ implementation mà không cần phải là abstract class.",
  },
  {
    id: 1330,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` extend class `A` và implement interface `I`. `A` và `I` đều có phương thức `void process()`. Điều gì xảy ra?",
    options: [
      "Phương thức `default` của `I` được ưu tiên.",
      "Implementation của class `A` được ưu tiên (class wins over interface).",
      "Xảy ra lỗi biên dịch.",
      "Cần sử dụng `I.super.process()`.",
    ],
    answer: 1,
    explanation:
      "Nếu có xung đột giữa phương thức được kế thừa từ class và phương thức `default` từ interface, implementation của class sẽ thắng (class wins).",
  },
  {
    id: 1331,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` trong interface có thể khai báo là `final` không?",
    options: [
      "Có, nếu nó không bị override.",
      "Không, vì `default` methods ngầm định là `abstract`.",
      "Không thể, vì nó sẽ mâu thuẫn với `public`.",
      "Có, để ngăn chặn việc ghi đè trong class triển khai.",
    ],
    answer: 3,
    explanation:
      "Phương thức `default` có thể được khai báo là `final` để ngăn chặn việc override (tuy nhiên, mặc định nó có thể được override).",
  },
  {
    id: 1332,
    topic: "Interface",
    type: "radio",
    question:
      "Trong cú pháp phương thức `default`, nếu không chỉ định `public`, access modifier là gì?",
    options: ["public", "default (package-private)", "private", "protected"],
    answer: 0,
    explanation:
      "Các phương thức trong interface, bao gồm cả `default` methods, đều ngầm định là `public` [4].",
  },
  {
    id: 1333,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface `I` có `default void setup()`, và interface `I2` extend `I`. `I2` có kế thừa `setup()` không?",
    options: [
      "Không.",
      "Có, và `I2` có thể khai báo lại `setup()` là abstract.",
      "Có, nhưng không thể được override.",
      "Chỉ khi `I2` là `final`.",
    ],
    answer: 1,
    explanation:
      "Các interface con kế thừa phương thức `default`. Interface con có thể ghi đè phương thức `default` (cung cấp implementation riêng) hoặc khai báo nó lại là abstract.",
  },
  {
    id: 1334,
    topic: "Interface",
    type: "radio",
    question:
      "Mục đích của việc sử dụng từ khóa `default` là để cung cấp implementation cho phương thức mà thông thường sẽ là gì?",
    options: ["abstract", "static", "private", "final"],
    answer: 0,
    explanation:
      "Phương thức `default` cho phép cung cấp implementation cho những phương thức mà trước đây phải là `abstract` trong interface.",
  },
  {
    id: 1335,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` được dùng để duy trì tính tương thích ngược (backward compatibility) khi nào?",
    options: [
      "Khi xóa một phương thức trừu tượng khỏi interface.",
      "Khi thêm một phương thức trừu tượng mới vào interface đã tồn tại.",
      "Khi thay đổi tên của interface.",
      "Khi thêm một trường `private` mới.",
    ],
    answer: 1,
    explanation:
      "Nếu không có `default` method, việc thêm một phương thức trừu tượng mới vào interface sẽ buộc tất cả các class triển khai phải implement nó, phá vỡ tính tương thích ngược.",
  },
  {
    id: 1336,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `MyInterface` có `default void display()` [64], và class `TestClass` implement nó. `TestClass` có thể gọi `display()` trên instance `t` của nó không?",
    options: [
      "Có, bằng `t.display()`.",
      "Không, vì nó là `default`.",
      "Chỉ bằng `MyInterface.display()`.",
      "Chỉ khi `TestClass` override `display()`.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` được kế thừa và có thể được gọi trên object của class triển khai [64].",
  },
  {
    id: 1337,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một class triển khai hai interface, `I1` (có `default void log()`) và `I2` (có `abstract void log()`)?",
    options: [
      "Implementation `abstract` sẽ thắng.",
      "Lỗi biên dịch.",
      "Class đó phải cung cấp implementation cho `log()` (vì `I2` buộc nó là abstract).",
      "Phương thức `default` được sử dụng.",
    ],
    answer: 2,
    explanation:
      "Nếu một interface định nghĩa là abstract, nó buộc class triển khai phải cung cấp implementation, bất kể interface khác có implementation mặc định hay không.",
  },
  {
    id: 1338,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` giúp giải quyết vấn đề đa kế thừa bằng cách nào?",
    options: [
      "Bằng cách buộc lớp triển khai phải override.",
      "Bằng cách cho phép các interface kế thừa implementation code.",
      "Bằng cách làm cho các phương thức không thể bị override.",
      "Nó không liên quan đến đa kế thừa.",
    ],
    answer: 1,
    explanation:
      "Mặc dù giải quyết ban đầu của Java cho đa kế thừa là bằng abstract methods [6], phương thức `default` cho phép các interface cung cấp các implementation 'kế thừa' (mà không cần phải là abstract class), mở rộng tính năng của interface mà vẫn giữ được tính linh hoạt.",
  },
  {
    id: 1339,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void connect()`, và class `C` implement `I`. Nếu `C` muốn gọi `connect()` bằng `super`, cú pháp nào là đúng?",
    options: [
      "super.connect()",
      "I.super.connect()",
      "C.connect()",
      "Không thể sử dụng super.",
    ],
    answer: 1,
    explanation:
      "Cú pháp để gọi phương thức `default` của interface từ class triển khai là `InterfaceName.super.methodName()`.",
  },
  {
    id: 1340,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng các phương thức `default` và `static` trong interface?",
    options: [
      "Chúng làm cho interface trở thành abstract class.",
      "Chúng không phá vỡ mô hình 100% abstract class của interface (trước JDK 8).",
      "Chúng phá vỡ mô hình 100% abstract class của interface.",
      "Chúng chỉ được sử dụng cho các hằng số.",
    ],
    answer: 2,
    explanation:
      "Việc thêm `default` và `static` methods phá vỡ định nghĩa truyền thống rằng interface là '100% abstract class' [9, 10].",
  },
  {
    id: 1341,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `java.io.Serializable`, và ta muốn dùng `ObjectOutputStream` để lưu object này. Phương thức `default` có được tuần tự hóa không?",
    options: [
      "Có, luôn luôn.",
      "Không, chỉ các trường instance mới được tuần tự hóa.",
      "Chỉ khi phương thức đó là `private`.",
      "Chỉ khi phương thức đó là `static`.",
    ],
    answer: 1,
    explanation:
      "Serialization lưu trữ trạng thái của đối tượng (các trường instance) vào byte stream [97, 98], không phải implementation của phương thức, dù là `default` hay abstract.",
  },
  {
    id: 1342,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void test()`, và class `C` không override nó. Nếu `C` có một class con `D`, `D` có thể gọi `test()` không?",
    options: [
      "Không, vì `C` không override.",
      "Có, vì `test()` được kế thừa bởi `C` và `D` kế thừa `C`.",
      "Chỉ nếu `D` là abstract.",
      "Chỉ nếu `test()` là `final`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` được kế thừa bởi class triển khai và sau đó được kế thừa như một phương thức instance bình thường bởi các class con [64].",
  },
  {
    id: 1343,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một interface có một phương thức trừu tượng, và một phương thức `default` có cùng tên (overloading)?",
    options: [
      "Lỗi biên dịch.",
      "Được phép nếu chữ ký phương thức khác nhau.",
      "Phương thức `default` bị loại bỏ.",
      "Phương thức trừu tượng được ưu tiên.",
    ],
    answer: 1,
    explanation:
      "Overloading được phép nếu chữ ký phương thức khác nhau [94, 95].",
  },
  {
    id: 1344,
    topic: "Interface",
    type: "radio",
    question:
      "Việc sử dụng phương thức `default` giúp tăng cường tính chất OOP nào cho interface?",
    options: [
      "Tăng cường tính đa hình (Polymorphism) bằng cách cung cấp hành vi mặc định.",
      "Làm cho interface trở thành `final`.",
      "Giới hạn khả năng hiển thị.",
      "Buộc sử dụng `super`.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` cho phép interface cung cấp hành vi mặc định, mở rộng khả năng định nghĩa vai trò (role) và tăng cường polymorphism [9, 17].",
  },
  {
    id: 1345,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `MyInterface` có `final int a = 100` [64]. Trong phương thức `default void printA()`, cú pháp nào là đúng để in `a`?",
    options: [
      "System.out.println(a);",
      "System.out.println(this.a);",
      "System.out.println(MyInterface.a);",
      "Cả A và C.",
    ],
    answer: 3,
    explanation:
      "Vì `a` là `static` [4, 57], nó có thể được truy cập trực tiếp bằng tên ngắn (`a`) hoặc tên interface (`MyInterface.a`) trong phương thức `default` [64].",
  },
  {
    id: 1346,
    topic: "Interface",
    type: "radio",
    question:
      "Lớp `TestClass` trong ví dụ `default` method có thể truy cập `a` bằng cách nào?",
    options: [
      "Chỉ `t.a`.",
      "Chỉ `TestClass.a`.",
      "Cả `t.a` và `TestClass.a`.",
      "Chỉ `MyInterface.a`.",
    ],
    answer: 2,
    explanation:
      "Ví dụ trong nguồn sử dụng `System.out.println(t.a)` [64]. Vì `a` là `static`, nó cũng có thể được truy cập bằng tên class `TestClass.a` (hoặc `MyInterface.a`).",
  },
  {
    id: 1347,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I1` có `default void action()`, và interface `I2` extend `I1` và khai báo `void action()` (trừu tượng). Điều gì xảy ra khi class `C` implement `I2`?",
    options: [
      "`C` phải override `action()` vì `I2` đã loại bỏ implementation mặc định.",
      "`C` có thể sử dụng implementation mặc định của `I1`.",
      "Lỗi biên dịch.",
      "`C` phải là `abstract`.",
    ],
    answer: 0,
    explanation:
      "Interface con có thể ghi đè phương thức `default` bằng cách khai báo lại nó là abstract (xóa implementation mặc định), buộc class triển khai phải cung cấp implementation.",
  },
  {
    id: 1348,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về phương thức `static` trong interface (JDK 8+)?",
    options: [
      "Nó có thể bị override trong class triển khai.",
      "Nó không thể bị override trong class triển khai.",
      "Nó phải được gọi bằng `new`.",
      "Nó là ngầm định `default`.",
    ],
    answer: 1,
    explanation: "Phương thức `static` không thể bị override [88].",
  },
  {
    id: 1349,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I`, và ta muốn gọi `default` method `dm()` của `I` trên đối tượng `c` của `C`. Cú pháp nào là đúng nếu `C` KHÔNG override `dm()`?",
    options: ["c.dm()", "I.dm()", "c.I.dm()", "Không thể gọi."],
    answer: 0,
    explanation:
      "Phương thức `default` được kế thừa và có thể được gọi trực tiếp trên object [64].",
  },
  {
    id: 1350,
    topic: "Interface",
    type: "radio",
    question:
      "Mặc dù phương thức `default` được giới thiệu từ JDK 8, nhưng cơ chế cơ bản để giải quyết đa kế thừa vẫn là gì?",
    options: [
      "Sử dụng `static` fields.",
      "Sử dụng các phương thức `abstract` và buộc triển khai.",
      "Sử dụng `final` methods.",
      "Sử dụng `try-catch`.",
    ],
    answer: 0,
    explanation:
      "Các phương thức `abstract` là giải pháp cốt lõi cho đa kế thừa, vì chúng loại bỏ sự mơ hồ (ambiguity) [6, 7].",
  },
  {
    id: 1351,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `List` là interface, và ta gọi `List.of()` (static method). Phương thức này có thể được gọi trên object của `ArrayList` không?",
    options: [
      "Có, nếu `ArrayList` không override nó.",
      "Không, phương thức `static` thuộc về interface và phải được gọi bằng tên interface.",
      "Chỉ khi `List.of()` là `default`.",
      "Chỉ khi `List` là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `static` trong interface phải được gọi bằng tên interface [18, 90].",
  },
  {
    id: 1352,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là KHÔNG ĐÚNG về phương thức `default` trong interface?",
    options: [
      "Nó có thể được ghi đè trong class triển khai.",
      "Nó phải được khai báo với từ khóa `default`.",
      "Nó không thể gọi các phương thức trừu tượng khác trong cùng interface.",
      "Nó có thể gọi các phương thức trừu tượng khác trong cùng interface.",
    ],
    answer: 2,
    explanation:
      "Phương thức `default` có thể gọi các phương thức trừu tượng khác trong cùng interface (nếu chúng được implement trong class triển khai).",
  },
  {
    id: 1353,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I1` và `I2`. Cả hai đều có `default void start()`. `C` gọi `start()`. Điều gì xảy ra ở thời điểm biên dịch?",
    options: [
      "Lỗi biên dịch, vì có xung đột `default` method.",
      "Trình biên dịch chọn implementation của `I1`.",
      "Trình biên dịch chọn implementation của `I2`.",
      "Trình biên dịch yêu cầu `I1` và `I2` phải là `abstract`.",
    ],
    answer: 0,
    explanation:
      "Xung đột phương thức `default` phải được giải quyết bằng việc override thủ công, nếu không sẽ lỗi biên dịch.",
  },
  {
    id: 1354,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về các hằng số `public static final` trong interface khi so sánh với `default` method?",
    options: [
      "Hằng số tồn tại từ JDK 1.0; `default` method từ JDK 8+.",
      "Hằng số có thể bị override; `default` method thì không.",
      "Hằng số chỉ có thể được truy cập trong class triển khai.",
      "Cả hai đều không thể có thân hàm.",
    ],
    answer: 0,
    explanation:
      "Các trường `public static final` là tính năng cơ bản của interface [4, 57]. Phương thức `default` được thêm vào từ JDK 8 [4, 64].",
  },
  {
    id: 1355,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I`, và ta muốn class `C` sử dụng implementation `default` của `I` nhưng class con của `C` lại không. `C` nên làm gì?",
    options: [
      "Khai báo `C` là `final`.",
      "Không cần làm gì, vì class con có thể override bất cứ lúc nào.",
      "Override phương thức và đặt nó là `final` trong `C`.",
      "Override phương thức và đặt nó là `abstract` trong `C`.",
    ],
    answer: 2,
    explanation:
      "Để ngăn chặn việc ghi đè trong class con, class `C` nên override phương thức đó và đánh dấu nó là `final` [86, 99].",
  },
  {
    id: 1356,
    topic: "Interface",
    type: "radio",
    question:
      "Trong interface `I`, nếu ta khai báo `static int count() { return 1; }`. Phương thức này có access modifier mặc định là gì?",
    options: ["private", "protected", "public", "default (package-private)"],
    answer: 2,
    explanation:
      "Phương thức `static` trong interface là ngầm định `public` [4].",
  },
  {
    id: 1357,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng các phương thức `default` để cung cấp implementation cơ sở trong interface?",
    options: [
      "Làm cho interface giống như một abstract class có thể được kế thừa nhiều lần.",
      "Buộc các class triển khai phải là `abstract`.",
      "Giới hạn khả năng hiển thị của các phương thức.",
      "Cung cấp implementation mà không cần `extends`.",
    ],
    answer: 0,
    explanation:
      "Mặc dù không hoàn toàn là abstract class vì không thể có state [10], nhưng `default` method cho phép interface mang implementation code mà trước đây chỉ có abstract class làm được.",
  },
  {
    id: 1358,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void setup()`, và interface `I2` extend `I`. Nếu class `C` implement `I2`, `C` kế thừa implementation `setup()` từ đâu?",
    options: [
      "Từ `I` thông qua `I2`.",
      "Chỉ từ `I2`.",
      "Cần phải override.",
      "Không thể kế thừa.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` được kế thừa xuống interface con (`I2`) và sau đó được kế thừa bởi class triển khai (`C`) [64].",
  },
  {
    id: 1359,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về mối quan hệ giữa phương thức `default` và phương thức `abstract` trong cùng một interface?",
    options: [
      "Chúng không thể tồn tại cùng nhau.",
      "Phương thức `default` phải là `static`.",
      "Interface có thể chứa cả hai loại phương thức.",
      "Phương thức `abstract` có thể gọi phương thức `default`.",
    ],
    answer: 2,
    explanation:
      "Interface có thể chứa phương thức `abstract` (mặc định) và phương thức `default` (từ JDK 8+) [4, 64].",
  },
  {
    id: 1360,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I` có `default void log()`. Để override `log()` và gọi implementation mặc định bên trong, cú pháp nào là đúng?",
    options: ["I.super.log();", "super.log();", "this.log();", "log();"],
    answer: 0,
    explanation:
      "Cú pháp để gọi phương thức `default` của interface từ class triển khai là `InterfaceName.super.methodName()` (Suy luận từ cách gọi super method trong abstract class).",
  },
  {
    id: 1361,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void action()`, và class `C` implement `I` nhưng không override nó. Nếu `C` muốn sử dụng tên phương thức khác (`performAction`) để gọi `action()`, `C` cần làm gì?",
    options: [
      "Định nghĩa `void performAction() { action(); }`.",
      "Sử dụng `I.super.action()`.",
      "Khai báo `action()` là `static`.",
      "Không thể làm được.",
    ],
    answer: 0,
    explanation:
      "Class `C` có thể định nghĩa một phương thức mới gọi đến phương thức `default` đã kế thừa (`action()`).",
  },
  {
    id: 1362,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng phương thức `static` trong interface (JDK 8+)?",
    options: [
      "Nó cho phép định nghĩa các tiện ích liên quan đến interface.",
      "Nó là ngầm định `abstract`.",
      "Nó phải được gọi trên instance.",
      "Nó có thể gọi các phương thức `default` khác.",
    ],
    answer: 0,
    explanation:
      "Phương thức `static` được dùng để cung cấp các hàm tiện ích (utility functions) liên quan trực tiếp đến interface, ví dụ như `List.of()`.",
  },
  {
    id: 1363,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default int getId() { return 1; }`, và class `C` implement `I` và override `getId()` thành `return 2;`. Gọi `c.getId()` sẽ trả về gì?",
    options: ["1", "2", "Lỗi biên dịch.", "null"],
    answer: 1,
    explanation:
      "Khi phương thức bị override, implementation của class con được gọi [9, 77].",
  },
  {
    id: 1364,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `default` có thể được gọi thông qua tham chiếu kiểu nào?",
    options: [
      "Tham chiếu kiểu interface.",
      "Tham chiếu kiểu class triển khai.",
      "Tham chiếu kiểu abstract class.",
      "Cả A và B.",
    ],
    answer: 3,
    explanation:
      "Phương thức `default` là một phương thức instance (non-static) và được kế thừa, nên có thể được gọi qua tham chiếu object của class triển khai (B) hoặc tham chiếu polymorphic kiểu interface (A) [64].",
  },
  {
    id: 1365,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I1` và `I2` (cả hai đều có `default void action()`) được implement bởi class `C`. `C` override `action()` và gọi `I1.super.action()`. Sau đó `I2` được thêm một phương thức `abstract void action()`. Điều gì xảy ra?",
    options: [
      "Chương trình chạy bình thường.",
      "Lỗi biên dịch, vì `I2` đã buộc `action()` là trừu tượng, xung đột với `I1`.",
      "Lỗi runtime.",
      "Chỉ implementation `I1` được sử dụng.",
    ],
    answer: 1,
    explanation:
      "Nếu `I2` khai báo lại `action()` là abstract, nó loại bỏ implementation mặc định, nhưng lại xung đột với implementation `default` của `I1`.",
  },
  {
    id: 1366,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG khi một interface có phương thức `default`?",
    options: [
      "Các class triển khai không thể định nghĩa lại phương thức đó.",
      "Nó không còn là một hợp đồng hoàn toàn trừu tượng.",
      "Nó không thể có các phương thức trừu tượng khác.",
      "Nó phải được đặt tên theo quy tắc PascalCase.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` cung cấp implementation, làm cho interface không còn là 100% abstract class nữa [4, 10, 64].",
  },
  {
    id: 1367,
    topic: "Interface",
    type: "radio",
    question:
      "Sử dụng `List<Integer>` thay vì `List<Number>` là ví dụ về gì trong Generics?",
    options: [
      "Kế thừa.",
      "Type safety.",
      "Type casting.",
      "Unbounded wildcard.",
    ],
    answer: 1,
    explanation:
      "Generics giúp đảm bảo type safety và loại bỏ nhu cầu ép kiểu [100-102].",
  },
  {
    id: 1368,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `static void utility() { ... }`. Điều gì xảy ra nếu ta gọi `I.utility()`?",
    options: [
      "Thực thi thành công.",
      "Lỗi biên dịch, vì `static` method không có thân hàm.",
      "Lỗi runtime.",
      "Chỉ khi `I` là `final`.",
    ],
    answer: 0,
    explanation:
      "Phương thức `static` trong interface có thân hàm và có thể được gọi trực tiếp bằng tên interface [18, 90].",
  },
  {
    id: 1369,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I` (có `default void action()`), và `C` muốn truy cập phương thức `default` mà không cần override. `C` cần làm gì?",
    options: [
      "Không cần làm gì, nó được kế thừa tự động.",
      "Khai báo `action()` là `static`.",
      "Khai báo `action()` là `private`.",
      "Sử dụng `I.action()`.",
    ],
    answer: 0,
    explanation:
      "Phương thức `default` được kế thừa tự động và có thể gọi trên instance của `C` [64].",
  },
  {
    id: 1370,
    topic: "Interface",
    type: "radio",
    question:
      "Trong cú pháp `interface MyInterface { default void dm() { } }`, access modifier `public` được ẩn ở đâu?",
    options: [
      "Trong từ khóa `interface`.",
      "Trong từ khóa `default`.",
      "Nó không được ẩn.",
      "Nó được ẩn trong tên phương thức.",
    ],
    answer: 1,
    explanation: "Phương thức `default` ngầm định là `public` [4].",
  },
  {
    id: 1371,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất đa hình (Polymorphism) mà interface mang lại được gọi là gì?",
    options: [
      "Reference đa hình (Polymorphic references).",
      "Kế thừa đa cấp.",
      "Type casting.",
      "Composition.",
    ],
    answer: 0,
    explanation:
      "Interface là công cụ tối ưu để khai thác đa hình, tạo ra các tham chiếu đa hình [9, 17, 103].",
  },
  {
    id: 1372,
    topic: "Interface",
    type: "radio",
    question: "Interface `Comparable` được định nghĩa trong package nào?",
    options: ["java.io", "java.util", "java.lang", "java.awt"],
    answer: 2,
    explanation:
      "Comparable là một interface cơ bản nằm trong `java.lang` (không cần import) [46, 47].",
  },
  {
    id: 1373,
    topic: "Interface",
    type: "radio",
    question: "Mục đích của Interface `Comparator` là gì?",
    options: [
      "Định nghĩa thứ tự tự nhiên (natural ordering).",
      "Định nghĩa thứ tự tùy chỉnh (custom ordering) cho một class.",
      "Chỉ dùng để so sánh các kiểu nguyên thủy.",
      "Đảm bảo tính tuần tự hóa.",
    ],
    answer: 1,
    explanation:
      "Comparator được sử dụng để cung cấp thứ tự tùy chỉnh (ví dụ: `Collections.sort(list, comparator)`) [50, 104].",
  },
  {
    id: 1374,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `A` implement `I` và `B` implement `I`. Ta có thể gán `I ref = new A()`. Điều này có nghĩa là gì?",
    options: [
      "`A` và `B` không liên quan.",
      "`ref` chỉ có thể gọi các phương thức trong `I`.",
      "`ref` có thể gọi tất cả các phương thức của `A`.",
      "`I` phải là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Tham chiếu kiểu interface chỉ có thể gọi các phương thức được định nghĩa trong interface đó, bất kể đối tượng thực tế là gì [65, 66].",
  },
  {
    id: 1375,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `Book` implement `Comparable<Book>`, và ta cần so sánh hai cuốn sách. Phương thức nào sẽ được sử dụng?",
    options: [
      "compare(Book b1, Book b2)",
      "compareTwo(Book b)",
      "compareTo(Book b)",
      "equals(Object obj)",
    ],
    answer: 2,
    explanation:
      "Interface `Comparable` có phương thức duy nhất là `compareTo()` [22, 46, 48, 105].",
  },
  {
    id: 1376,
    topic: "Interface",
    type: "radio",
    question: "Interface `Collection` là gì?",
    options: [
      "Cơ chế quản lý I/O streams.",
      "Một interface gốc trong Java Collection Framework.",
      "Một class wrapper cho String.",
      "Một abstract class cho tất cả các map.",
    ],
    answer: 1,
    explanation:
      "Collection là một root interface trong Java collection framework [36].",
  },
  {
    id: 1377,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Queue` được triển khai bởi lớp nào để hoạt động như một danh sách liên kết?",
    options: ["ArrayList", "LinkedList", "Stack", "HashMap"],
    answer: 1,
    explanation:
      "LinkedList là một trong những class phổ biến triển khai interface Queue [61].",
  },
  {
    id: 1378,
    topic: "Interface",
    type: "radio",
    question: "Lợi ích của việc sử dụng Interface trong Adapter Pattern là gì?",
    options: [
      "Đảm bảo chỉ có một instance được tạo.",
      "Cung cấp một giao diện mới để thích ứng với giao diện cũ không tương thích.",
      "Thêm chức năng mới mà không thay đổi cấu trúc.",
      "Tổ chức các đối tượng trong cấu trúc cây.",
    ],
    answer: 1,
    explanation:
      "Adapter Pattern giúp các đối tượng có interface không tương thích cộng tác bằng cách hoạt động như một cầu nối, cung cấp một interface mới để thích ứng [54, 106, 107].",
  },
  {
    id: 1379,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, nếu `T` là một interface, cú pháp nào là đúng để chỉ ra rằng tham số `T` phải là kiểu con của `T`?",
    options: ["<T implements T>", "<T extends T>", "<T super T>", "<T uses T>"],
    answer: 1,
    explanation:
      "Trong Generics, từ khóa `extends` được sử dụng cho cả class và interface để chỉ ra quan hệ `IS-A` [23, 24].",
  },
  {
    id: 1380,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là SAI về việc sử dụng interface để định nghĩa hằng số?",
    options: [
      "Các hằng số là `final`.",
      "Các hằng số là `static`.",
      "Các hằng số có thể được thay đổi trong runtime.",
      "Các hằng số là `public`.",
    ],
    answer: 2,
    explanation:
      "Các hằng số là `final` và không thể thay đổi sau khi khởi tạo [4, 57, 79].",
  },
  {
    id: 1381,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `Dog` implement interface `Pet`, và `RoboDog` cũng implement `Pet`. Điều này cho phép ta làm gì?",
    options: [
      "Buộc `RoboDog` phải kế thừa `Dog`.",
      "Đảm bảo rằng `Dog` và `RoboDog` có thể được đối xử như kiểu `Pet` chung.",
      "Giới hạn `Dog` khỏi việc kế thừa.",
      "Ngăn chặn việc đa kế thừa.",
    ],
    answer: 1,
    explanation:
      "Interfaces cho phép các class từ các cây kế thừa khác nhau (`Dog` và `RoboDog`) được đối xử như cùng một kiểu `Pet` [18, 58].",
  },
  {
    id: 1382,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, ta phải sử dụng tên interface để truy cập một hằng số?",
    options: [
      "Khi hằng số đó là `private`.",
      "Khi có xung đột tên hằng số từ nhiều interface hoặc class cha.",
      "Khi hằng số đó không phải là `static`.",
      "Luôn luôn phải dùng tên interface.",
    ],
    answer: 1,
    explanation:
      "Nếu có xung đột tên (ambiguity) (ví dụ: từ đa kế thừa thông qua interface), cần sử dụng tên interface để phân biệt rõ ràng [6].",
  },
  {
    id: 1383,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `compareTo()` trong `Comparable` trả về một số nguyên âm khi nào?",
    options: [
      "Đối tượng `this` bằng đối tượng chỉ định.",
      "Đối tượng `this` nhỏ hơn đối tượng chỉ định.",
      "Đối tượng `this` lớn hơn đối tượng chỉ định.",
      "Khi có lỗi.",
    ],
    answer: 1,
    explanation:
      "Nếu đối tượng 'This' được coi là nhỏ hơn đối tượng 'specified', phương thức nên trả về một số nguyên âm [48].",
  },
  {
    id: 1384,
    topic: "Interface",
    type: "radio",
    question: "Interface `List` là một subtype của interface nào?",
    options: ["Map", "Set", "Collection", "Iterator"],
    answer: 2,
    explanation:
      "Collection là root interface. List là một subtype của Collection [36, 108].",
  },
  {
    id: 1385,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có phương thức trừu tượng `void run()`, và class `C` implement `I`. Nếu `C` muốn sử dụng `Runnable` interface, nó có thể làm gì?",
    options: [
      "Nó phải implement cả `I` và `Runnable`.",
      "Nó chỉ cần implement `I`.",
      "Nó không thể implement cả hai.",
      "Nó phải extend `I`.",
    ],
    answer: 0,
    explanation: "Class có thể implement nhiều interface [14].",
  },
  {
    id: 1386,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về Generics và interface?",
    options: [
      "Generics chỉ chấp nhận các class, không phải interface.",
      "Generics sử dụng `extends` để chỉ ra quan hệ `IS-A` cho cả class và interface.",
      "Generics chỉ hoạt động với `Comparable`.",
      "Interface không thể có Generics.",
    ],
    answer: 1,
    explanation:
      "Trong Generics, `extends` được sử dụng cho cả class và interface để chỉ ra quan hệ `IS-A` [23, 24].",
  },
  {
    id: 1387,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `MyInterface` có `default void setup()`, và class `C` implement `MyInterface`. `C` có thể sử dụng annotation `@Override` khi triển khai `setup()` không?",
    options: [
      "Có, nếu muốn ghi đè implementation mặc định.",
      "Không, vì nó không phải là phương thức trừu tượng.",
      "Chỉ khi phương thức đó là `final`.",
      "Luôn luôn bắt buộc.",
    ],
    answer: 0,
    explanation:
      "Annotation `@Override` có thể được sử dụng khi ghi đè phương thức `default`.",
  },
  {
    id: 1388,
    topic: "Interface",
    type: "radio",
    question: "Sự khác biệt giữa `Collection` và `Collections` (có 's') là gì?",
    options: [
      "`Collection` là một class; `Collections` là một interface.",
      "`Collection` là một interface; `Collections` là một class tiện ích có `static` methods.",
      "Cả hai đều là interface.",
      "Cả hai đều là class.",
    ],
    answer: 1,
    explanation:
      "`Collection` là một root interface [36]. `Collections` là một class tiện ích (ví dụ: `Collections.sort()` [49]) chứa các phương thức `static`.",
  },
  {
    id: 1389,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu `Iterator` là interface, phương thức `next()` trong nó có mục đích gì?",
    options: [
      "Trả về phần tử tiếp theo trong collection.",
      "Thiết lập phần tử tiếp theo.",
      "Kiểm tra xem có phần tử tiếp theo không.",
      "Loại bỏ phần tử.",
    ],
    answer: 0,
    explanation:
      "Phương thức `next()` trong `Iterator` trả về phần tử tiếp theo [34, 37].",
  },
  {
    id: 1390,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `java.io.Serializable`, và class con của nó không làm gì thêm. Class con đó có được tuần tự hóa không?",
    options: [
      "Có, vì tính chất `Serializable` được kế thừa.",
      "Không, class con phải khai báo rõ ràng.",
      "Chỉ khi class con có phương thức `default`.",
      "Chỉ khi class con là `abstract`.",
    ],
    answer: 0,
    explanation: "Tính chất `Serializable` (từ interface) được kế thừa.",
  },
  {
    id: 1391,
    topic: "Interface",
    type: "radio",
    question: "Trong Generics, `List<? super Integer>` được gọi là gì?",
    options: [
      "Upper bounded wildcard.",
      "Unbounded wildcard.",
      "Lower bounded wildcard.",
      "Type parameter.",
    ],
    answer: 2,
    explanation:
      "`? super Type` là lower bounded wildcard, giới hạn kiểu phải là siêu kiểu của kiểu được chỉ định [109].",
  },
  {
    id: 1392,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc một class triển khai nhiều interface?",
    options: [
      "Chỉ có thể có một phương thức `default` duy nhất.",
      "Nó có thể có nhiều vai trò (roles) khác nhau.",
      "Nó làm cho class đó không thể kế thừa.",
      "Nó làm cho class đó trở thành abstract class.",
    ],
    answer: 1,
    explanation:
      "Interface định nghĩa vai trò (role) [15]. Implement nhiều interface cho phép class đóng nhiều vai trò khác nhau [14, 15].",
  },
  {
    id: 1393,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `static void utility()`. `utility()` có thể được gọi thông qua object `o` của class triển khai `I` không?",
    options: [
      "Có, `o.utility()`.",
      "Không, phải dùng `I.utility()`.",
      "Chỉ khi `utility()` là `default`.",
      "Chỉ khi `o` là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `static` thuộc về interface và phải được gọi bằng tên interface [18, 81].",
  },
  {
    id: 1394,
    topic: "Interface",
    type: "radio",
    question: "Khi nào ta nên sử dụng Interface thay vì Abstract Class?",
    options: [
      "Khi cần định nghĩa các trường `private`.",
      "Khi cần định nghĩa một template cho một nhóm subclass với implementation code chung.",
      "Khi cần định nghĩa một vai trò mà các class từ các cây kế thừa khác nhau có thể chơi.",
      "Khi cần ngăn chặn việc đa kế thừa.",
    ],
    answer: 2,
    explanation:
      "Interface được dùng để định nghĩa một vai trò, cho phép các class không liên quan về mặt kế thừa (từ các cây khác nhau) implement [18, 19].",
  },
  {
    id: 1395,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Comparable` được sử dụng để làm gì trong phương thức `Collections.sort(List)`?",
    options: [
      "Cho phép `List` chấp nhận các kiểu khác nhau.",
      "Cung cấp cách thức so sánh để sắp xếp `List` theo thứ tự tự nhiên.",
      "Buộc các phần tử phải là `String`.",
      "Chỉ hoạt động với `ArrayList`.",
    ],
    answer: 1,
    explanation:
      "Interface `Comparable` định nghĩa thứ tự tự nhiên, được sử dụng bởi `Collections.sort()` [47, 49].",
  },
  {
    id: 1396,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu ta khai báo `interface I { int SIZE = 1; }`. Điều gì xảy ra nếu ta không khởi tạo `SIZE`?",
    options: [
      "Trình biên dịch gán giá trị mặc định 0.",
      "Lỗi biên dịch, vì `final` field phải được khởi tạo.",
      "Trình biên dịch gán giá trị `null`.",
      "Nó trở thành `abstract` field.",
    ],
    answer: 1,
    explanation:
      "Các trường là `final` [4, 57] và phải được khởi tạo khi khai báo.",
  },
  {
    id: 1397,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức nào trong interface `Iterator` được sử dụng để loại bỏ phần tử hiện tại khỏi collection?",
    options: ["delete()", "remove()", "clear()", "pop()"],
    answer: 1,
    explanation: "Interface `Iterator` có phương thức `remove()` [37].",
  },
  {
    id: 1398,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng `interface` trong Composite Pattern?",
    options: [
      "Đảm bảo các đối tượng Leaf và Composite có thể được xử lý đồng nhất.",
      "Giới hạn số lượng leaf node.",
      "Buộc các leaf node phải là `final`.",
      "Ngăn chặn việc đa kế thừa.",
    ],
    answer: 0,
    explanation:
      "Composite Pattern sử dụng interface Component (`FileSystemItem`) để đảm bảo tính đồng nhất (uniformity) khi xử lý cả leaf (File) và composite (Directory) [30, 110].",
  },
  {
    id: 1399,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Queue` tuân theo nguyên tắc nào về thứ tự xử lý dữ liệu?",
    options: [
      "LIFO (Last-In, First-Out).",
      "FIFO (First-In, First-Out).",
      "Random access.",
      "Indexed access.",
    ],
    answer: 1,
    explanation:
      "Queue là cấu trúc dữ liệu First-In, First-Out (FIFO) [111, 112].",
  },
  {
    id: 1400,
    topic: "Interface",
    type: "radio",
    question: "Interface `Iterator` được định nghĩa trong package nào?",
    options: ["java.io", "java.util", "java.lang", "java.sql"],
    answer: 1,
    explanation:
      "Iterator nằm trong `java.util` (Được sử dụng trong các ví dụ `import java.util.*`) [34, 37, 113].",
  },
  {
    id: 1401,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void init()`. Điều gì là đúng về việc class `C` override `init()`?",
    options: [
      "`C` có thể giảm quyền truy cập thành `protected`.",
      "`C` có thể tăng quyền truy cập thành `private`.",
      "`C` phải giữ quyền truy cập là `public`.",
      "`C` phải là `abstract`.",
    ],
    answer: 2,
    explanation:
      "Phương thức `default` là `public` [4]. Ghi đè phương thức không được phép giảm quyền truy cập [69].",
  },
  {
    id: 1402,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì xảy ra nếu một class triển khai `java.io.Serializable` nhưng không khai báo `serialVersionUID`?",
    options: [
      "Lỗi biên dịch.",
      "Lỗi runtime.",
      "JVM sẽ tự động tạo một ID, nhưng điều này có thể gây ra lỗi versioning khi deserialization.",
      "Quá trình serialization sẽ bị bỏ qua.",
    ],
    answer: 2,
    explanation:
      "JVM tự động tạo `serialVersionUID` nếu không được cung cấp, nhưng điều này có thể làm serialization thất bại khi class thay đổi [114, 115].",
  },
  {
    id: 1403,
    topic: "Interface",
    type: "radio",
    question:
      "Interface nào được sử dụng để định nghĩa 'job' cho thread trong Java?",
    options: ["Comparable", "Iterator", "Runnable", "Serializable"],
    answer: 2,
    explanation:
      "Interface `Runnable` được dùng để định nghĩa job cho thread [18, 63].",
  },
  {
    id: 1404,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `Comparable<T>`, nó phải định nghĩa thứ tự tự nhiên dựa trên cái gì?",
    options: [
      "Các trường `static`.",
      "Các đối số constructor.",
      "Logic của phương thức `compareTo()`.",
      "Quy tắc mặc định của `Object`.",
    ],
    answer: 2,
    explanation: "Logic so sánh nằm trong `compareTo()` [22, 48, 116].",
  },
  {
    id: 1405,
    topic: "Interface",
    type: "radio",
    question: "Interface có thể được sử dụng để mô tả một class như thế nào?",
    options: [
      "Một class có thể được khởi tạo.",
      "Một class có thể được kế thừa.",
      "Một class có thể được 'lưu' (`Saveable`).",
      "Một class có thể có các trường `private`.",
    ],
    answer: 2,
    explanation:
      "Interface định nghĩa vai trò (ví dụ: `Saveable` là một interface mà `Dog` có thể implement) [14, 18].",
  },
  {
    id: 1406,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là bắt buộc đối với tất cả các phương thức trừu tượng trong interface?",
    options: [
      "Phải có ít nhất một tham số.",
      "Không được có implementation (thân hàm).",
      "Phải được đánh dấu là `final`.",
      "Phải trả về `void`.",
    ],
    answer: 1,
    explanation: "Phương thức abstract không có thân hàm [12, 25, 53].",
  },
  {
    id: 1407,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `List` định nghĩa phương thức nào để lấy phần tử tại vị trí index cụ thể?",
    options: [
      "pop()",
      "get(int index)",
      "indexOf(Object o)",
      "poll(int index)",
    ],
    answer: 1,
    explanation:
      "Phương thức `get(int index)` trả về phần tử tại vị trí được chỉ định [73].",
  },
  {
    id: 1408,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I` có `default void action()`. `C` có thể override `action()` và đặt là `final` không?",
    options: [
      "Không, vì `default` method không phải là `final`.",
      "Có, để ngăn chặn class con ghi đè phương thức đó.",
      "Chỉ khi `C` là `abstract`.",
      "Chỉ khi `action()` không phải là `default`.",
    ],
    answer: 1,
    explanation:
      "Phương thức có thể được đánh dấu là `final` để ngăn chặn ghi đè trong subclass [86, 99].",
  },
  {
    id: 1409,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `static final int MAX = 100`. Nếu class `C` implement `I`, `MAX` được gọi là gì trong `C`?",
    options: [
      "Instance variable.",
      "Class constant.",
      "Local variable.",
      "Default value.",
    ],
    answer: 1,
    explanation: "`static final` field là hằng số cấp class [4, 57].",
  },
  {
    id: 1410,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, `Pair<? extends Animal>` được sử dụng để làm gì?",
    options: [
      "Hạn chế Pair chỉ chứa các đối tượng kiểu Animal.",
      "Cho phép Pair chứa các đối tượng là subtype của Animal (upper bound).",
      "Buộc Pair phải là kiểu `abstract`.",
      "Cho phép Pair chứa các đối tượng là supertype của Animal (lower bound).",
    ],
    answer: 1,
    explanation:
      "`? extends Animal` là upper bounded wildcard, cho phép chứa các subtype của Animal [43, 117].",
  },
  {
    id: 1411,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc sử dụng interface để định nghĩa API?",
    options: [
      "Nó làm cho API trở nên phức tạp hơn.",
      "Nó định nghĩa các hàm `public` cho các class triển khai.",
      "Nó giới hạn tính đa hình.",
      "Nó buộc tất cả các class phải là `private`.",
    ],
    answer: 1,
    explanation:
      "Interface là 'hợp đồng' hoặc 'public interface' [11, 118] định nghĩa các phương thức `public` [4, 16].",
  },
  {
    id: 1412,
    topic: "Interface",
    type: "radio",
    question: "Trong Adapter Pattern, Interface đóng vai trò là gì?",
    options: [
      "Lớp cần được thích ứng (Adaptee).",
      "Lớp cầu nối (Adapter).",
      "Giao diện mục tiêu (Target interface).",
      "Client.",
    ],
    answer: 2,
    explanation:
      "Adapter Pattern kết nối đối tượng có interface không tương thích với 'Target interface' (interface mà client mong đợi) [106, 107].",
  },
  {
    id: 1413,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về phương thức `static` và `default` trong interface (JDK 8+)?",
    options: [
      "Cả hai đều không thể bị override.",
      "Chỉ phương thức `static` không thể bị override.",
      "Cả hai đều phải được khai báo `final`.",
      "Cả hai đều là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `static` không thể bị override [88], nhưng phương thức `default` thì có thể [4].",
  },
  {
    id: 1414,
    topic: "Interface",
    type: "radio",
    question: "Interface `Comparable` hữu ích nhất cho việc gì?",
    options: [
      "Quản lý bộ nhớ.",
      "Phân luồng.",
      "Sắp xếp Collection.",
      "Xử lý I/O.",
    ],
    answer: 2,
    explanation:
      "`Comparable` được sử dụng để định nghĩa thứ tự cho việc sắp xếp [45, 47, 49].",
  },
  {
    id: 1415,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I`, và ta muốn class con của `C` phải override một phương thức trừu tượng từ `I`. `C` nên làm gì?",
    options: [
      "`C` không nên triển khai phương thức đó và giữ nó là `abstract`.",
      "`C` nên định nghĩa lại phương thức đó là `final`.",
      "`C` nên định nghĩa lại phương thức đó là `static`.",
      "`C` nên định nghĩa lại phương thức đó là `private`.",
    ],
    answer: 0,
    explanation:
      "Nếu class `C` không triển khai phương thức đó, nó phải là `abstract` và buộc class con concrete phải triển khai [53, 66].",
  },
  {
    id: 1416,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, việc sử dụng `implements` giúp tránh lỗi biên dịch do không thể kế thừa nhiều class?",
    options: [
      "Khi cần kế thừa các fields `private`.",
      "Khi cần kết hợp hành vi từ nhiều interface khác nhau.",
      "Khi cần sử dụng `default` constructor.",
      "Khi cần sử dụng đa hình của abstract class.",
    ],
    answer: 1,
    explanation:
      "Interface là giải pháp cho đa kế thừa, cho phép class kết hợp hành vi (hợp đồng) từ nhiều interface [6, 11].",
  },
  {
    id: 1417,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void action()`, và class `C` implement `I` và override `action()` thành `public void action()`. Access modifier của phương thức trong `C` là gì?",
    options: ["protected", "default (package-private)", "public", "private"],
    answer: 2,
    explanation:
      "Phương thức `default` là `public` [4]. Việc override phải giữ hoặc tăng quyền truy cập [69].",
  },
  {
    id: 1418,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Iterator` có phương thức nào để chuyển sang phần tử tiếp theo?",
    options: ["moveNext()", "forward()", "next()", "poll()"],
    answer: 2,
    explanation:
      "Phương thức `next()` trong `Iterator` trả về phần tử tiếp theo [34, 37].",
  },
  {
    id: 1419,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về các fields `public static final` trong interface?",
    options: [
      "Chúng có thể được gọi là instance variables.",
      "Chúng có thể được gọi là hằng số (constants).",
      "Chúng không thể được khởi tạo.",
      "Chúng chỉ có thể là kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation: "Các trường `final` là hằng số [4, 57, 79, 80].",
  },
  {
    id: 1420,
    topic: "Interface",
    type: "radio",
    question: "Sự khác biệt chính giữa abstract class và interface là gì?",
    options: [
      "Abstract class không thể có constructor, interface thì có.",
      "Abstract class có thể có fields non-static; interface thì không.",
      "Interface có thể implement nhiều interface khác, abstract class thì không.",
      "Interface có thể được khởi tạo, abstract class thì không.",
    ],
    answer: 1,
    explanation:
      "Abstract class có thể có instance variables (non-static fields) [19] và constructor [119], còn interface thì không (fields luôn là `static`) [4, 8, 57].",
  },
  {
    id: 1421,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Serializable` là một ví dụ về 'marker interface' vì sao?",
    options: [
      "Nó có nhiều phương thức để đánh dấu trạng thái.",
      "Nó không chứa bất kỳ phương thức nào để triển khai (chỉ là đánh dấu).",
      "Nó đánh dấu đối tượng là `abstract`.",
      "Nó chỉ có `default` method.",
    ],
    answer: 1,
    explanation:
      "Marker interface không định nghĩa phương thức nào (mặc dù các nguồn không mô tả chi tiết `Serializable` không có phương thức, nhưng đây là định nghĩa của marker interface).",
  },
  {
    id: 1422,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng interface để định nghĩa các phương thức trừu tượng?",
    options: [
      "Nó là cách duy nhất để định nghĩa trừu tượng trong Java.",
      "Nó tạo ra một hợp đồng không ràng buộc về implementation.",
      "Nó tạo ra hợp đồng mà các lớp triển khai phải tuân thủ nghiêm ngặt.",
      "Nó chỉ áp dụng cho các phương thức `private`.",
    ],
    answer: 2,
    explanation:
      "Interface định nghĩa một hợp đồng [11, 118] và class triển khai phải thực hiện tất cả các phương thức abstract [4, 16].",
  },
  {
    id: 1423,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I` có `static final int TIMEOUT = 500`. Cú pháp nào là KHÔNG hợp lệ để truy cập `TIMEOUT`?",
    options: ["I.TIMEOUT", "C.TIMEOUT", "new C().TIMEOUT", "TIMEOUT (trong C)"],
    answer: 2,
    explanation:
      "Vì `TIMEOUT` là `static` [4, 57], truy cập thông qua đối tượng (instance) là không chuẩn và có thể gây lỗi biên dịch.",
  },
  {
    id: 1424,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, việc sử dụng `List<T extends Interface>` có ý nghĩa gì?",
    options: [
      "List phải chứa các đối tượng extend `Interface`.",
      "List phải chứa các đối tượng implement `Interface`.",
      "List có thể chứa các đối tượng là supertype của `Interface`.",
      "List chỉ có thể chứa các đối tượng là `Object`.",
    ],
    answer: 1,
    explanation:
      "Trong Generics, `extends` có nghĩa là 'extends hoặc implements' (IS-A) [24].",
  },
  {
    id: 1425,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void start()`. Class `C` implement `I` và gọi `start()`. Phân tích binding của phương thức này?",
    options: [
      "Static binding.",
      "Dynamic binding.",
      "Constructor binding.",
      "Final binding.",
    ],
    answer: 1,
    explanation:
      "Các phương thức `default` (tương tự như phương thức instance) được phân giải (bound) trong runtime (dynamic binding), dựa trên kiểu đối tượng thực tế.",
  },
  {
    id: 1426,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Iterator` có phương thức nào được sử dụng để lấy phần tử tiếp theo?",
    options: ["getNext()", "get()", "next()", "peek()"],
    answer: 2,
    explanation: "Phương thức `next()` trong `Iterator` [34, 37].",
  },
  {
    id: 1427,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc một class triển khai hai interface `I1` và `I2`?",
    options: [
      "Nó có thể gọi các phương thức `default` từ cả hai mà không có xung đột.",
      "Nó có thể định nghĩa lại các trường `static final` của interface.",
      "Nó phải giải quyết mọi xung đột phương thức bằng cách override.",
      "Nó phải là `abstract`.",
    ],
    answer: 2,
    explanation:
      "Nếu có xung đột phương thức (đặc biệt là `default` methods từ JDK 8+), class triển khai phải override để giải quyết [6].",
  },
  {
    id: 1428,
    topic: "Interface",
    type: "radio",
    question: "Interface nào được sử dụng để tuần tự hóa một đối tượng?",
    options: [
      "java.lang.Cloneable",
      "java.io.Serializable",
      "java.util.Scanner",
      "java.lang.Thread",
    ],
    answer: 1,
    explanation: "Interface `java.io.Serializable` [38, 39].",
  },
  {
    id: 1429,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `Comparable`, nó phải implement phương thức `compareTo()` với access modifier nào?",
    options: ["private", "protected", "default", "public"],
    answer: 3,
    explanation:
      "Phương thức interface là ngầm định `public` [4, 16]. Việc triển khai không được giảm quyền truy cập [69].",
  },
  {
    id: 1430,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về phương thức `default` trong interface?",
    options: [
      "Nó có thể được khai báo là `abstract`.",
      "Nó có thể có các trường `private`.",
      "Nó là phương thức instance (không phải static).",
      "Nó không thể được gọi từ class triển khai.",
    ],
    answer: 2,
    explanation:
      "Phương thức `default` được kế thừa và gọi trên instance [64].",
  },
  {
    id: 1431,
    topic: "Interface",
    type: "radio",
    question:
      "Sự khác biệt giữa `implements` và `extends` khi nói đến việc sử dụng interface trong Generics là gì?",
    options: [
      "`implements` chỉ dùng cho interface; `extends` chỉ dùng cho class.",
      "Trong Generics, chỉ `extends` được sử dụng cho cả hai.",
      "Chỉ `implements` được sử dụng cho cả hai.",
      "Chúng là các từ khóa đồng nghĩa.",
    ],
    answer: 1,
    explanation:
      "Trong Generics, `extends` có nghĩa là 'extends hoặc implements' (IS-A) [23, 24].",
  },
  {
    id: 1432,
    topic: "Interface",
    type: "radio",
    question:
      "Tính chất `static` của các trường trong interface đảm bảo điều gì về mặt bộ nhớ?",
    options: [
      "Mỗi đối tượng có một vị trí bộ nhớ riêng.",
      "Chỉ có một vị trí bộ nhớ được chia sẻ bởi tất cả các class triển khai.",
      "Chúng được lưu trữ trên Stack.",
      "Chúng được lưu trữ trên Garbage Collector.",
    ],
    answer: 1,
    explanation:
      "`static` fields được lưu trữ trong class (hoặc interface) và chia sẻ giữa tất cả các instance [19, 81, 83].",
  },
  {
    id: 1433,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `static void run()`, class `C` implement `I`. `C` có thể định nghĩa `void run()` không?",
    options: [
      "Có, đây là overloading.",
      "Có, đây là shadowing.",
      "Có, đây là overriding.",
      "Có, đây là hiding.",
    ],
    answer: 1,
    explanation:
      "Định nghĩa một phương thức instance trùng tên với phương thức static của supertype được gọi là shadowing hoặc hiding, nhưng nó không phải là overloading hoặc overriding (vì static methods không thể override) [88].",
  },
  {
    id: 1434,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, việc sử dụng interface có thể thay thế việc sử dụng abstract class?",
    options: [
      "Khi cần định nghĩa các fields non-static.",
      "Khi không cần implementation code chung (trước JDK 8).",
      "Khi cần định nghĩa constructor.",
      "Khi cần định nghĩa các fields `private`.",
    ],
    answer: 1,
    explanation:
      "Interface là 100% abstract class [9, 10]. Nếu không cần implementation code chung hoặc state, interface là lựa chọn tốt hơn.",
  },
  {
    id: 1435,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về `public static final` trong interface?",
    options: [
      "Chúng là các biến `final` của đối tượng.",
      "Chúng là các hằng số không thể bị thay đổi.",
      "Chúng có thể được gán giá trị sau khi đối tượng được tạo.",
      "Chúng chỉ có thể là kiểu `int`.",
    ],
    answer: 1,
    explanation: "Là hằng số (`final`) và không thể thay đổi [4, 57, 79].",
  },
  {
    id: 1436,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void action()`, và class `C` implement `I` và override `action()` thành `public void action() { I.super.action(); }`. Điều này gọi là gì?",
    options: [
      "Constructor chaining.",
      "Delegate to interface default implementation.",
      "Shadowing.",
      "Re-serialization.",
    ],
    answer: 1,
    explanation:
      "Đây là việc class `C` gọi lại implementation mặc định của interface (ủy quyền).",
  },
  {
    id: 1437,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng `List<E>` thay vì `ArrayList<E>` trong khai báo tham số?",
    options: [
      "Giới hạn tham số thành `List`.",
      "Tăng tính linh hoạt để chấp nhận bất kỳ class nào triển khai `List`.",
      "Đảm bảo rằng chỉ `ArrayList` được sử dụng.",
      "Giảm thiểu sự cần thiết của `implements`.",
    ],
    answer: 1,
    explanation:
      "Lập trình với kiểu interface (List) thay vì kiểu concrete (ArrayList) tăng tính linh hoạt [18, 19].",
  },
  {
    id: 1438,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `int MAX = 10`. Class `C` implement `I`. Nếu `C` muốn sử dụng một biến `MAX` của riêng mình, điều gì cần thiết?",
    options: [
      "`C` phải khai báo `MAX` là `private`.",
      "`C` phải sử dụng tên khác cho biến của mình, hoặc truy cập `I.MAX` nếu cần hằng số của interface.",
      "Không thể, vì `MAX` đã được kế thừa.",
      "`C` phải là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Hằng số `MAX` được kế thừa (hoặc nhập tĩnh). Nếu muốn có biến riêng, cần đổi tên hoặc che giấu tên. Nếu muốn dùng hằng số của interface, cần truy cập rõ ràng `I.MAX`.",
  },
  {
    id: 1439,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc một interface có thể `extend` nhiều interface khác?",
    options: [
      "Nó cho phép đa kế thừa code.",
      "Nó cho phép tổng hợp nhiều hợp đồng (contracts).",
      "Nó gây ra lỗi biên dịch.",
      "Nó chỉ hoạt động với `default` methods.",
    ],
    answer: 1,
    explanation:
      "Interface có thể extend nhiều interface [4, 21], tổng hợp các hợp đồng (phương thức abstract) thành một hợp đồng lớn hơn.",
  },
  {
    id: 1440,
    topic: "Interface",
    type: "radio",
    question: "Phương thức `default` trong interface được gọi là gì?",
    options: [
      "Abstract method.",
      "Instance method.",
      "Static method.",
      "Private method.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` được kế thừa và gọi trên instance, do đó nó là phương thức instance [64].",
  },
  {
    id: 1441,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement interface `I`, và `I` có phương thức trừu tượng `void process()`. Điều gì xảy ra nếu `C` không khai báo `public` khi triển khai `process()`?",
    options: [
      "Trình biên dịch gán `public` tự động.",
      "Lỗi biên dịch do giảm quyền truy cập.",
      "Phương thức đó trở thành `private`.",
      "Phương thức đó trở thành `static`.",
    ],
    answer: 1,
    explanation:
      "Phương thức trừu tượng interface là `public` [4, 16]. Không khai báo `public` sẽ dẫn đến `default` (package-private), là giảm quyền truy cập [70], gây lỗi biên dịch.",
  },
  {
    id: 1442,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về các trường `public static final` trong interface?",
    options: [
      "Chúng có thể được sử dụng để lưu trữ state của object.",
      "Chúng phải được gán giá trị sau khi object được tạo.",
      "Chúng là hằng số chia sẻ, không phải là state của object.",
      "Chúng được lưu trữ trên Stack.",
    ],
    answer: 2,
    explanation:
      "Chúng là hằng số cấp class, không phải state của object [4, 57].",
  },
  {
    id: 1443,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `Comparable`, và ta dùng `Collections.sort(List<C>)`. `Comparable` sẽ được gọi như thế nào?",
    options: [
      "Thông qua `Comparator`.",
      "Thông qua phương thức `compareTo()` trên các phần tử của List.",
      "Thông qua phương thức `default`.",
      "Thông qua phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "`Collections.sort()` gọi `compareTo()` trên các phần tử nếu chúng implement `Comparable` [47, 49].",
  },
  {
    id: 1444,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Generics, nếu `I` là interface, khai báo `Pair<I>` có ý nghĩa gì?",
    options: [
      "Chỉ có thể tạo object từ `I`.",
      "Pair có thể chứa các đối tượng có kiểu là `I` hoặc triển khai `I`.",
      "`Pair` phải là abstract.",
      "Không được phép.",
    ],
    answer: 1,
    explanation:
      "Tham số kiểu `I` trong Generics cho phép Pair chứa các đối tượng là subtype của `I` hoặc implement `I`.",
  },
  {
    id: 1445,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc sử dụng phương thức `default` để cung cấp implementation?",
    options: [
      "Nó cho phép interface có state (fields non-static).",
      "Nó cho phép các class triển khai chia sẻ implementation code.",
      "Nó chỉ hoạt động cho các phương thức `private`.",
      "Nó là giải pháp cho vấn đề deadlock.",
    ],
    answer: 1,
    explanation: "Phương thức `default` cung cấp code reuse [4, 64].",
  },
  {
    id: 1446,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface được thiết kế để định nghĩa hằng số, điều gì là quan trọng nhất?",
    options: [
      "Các phương thức phải là `default`.",
      "Các fields phải là `public static final`.",
      "Nó phải có constructor.",
      "Nó phải implement `Serializable`.",
    ],
    answer: 1,
    explanation:
      "Định nghĩa hằng số yêu cầu fields là `public static final` [4, 57, 80].",
  },
  {
    id: 1447,
    topic: "Interface",
    type: "radio",
    question:
      "Trong Pattern Design, interface được sử dụng để đạt được tính chất nào của SOLID?",
    options: [
      "Single Responsibility Principle (SRP).",
      "Open/Closed Principle (OCP) và Dependency Inversion Principle (DIP).",
      "Liskov Substitution Principle (LSP).",
      "Interface Segregation Principle (ISP).",
    ],
    answer: 1,
    explanation:
      "Interface là công cụ chính cho DIP và OCP (mở để mở rộng, đóng để sửa đổi) [120].",
  },
  {
    id: 1448,
    topic: "Interface",
    type: "radio",
    question:
      "Mặc dù Interface là 100% abstract class (trước JDK 8), nó khác biệt với abstract class ở điểm nào?",
    options: [
      "Interface cho phép đa kế thừa (hợp đồng), abstract class thì không.",
      "Abstract class không thể có phương thức trừu tượng.",
      "Interface có thể được khởi tạo.",
      "Abstract class không thể có hằng số.",
    ],
    answer: 0,
    explanation:
      "Interface được dùng để đạt được đa kế thừa (hợp đồng) [4, 6].",
  },
  {
    id: 1449,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về mối quan hệ giữa một abstract class và một interface?",
    options: [
      "Abstract class có thể implement nhiều interface.",
      "Interface có thể extend abstract class.",
      "Abstract class không thể extend class khác.",
      "Interface không thể có Generics.",
    ],
    answer: 0,
    explanation:
      "Abstract class là class, có thể implement nhiều interface [8, 14].",
  },
  {
    id: 1450,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một class triển khai `java.io.Serializable`, nó đang nói với JVM điều gì?",
    options: [
      "Đối tượng có thể chạy trên thread riêng.",
      "Đối tượng có thể được lưu trữ và khôi phục (persistence).",
      "Đối tượng không thể thay đổi.",
      "Đối tượng phải được so sánh.",
    ],
    answer: 1,
    explanation:
      "Serialization được sử dụng để lưu trữ object state (persistence) [38, 97].",
  },
  {
    id: 1451,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa nào được sử dụng để chỉ ra rằng một class cam kết với một interface?",
    options: ["implements", "uses", "extends", "links"],
    answer: 0,
    explanation: "Từ khóa `implements` [7, 8, 13].",
  },
  {
    id: 1452,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `I1, I2`. `C` phải override bao nhiêu phương thức nếu `I1` có 3 abstract methods và `I2` có 2 abstract methods (không trùng lặp)?",
    options: ["2", "3", "5", "6"],
    answer: 2,
    explanation: "Class phải implement tất cả 5 phương thức abstract [4, 16].",
  },
  {
    id: 1453,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về các trường `public static final` trong interface?",
    options: [
      "Chúng được gọi là instance variables.",
      "Chúng phải được khai báo `private`.",
      "Chúng là hằng số cấp class.",
      "Chúng không thể được truy cập bên ngoài class.",
    ],
    answer: 2,
    explanation: "Là hằng số cấp class (`static`) [4, 57].",
  },
  {
    id: 1454,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void action()`. `I` có thể có thêm `static void run()` không?",
    options: [
      "Không, vì xung đột.",
      "Có, interface có thể có cả `default` và `static` methods (từ JDK 8+).",
      "Chỉ khi `action()` là `final`.",
      "Chỉ khi `run()` là `abstract`.",
    ],
    answer: 1,
    explanation:
      "Interface có thể chứa cả `default` và `static` methods [4, 64].",
  },
  {
    id: 1455,
    topic: "Interface",
    type: "radio",
    question:
      "Khi sử dụng `implements`, class đó đang định nghĩa mối quan hệ `IS-A` nào?",
    options: [
      "Kế thừa code.",
      "Vai trò (role).",
      "Composition.",
      "Association.",
    ],
    answer: 1,
    explanation:
      "Interface định nghĩa vai trò (role) mà class có thể chơi [15].",
  },
  {
    id: 1456,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void action()`. `I` có thể có thêm `abstract void perform()` không?",
    options: [
      "Có, interface có thể chứa cả hai loại phương thức.",
      "Không, nếu có `default` method thì không thể có `abstract` method.",
      "Chỉ khi `perform()` là `static`.",
      "Chỉ khi `action()` là `final`.",
    ],
    answer: 0,
    explanation:
      "Interface có thể chứa cả phương thức `abstract` (ngầm định) và phương thức `default` (từ JDK 8+) [4, 64].",
  },
  {
    id: 1457,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng các trường `final` trong interface?",
    options: [
      "Ngăn chặn class triển khai ghi đè chúng.",
      "Đảm bảo giá trị của chúng không thay đổi.",
      "Cho phép chúng được khởi tạo sau này.",
      "Cho phép chúng là `private`.",
    ],
    answer: 1,
    explanation: "`final` đảm bảo tính bất biến (không thay đổi) [4, 57, 79].",
  },
  {
    id: 1458,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `Comparable`, và ta so sánh hai object `c1` và `c2`. Nếu `c1.compareTo(c2)` trả về 0, điều đó có nghĩa là gì?",
    options: [
      "`c1` nhỏ hơn `c2`.",
      "`c1` lớn hơn `c2`.",
      "`c1` bằng `c2`.",
      "Lỗi.",
    ],
    answer: 2,
    explanation:
      "Trả về Zero khi đối tượng `this` được coi là bằng đối tượng được chỉ định [48].",
  },
  {
    id: 1459,
    topic: "Interface",
    type: "radio",
    question: "Interface `Iterator` được sử dụng chủ yếu để làm gì?",
    options: [
      "Xử lý I/O.",
      "Duyệt qua các phần tử của collection.",
      "Định nghĩa các hàm toán học.",
      "Đảm bảo tính đa kế thừa.",
    ],
    answer: 1,
    explanation: "`Iterator` cho phép duyệt qua collection [37].",
  },
  {
    id: 1460,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `I1` (có `default void action()`) và `I2` (không có `action()`). `C` gọi `action()`. Điều gì xảy ra?",
    options: [
      "Xung đột `default` method.",
      "Thực thi thành công `action()` của `I1`.",
      "Lỗi biên dịch.",
      "`action()` trở thành `abstract`.",
    ],
    answer: 1,
    explanation:
      "Không có xung đột, phương thức `default` từ `I1` được kế thừa và thực thi.",
  },
  {
    id: 1461,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về các phương thức trong interface (trước JDK 8)?",
    options: [
      "Chúng có thể có thân hàm.",
      "Chúng có thể là `private`.",
      "Chúng ngầm định là `public abstract`.",
      "Chúng phải là `final`.",
    ],
    answer: 2,
    explanation: "Ngầm định `public` và `abstract` [4, 16, 84].",
  },
  {
    id: 1462,
    topic: "Interface",
    type: "radio",
    question:
      "Từ khóa `implements` có thể được sử dụng cùng với những từ khóa nào trong khai báo class?",
    options: ["extends", "final", "abstract", "Tất cả các đáp án trên."],
    answer: 3,
    explanation:
      "Cú pháp cho phép `abstract class C extends A implements I` hoặc `final class C extends A implements I`.",
  },
  {
    id: 1463,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `int X = 1`. Class `C` implement `I`. `X` có thể được truy cập như thế nào trong phương thức `main()` của `C`?",
    options: ["X", "C.X", "I.X", "Tất cả các đáp án trên."],
    answer: 3,
    explanation:
      "`X` là `public static final` [4, 57]. Có thể truy cập trực tiếp bằng tên ngắn (nếu không xung đột) hoặc tên kiểu.",
  },
  {
    id: 1464,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về `default` method trong interface?",
    options: [
      "Nó không thể có thân hàm.",
      "Nó cho phép thay đổi cấu trúc của interface mà không phá vỡ tính tương thích ngược.",
      "Nó phải được override trong class triển khai.",
      "Nó chỉ hoạt động cho các hằng số.",
    ],
    answer: 1,
    explanation:
      "`default` method được thêm vào để duy trì tính tương thích ngược khi thêm phương thức mới [4, 64].",
  },
  {
    id: 1465,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `I` có `default void action()`. Nếu class `D` extend `C`, `D` có thể gọi `action()` không?",
    options: [
      "Không, trừ khi `D` override.",
      "Có, vì `action()` được kế thừa từ `C`.",
      "Chỉ thông qua `I.super.action()`.",
      "Chỉ thông qua `I.action()`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `default` được kế thừa như phương thức instance bình thường [64].",
  },
  {
    id: 1466,
    topic: "Interface",
    type: "radio",
    question:
      "Trong trường hợp nào, `implements` được sử dụng để định nghĩa một mối quan hệ `IS-A`?",
    options: [
      "`Dog` implements `Animal`.",
      "`Dog` implements `Canine`.",
      "`Dog` implements `Pet`.",
      "`Dog` implements `Object`.",
    ],
    answer: 2,
    explanation:
      "Interface `Pet` định nghĩa vai trò `IS-A` cho `Dog` [14, 20, 58].",
  },
  {
    id: 1467,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về `public static final` khi class `C` implement interface `I`?",
    options: [
      "Chúng là các biến cục bộ trong `C`.",
      "Chúng được lưu trữ trên heap cho mỗi đối tượng `C`.",
      "Chúng là các hằng số được chia sẻ giữa tất cả các instance của `C` và các class khác.",
      "Chúng có thể bị ghi đè trong `C`.",
    ],
    answer: 2,
    explanation: "Là hằng số cấp class, được chia sẻ [4, 57, 81].",
  },
  {
    id: 1468,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu ta có `List<String> list = new ArrayList<>();`. Kiểu tham chiếu nào đang được sử dụng?",
    options: [
      "Kiểu concrete.",
      "Kiểu abstract class.",
      "Kiểu interface (Polymorphic).",
      "Kiểu primitive.",
    ],
    answer: 2,
    explanation:
      "List là một interface, tạo ra tham chiếu polymorphic [18, 36].",
  },
  {
    id: 1469,
    topic: "Interface",
    type: "radio",
    question:
      "Phương thức `compareTo()` trong `Comparable` được sử dụng để làm gì?",
    options: [
      "Định nghĩa thứ tự mặc định cho các đối tượng.",
      "Kiểm tra xem hai đối tượng có cùng tham chiếu không.",
      "Ép kiểu giữa hai đối tượng.",
      "Định nghĩa thứ tự ngẫu nhiên.",
    ],
    answer: 0,
    explanation:
      "`compareTo()` định nghĩa thứ tự tự nhiên (natural ordering) [22, 47].",
  },
  {
    id: 1470,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `I` có `default void action()`. `C` muốn override và ngăn chặn class con ghi đè. `C` phải sử dụng từ khóa nào?",
    options: ["abstract", "static", "final", "private"],
    answer: 2,
    explanation: "`final` method không thể bị override [86, 99].",
  },
  {
    id: 1471,
    topic: "Interface",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc đa kế thừa trong Java thông qua Interface?",
    options: [
      "Chỉ cho phép kế thừa implementation code.",
      "Cho phép kế thừa nhiều implementation code từ nhiều interface (từ JDK 8+).",
      "Không cho phép kế thừa bất kỳ code nào.",
      "Chỉ hoạt động cho các fields `private`.",
    ],
    answer: 1,
    explanation:
      "Interface (từ JDK 8+) có thể chứa implementation code thông qua `default` methods, cho phép các class kế thừa implementation từ nhiều interface [4, 64].",
  },
  {
    id: 1472,
    topic: "Interface",
    type: "radio",
    question: "Tại sao Java cấm đa kế thừa class?",
    options: [
      "Để thúc đẩy việc sử dụng Generics.",
      "Để ngăn chặn sự mơ hồ (ambiguity) và vấn đề DDD.",
      "Vì class không thể có constructor.",
      "Vì class không thể có phương thức `default`.",
    ],
    answer: 1,
    explanation:
      "Cấm đa kế thừa class để tránh ambiguity và vấn đề DDD [6, 8, 121].",
  },
  {
    id: 1473,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu một interface `I` có `static final int CONST = 100`. Class `C` implement `I`. Giá trị của `CONST` được thiết lập khi nào?",
    options: [
      "Khi `C` được khởi tạo.",
      "Khi `C` được load vào JVM.",
      "Khi `I` được load vào JVM.",
      "Khi đối tượng `C` được tạo.",
    ],
    answer: 2,
    explanation:
      "Fields `static` được khởi tạo khi class (hoặc interface) được load bởi JVM [80].",
  },
  {
    id: 1474,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `I` có `default void action()`. `C` muốn override và gọi `default` implementation. `C` cần làm gì?",
    options: [
      "Sử dụng `I.super.action()` bên trong phương thức override.",
      "Sử dụng `super.action()`.",
      "Không thể gọi implementation mặc định.",
      "Khai báo `action()` là `static`.",
    ],
    answer: 0,
    explanation:
      "Cú pháp để gọi phương thức `default` của interface từ class triển khai là `InterfaceName.super.methodName()`.",
  },
  {
    id: 1475,
    topic: "Interface",
    type: "radio",
    question: "Trong Generics, việc sử dụng `List<?>` được gọi là gì?",
    options: [
      "Unbounded wildcard.",
      "Bounded wildcard.",
      "Type parameter.",
      "Raw type.",
    ],
    answer: 0,
    explanation:
      "Wildcard `?` không có `extends` hoặc `super` là unbounded wildcard [72].",
  },
  {
    id: 1476,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu interface `I` có `default void start()`. `I` có thể có thêm `static void start()` không (overloading/hiding)?",
    options: [
      "Không, vì `default` method không thể bị che khuất bởi `static` method.",
      "Có, vì chữ ký phương thức khác nhau (phương thức static không có tham chiếu implicit `this`).",
      "Chỉ khi `start()` là `final`.",
      "Không, vì xung đột tên.",
    ],
    answer: 1,
    explanation:
      "Overloading/Hiding được phép giữa phương thức instance (default) và static nếu chữ ký khác nhau (phương thức static không có tham chiếu `this`).",
  },
  {
    id: 1477,
    topic: "Interface",
    type: "radio",
    question:
      "Interface `Iterable` (mà `Collection` extend) có phương thức nào để cung cấp `Iterator`?",
    options: ["next()", "iterator()", "get()", "list()"],
    answer: 1,
    explanation:
      "Interface `List` (và ngầm định là `Iterable`) có phương thức `iterator()` [34].",
  },
  {
    id: 1478,
    topic: "Interface",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc khai báo các trường trong interface?",
    options: [
      "Chúng là `private` và `mutable`.",
      "Chúng là `public static final`.",
      "Chúng không được khởi tạo.",
      "Chúng là `abstract`.",
    ],
    answer: 1,
    explanation: "Ngầm định `public static final` [4, 57].",
  },
  {
    id: 1479,
    topic: "Interface",
    type: "radio",
    question:
      "Nếu class `C` implement `I` có `default void action()`. `C` có thể override `action()` và gọi `super.action()` không?",
    options: [
      "Có.",
      "Không, phải dùng `I.super.action()`.",
      "Chỉ khi `action()` là `final`.",
      "Chỉ khi `action()` là `static`.",
    ],
    answer: 1,
    explanation:
      "Khi gọi phương thức `default` của interface, phải chỉ rõ tên interface (`I.super.action()`) [64].",
  },
  {
    id: 1480,
    topic: "Interface",
    type: "radio",
    question: "Interface `Runnable` chỉ có một phương thức là gì?",
    options: ["start()", "init()", "execute()", "run()"],
    answer: 3,
    explanation:
      "Runnable có một phương thức duy nhất: `public void run()` [63].",
  },
  {
    id: 1481,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích chính của Lớp Wrapper (Wrapper Class) trong Java là gì?",
    options: [
      "Định nghĩa các phương thức toán học tĩnh.",
      "Cung cấp các phương thức tiện ích cho các kiểu dữ liệu nguyên thủy (primitive types) bằng cách đóng gói chúng thành đối tượng.",
      "Lưu trữ các chuỗi ký tự không thể thay đổi.",
      "Thực hiện đa hình (Polymorphism).",
    ],
    answer: 1,
    explanation:
      "Lớp Wrapper gói gọn một kiểu dữ liệu nguyên thủy, mang lại cho nó vẻ ngoài của một đối tượng [1, 2]. Chúng bao bọc quanh tất cả các kiểu nguyên thủy để cung cấp thêm chức năng thông qua các phương thức [3].",
  },
  {
    id: 1482,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong Java, kiểu dữ liệu nguyên thủy (primitive type) 'int' tương ứng với lớp Wrapper nào?",
    options: ["Int", "Number", "Integer", "IntWrapper"],
    answer: 2,
    explanation:
      "Lớp Wrapper tương ứng cho kiểu nguyên thủy 'int' là Integer [3-5].",
  },
  {
    id: 1483,
    topic: "Data Structures",
    type: "radio",
    question: "Quá trình Autoboxing (Đóng hộp tự động) là gì?",
    options: [
      "Chuyển đổi một đối tượng Wrapper thành kiểu dữ liệu nguyên thủy tương ứng.",
      "Chuyển đổi tự động từ kiểu dữ liệu nguyên thủy sang đối tượng Wrapper tương ứng.",
      "Chuyển đổi một chuỗi String thành kiểu dữ liệu số.",
      "Chuyển đổi từ mảng Array sang ArrayList.",
    ],
    answer: 1,
    explanation:
      "Autoboxing là việc tự động chuyển đổi từ kiểu nguyên thủy sang kiểu Wrapper tương ứng, ví dụ như từ int sang Integer [6, 7].",
  },
  {
    id: 1484,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào, có sẵn trong tất cả các lớp Wrapper (trừ Character), được sử dụng để chuyển đổi một chuỗi String thành một đối tượng Wrapper?",
    options: [
      "parseInt(String s)",
      "valueOf(String s)",
      "stringValue()",
      "typeValue()",
    ],
    answer: 1,
    explanation:
      "Phương thức valueOf(String s) trả về một đối tượng của kiểu tương ứng chứa giá trị của String s. Phương thức này có sẵn trong tất cả các lớp Wrapper ngoại trừ Character [8, 9].",
  },
  {
    id: 1485,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để lấy giá trị nguyên thủy (primitive value) từ một đối tượng Wrapper (Unwrap)?",
    options: ["getPrimitive()", "typeValue()", "getValue()", "getRawValue()"],
    answer: 1,
    explanation:
      "Tất cả các lớp Wrapper đều có phương thức typeValue(). Phương thức này trả về giá trị của đối tượng dưới dạng kiểu nguyên thủy của nó [9, 10]. Ví dụ: int y = o.intValue() [8].",
  },
  {
    id: 1486,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức static nào của lớp Wrapper được dùng để chuyển đổi một chuỗi String thành giá trị nguyên thủy tương ứng?",
    options: [
      "parseType(String s)",
      "toPrimitive(String s)",
      "getPrimitiveValue(String s)",
      "unwrap(String s)",
    ],
    answer: 0,
    explanation:
      'Phương thức static parseType(String s) chuyển đổi một chuỗi thành giá trị của kiểu nguyên thủy tương ứng (ví dụ: Integer.parseInt("12")) [8].',
  },
  {
    id: 1487,
    topic: "Data Structures",
    type: "radio",
    question:
      'Nếu bạn cố gắng sử dụng Integer.parseInt("abc"), ngoại lệ nào có khả năng bị ném ra?',
    options: [
      "StringIndexOutOfBoundException",
      "IOException",
      "NullPointerException",
      "NumberFormatException",
    ],
    answer: 3,
    explanation:
      "NumberFormatException xảy ra khi không thể chuyển đổi một chuỗi thành định dạng số [11, 12]. Cụ thể, Integer.parseInt() hoạt động chỉ trên các chuỗi biểu diễn giá trị ASCII cho chữ số. Nếu bạn cố gắng phân tích cú pháp chuỗi như 'blurp', mã sẽ ném ra ngoại lệ runtime (NumberFormatException) [13].",
  },
  {
    id: 1488,
    topic: "Data Structures",
    type: "radio",
    question: "Autoboxing/Unboxing hoạt động trong những trường hợp nào?",
    options: [
      "Chỉ khi sử dụng các Collection Framework.",
      "Hầu như ở mọi nơi, cho phép sử dụng kiểu nguyên thủy hoặc kiểu Wrapper khi một trong hai được mong đợi.",
      "Chỉ với kiểu 'int' và 'Integer'.",
      "Chỉ khi kiểu dữ liệu được khai báo là 'final'.",
    ],
    answer: 1,
    explanation:
      "Autoboxing cho phép bạn sử dụng kiểu nguyên thủy hoặc kiểu Wrapper tương ứng ở hầu như bất cứ nơi nào một trong hai được mong đợi. Ví dụ, nó cho phép áp dụng toán tử tăng lên (increment operator) lên một tham chiếu đến đối tượng Integer (i++) [7, 14].",
  },
  {
    id: 1489,
    topic: "Data Structures",
    type: "code",
    question:
      "Điều gì xảy ra với đoạn code sau (giả sử nó nằm trong một phương thức hợp lệ)?",
    code: "int x = 42;\nArrayList list = new ArrayList();\nlist.add(x);",
    options: [
      "Chạy và thêm 42 dưới dạng int.",
      "Chạy và sử dụng Autoboxing để thêm 42 dưới dạng Integer.",
      "Lỗi biên dịch vì ArrayList không có phương thức add(int).",
      "Gây ra NullPointerException.",
    ],
    answer: 2,
    explanation:
      "Trước Java 5.0, ArrayList không có phương thức add(int), chỉ có add() chấp nhận Object references. Tuy nhiên, nếu sử dụng Java 5.0 trở lên, Autoboxing sẽ tự động chuyển đổi int x thành đối tượng Integer [15].",
  },
  {
    id: 1490,
    topic: "Data Structures",
    type: "radio",
    question:
      "Lớp Wrapper nào không nằm trong nhóm Number (Integer, Long, Byte, Short, Float, Double)?",
    options: ["Double", "Void", "Character", "Boolean"],
    answer: 2,
    explanation:
      "Các lớp cơ bản bao gồm Object, Boolean, Character, Void, Number, Math, String, StringBuffer. Trong Number có Integer, Short, Byte, Long, Float, Double. Do đó Character và Boolean không phải là lớp con của Number [4].",
  },
  {
    id: 1491,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong số các kiểu dữ liệu nguyên thủy sau, kiểu nào có lớp Wrapper tương ứng?",
    options: ["char", "String", "void", "array"],
    answer: 0,
    explanation:
      "Kiểu 'char' có lớp Wrapper là Character [3]. String là một class, không phải primitive type [16]. Void và Array cũng có lớp tương ứng (Void Class, Array Object) [4, 17].",
  },
  {
    id: 1492,
    topic: "Data Structures",
    type: "radio",
    question:
      "Quá trình nào được gọi là 'Unwrap' (Mở hộp) một đối tượng Wrapper?",
    options: [
      "Chuyển đổi một chuỗi thành số.",
      "Truy xuất kiểu dữ liệu nguyên thủy ban đầu từ đối tượng Wrapper.",
      "Gán một đối tượng cho một tham chiếu null.",
      "Tạo một đối tượng mới bằng từ khóa new.",
    ],
    answer: 1,
    explanation:
      "Các lớp Wrapper bao gồm các phương thức để 'unWrap' (mở hộp) đối tượng và truy xuất kiểu dữ liệu ban đầu [1].",
  },
  {
    id: 1493,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về lớp Character?",
    options: [
      "Nó hỗ trợ phương thức valueOf(String s).",
      "Nó có các phương thức tĩnh như isUpperCase(char ch).",
      "Nó là một kiểu dữ liệu nguyên thủy.",
      "Nó không có phương thức typeValue().",
    ],
    answer: 1,
    explanation:
      "Lớp Character có các phương thức tĩnh như isUppercase, isLowercase, isDigit, isLetter, toUpperCase, toLowerCase [18]. Nó không có valueOf() [9] nhưng có typeValue() [9].",
  },
  {
    id: 1494,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các phương thức 'parseXxx(String s)' (ví dụ: Integer.parseInt()) là gì?",
    options: [
      "Chuyển đổi kiểu nguyên thủy thành đối tượng Wrapper.",
      "Chuyển đổi kiểu nguyên thủy thành chuỗi String.",
      "Chuyển đổi chuỗi String thành kiểu dữ liệu nguyên thủy tương ứng.",
      "Chuyển đổi đối tượng Wrapper thành kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Phương thức parseType(String s) (tức là parseXxx) được sử dụng để chuyển đổi chuỗi thành kiểu dữ liệu nguyên thủy [8, 19].",
  },
  {
    id: 1495,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khẳng định nào sau đây là ĐÚNG về việc sử dụng kiểu Wrapper và Autoboxing?",
    options: [
      "Chỉ cho phép chuyển đổi từ Wrapper sang Primitive.",
      "Cho phép chuyển đổi chuỗi số thành kiểu số (number) và lưu trữ dữ liệu nguyên thủy trong một đối tượng.",
      "Không thể sử dụng các toán tử số học với đối tượng Wrapper.",
      "Luôn cần nhập (import) các lớp Wrapper vì chúng không thuộc gói java.lang.",
    ],
    answer: 1,
    explanation:
      "Các tính năng của lớp Wrapper bao gồm: chuyển đổi chuỗi số thành giá trị số, và lưu trữ dữ liệu nguyên thủy trong một đối tượng [9]. Wrapper Classes nằm trong gói java.lang nên không cần import [15].",
  },
  {
    id: 1496,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu Integer i được gán là null, điều gì xảy ra khi bạn cố gắng thực hiện unboxing trong dòng j=i?",
    code: "Integer i = null;\nint j = i;",
    options: [
      "j được gán giá trị 0.",
      "j được gán giá trị mặc định của Integer.",
      "Gây ra lỗi biên dịch.",
      "Gây ra NullPointerException tại runtime.",
    ],
    answer: 3,
    explanation:
      "Khi Autoboxing/Unboxing diễn ra, nếu đối tượng Wrapper là null, nó sẽ gây ra NullPointerException do cố gắng truy xuất giá trị từ một tham chiếu không trỏ đến đối tượng nào [20].",
  },
  {
    id: 1497,
    topic: "Data Structures",
    type: "radio",
    question:
      "Wrapper Class nào tương ứng với kiểu dữ liệu nguyên thủy 'double'?",
    options: ["Float", "Double", "Decimal", "Long"],
    answer: 1,
    explanation: "Kiểu double tương ứng với lớp Double [3].",
  },
  {
    id: 1498,
    topic: "Data Structures",
    type: "radio",
    question: "Wrapper Class nào có hằng số Type.MAX_VALUE và Type.MIN_VALUE?",
    options: [
      "Chỉ Integer và Double.",
      "Chỉ các lớp Number (số).",
      "Tất cả các lớp Wrapper.",
      "Chỉ Character.",
    ],
    answer: 1,
    explanation:
      "Các lớp Wrapper có các hằng số như Type.MAX_VALUE và Type.MIN_VALUE, áp dụng cho các kiểu số [18].",
  },
  {
    id: 1499,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi sử dụng Autoboxing, điều gì sẽ chuyển đổi tự động từ 'true' thành đối tượng Wrapper?",
    options: ["Character", "Void", "Boolean", "String"],
    answer: 2,
    explanation:
      "Kiểu dữ liệu nguyên thủy 'boolean' sẽ được đóng gói bởi lớp Wrapper Boolean [3, 7, 15].",
  },
  {
    id: 1500,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu `k` là Integer (Wrapper Class), đoạn code sau in ra giá trị nào (giả sử nó chạy trong môi trường có Autoboxing/Unboxing)?",
    code: 'Integer k = Integer.valueOf("12");\nint i = k.intValue();\nSystem.out.println(i);',
    options: ["12", "12 (với i là Integer)", "Lỗi runtime", "null"],
    answer: 0,
    explanation:
      'Integer.valueOf("12") tạo ra đối tượng Integer có giá trị 12. Phương thức intValue() (là một hình thức unboxing/typeValue()) trả về giá trị nguyên thủy int 12. Output là 12 [8, 9].',
  },
  {
    id: 1501,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của phương thức toUpperCase(char ch) trong lớp Character là gì?",
    options: [
      "Chuyển đổi chuỗi String thành chữ hoa.",
      "Kiểm tra xem ký tự có phải là chữ hoa không.",
      "Chuyển đổi ký tự sang dạng chữ hoa.",
      "Trả về giá trị ASCII của ký tự.",
    ],
    answer: 2,
    explanation:
      "Lớp Character cung cấp phương thức static char toUpperCase(char ch) để chuyển đổi ký tự sang chữ hoa [18].",
  },
  {
    id: 1502,
    topic: "Data Structures",
    type: "radio",
    question: "Wrapper class 'Long' tương ứng với primitive type nào?",
    options: ["long", "int", "short", "double"],
    answer: 0,
    explanation: "Long là Wrapper Class của primitive type long [3, 4].",
  },
  {
    id: 1503,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi chuyển đổi một String thành int bằng Integer.parseInt(), điều gì xảy ra nếu String không thể được biểu diễn dưới dạng số nguyên?",
    options: [
      "Trả về 0.",
      "Trả về giá trị lớn nhất của int.",
      "Ném ra NumberFormatException.",
      "Sử dụng giá trị mặc định (default value).",
    ],
    answer: 2,
    explanation:
      "Việc cố gắng phân tích cú pháp một chuỗi không phải là số (ví dụ: 'abc') sẽ ném ra NumberFormatException [11-13].",
  },
  {
    id: 1504,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của việc lưu trữ primitive data trong một object (thông qua Wrapper Class) là gì?",
    options: [
      "Giảm dung lượng bộ nhớ.",
      "Cho phép primitive data được sử dụng trong Collections (chỉ chấp nhận objects).",
      "Ngăn chặn việc thay đổi giá trị của primitive data.",
      "Tăng tốc độ truy cập dữ liệu.",
    ],
    answer: 1,
    explanation:
      "Wrapper classes cho phép lưu trữ primitive data trong một object [9]. Điều này cần thiết vì Collection chỉ làm việc với Object [15].",
  },
  {
    id: 1505,
    topic: "Data Structures",
    type: "radio",
    question: "Unboxing là quá trình ngược lại của hoạt động nào?",
    options: [
      "Kế thừa (Inheritance).",
      "Trừu tượng hóa (Abstraction).",
      "Autoboxing.",
      "Serialization.",
    ],
    answer: 2,
    explanation:
      "Unboxing là hành động lấy lại primitive data từ Wrapper Object [1], là ngược lại của Autoboxing (chuyển primitive thành Object) [6, 7].",
  },
  {
    id: 1506,
    topic: "Data Structures",
    type: "radio",
    question: "Lớp Wrapper nào không thuộc nhóm Float/Double?",
    options: ["Float", "Double", "Short", "Long"],
    answer: 2,
    explanation:
      "Short, Byte, Integer, Long là các lớp Integer-based. Float và Double là các lớp floating-point [4].",
  },
  {
    id: 1507,
    topic: "Data Structures",
    type: "radio",
    question: "Khi nào thì Autoboxing xảy ra?",
    options: [
      "Khi khai báo biến 'final'.",
      "Khi gán một giá trị nguyên thủy cho một biến tham chiếu của lớp Wrapper.",
      "Khi gọi một phương thức 'static'.",
      "Chỉ khi sử dụng toán tử '=='.",
    ],
    answer: 1,
    explanation:
      "Autoboxing xảy ra khi gán kiểu nguyên thủy cho biến kiểu Wrapper [6, 7]. Ví dụ: Integer o = 42; [21].",
  },
  {
    id: 1508,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong Java, các lớp Wrapper có sẵn trong gói (package) nào, vì vậy không cần import?",
    options: ["java.util", "java.io", "java.lang", "java.net"],
    answer: 2,
    explanation:
      "Các lớp Wrapper (Integer, Boolean, Character, v.v.) nằm trong gói java.lang nên không cần import [15].",
  },
  {
    id: 1509,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì xảy ra khi bạn sử dụng một đối tượng Wrapper làm toán hạng (operand) trong một phép toán số học (ví dụ: `i++` với `i` là Integer)?",
    options: [
      "Lỗi biên dịch.",
      "Giá trị bên trong đối tượng được tự động unbox để thực hiện phép toán.",
      "Đối tượng Wrapper bị biến thành `null`.",
      "Chỉ xảy ra nếu đối tượng Wrapper được khai báo là `final`.",
    ],
    answer: 1,
    explanation:
      "Autoboxing/Unboxing cho phép sử dụng kiểu Wrapper làm toán hạng trong các phép toán mà kiểu primitive được mong đợi, giá trị bên trong được unbox, thực hiện phép toán và sau đó có thể autobox trở lại nếu cần [14].",
  },
  {
    id: 1510,
    topic: "Data Structures",
    type: "radio",
    question: "Lớp Wrapper nào không hỗ trợ phương thức valueOf(String s)?",
    options: ["Integer", "Double", "Character", "Long"],
    answer: 2,
    explanation:
      "Phương thức valueOf() có sẵn trong tất cả các lớp Wrapper ngoại trừ Character [9].",
  },
  {
    id: 1511,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của phương thức isDigit(char ch) trong lớp Character là gì?",
    options: [
      "Kiểm tra xem ký tự có phải là chữ cái không.",
      "Kiểm tra xem ký tự có phải là chữ số không.",
      "Chuyển đổi ký tự sang dạng chữ số.",
      "Tìm kiếm vị trí của ký tự.",
    ],
    answer: 1,
    explanation:
      "Lớp Character cung cấp phương thức static boolean isDigit(char ch) để kiểm tra xem ký tự có phải là chữ số hay không [18].",
  },
  {
    id: 1512,
    topic: "Data Structures",
    type: "radio",
    question:
      "Kiểu dữ liệu nguyên thủy nào không có kích thước bit xác định mà là 'JVM-specific' (phụ thuộc JVM)?",
    options: ["int", "byte", "boolean", "char"],
    answer: 2,
    explanation:
      "Kiểu boolean có độ sâu bit JVM-specific (phụ thuộc vào JVM) [22].",
  },
  {
    id: 1513,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức `intValue()` thuộc loại nào trong quá trình xử lý Wrapper Class?",
    options: [
      "Autoboxing.",
      "Unboxing (hoặc typeValue()).",
      "Casting rõ ràng.",
      "Gán giá trị literal.",
    ],
    answer: 1,
    explanation:
      "intValue() là một ví dụ cụ thể của phương thức typeValue() [8, 9], được dùng để truy xuất giá trị nguyên thủy (Unboxing).",
  },
  {
    id: 1514,
    topic: "Data Structures",
    type: "radio",
    question: "Wrapper class nào tương ứng với primitive type 'char'?",
    options: ["Character", "Char", "String", "Void"],
    answer: 0,
    explanation:
      "Primitive type 'char' tương ứng với Wrapper Class Character [3, 23].",
  },
  {
    id: 1515,
    topic: "Data Structures",
    type: "radio",
    question:
      'Khi muốn chuyển đổi String "12" thành giá trị nguyên thủy int 12, phương pháp tối ưu nhất là gì?',
    options: [
      'Sử dụng constructor: new Integer("12").intValue()',
      'Sử dụng static method: Integer.parseInt("12")',
      "Sử dụng String concatenation.",
      "Sử dụng valueOf() sau đó là typeValue().",
    ],
    answer: 1,
    explanation:
      'Phương thức static parseType(String s), ví dụ Integer.parseInt("12"), chuyển đổi chuỗi thành giá trị primitive type tương ứng [8].',
  },
  {
    id: 1516,
    topic: "Data Structures",
    type: "radio",
    question: "Khẳng định nào sau đây là SAI về Wrapper Classes?",
    options: [
      "Chúng có thể chuyển đổi primitive data thành object.",
      "Chúng có thể chuyển đổi chuỗi số thành primitive data.",
      "Chúng cần thiết để lưu trữ primitive data trong Collections.",
      "Chúng không thể được sử dụng như toán hạng trong các phép toán số học.",
    ],
    answer: 3,
    explanation:
      "Sử dụng Autoboxing/Unboxing, các đối tượng Wrapper có thể được sử dụng làm toán hạng trong các phép toán số học (ví dụ: i++) [14].",
  },
  {
    id: 1517,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong trường hợp nào, việc truyền một đối tượng Wrapper vào một phương thức mong đợi một kiểu nguyên thủy là hợp lệ?",
    options: [
      "Chỉ khi phương thức được khai báo là 'static'.",
      "Luôn hợp lệ nhờ cơ chế Unboxing.",
      "Chỉ khi đối tượng Wrapper được khởi tạo bằng 'new'.",
      "Không bao giờ hợp lệ.",
    ],
    answer: 1,
    explanation:
      "Unboxing cho phép bạn sử dụng kiểu Wrapper ở bất cứ đâu kiểu nguyên thủy được mong đợi [7].",
  },
  {
    id: 1518,
    topic: "Data Structures",
    type: "code",
    question:
      "Đoạn code sau đây có compile và chạy bình thường không, và nếu có thì output là gì (Giả sử Java 5.0+)?",
    code: "Integer i = 10;\ni++;\nSystem.out.println(i);",
    options: ["Compile Error.", "Runtime Error.", "10", "11"],
    answer: 3,
    explanation:
      "Integer i = 10; là Autoboxing. i++ sử dụng Unboxing, tăng giá trị primitive, sau đó Autoboxing giá trị 11 trở lại thành đối tượng Integer mới (nhờ tính năng mới trong Java 5.0+). Output là 11 [14].",
  },
  {
    id: 1519,
    topic: "Data Structures",
    type: "radio",
    question:
      "Để chuyển đổi một kiểu dữ liệu nguyên thủy thành một đối tượng (Wrapper Object) người ta thường sử dụng phương pháp nào?",
    options: [
      "Chỉ định type casting thủ công.",
      "Sử dụng từ khóa `convert`.",
      "Sử dụng constructor của Wrapper class (hoặc Autoboxing).",
      "Sử dụng phương thức `parseType()`.",
    ],
    answer: 2,
    explanation:
      "Wrapper classes có hai cách dùng: chuyển đổi kiểu dữ liệu đơn giản thành đối tượng bằng cách sử dụng constructor (hoặc Autoboxing), hoặc chuyển đổi chuỗi thành kiểu dữ liệu bằng phương thức parseXXX() [19].",
  },
  {
    id: 1520,
    topic: "Data Structures",
    type: "radio",
    question:
      "Tính năng nào của Wrapper Classes cho phép chúng được coi là Objects?",
    options: [
      "Chúng có thể được gán giá trị trực tiếp.",
      "Chúng có thể có các phương thức (methods) kèm theo.",
      "Chúng được lưu trữ trên Stack memory.",
      "Chúng không thể được kế thừa.",
    ],
    answer: 1,
    explanation:
      "Wrapper classes 'bọc' primitive types để cung cấp thêm chức năng thông qua các phương thức [3].",
  },
  {
    id: 1521,
    topic: "Data Structures",
    type: "radio",
    question: "Hạn chế chính của Array (mảng tĩnh) trong Java là gì?",
    options: [
      "Không thể lưu trữ các đối tượng.",
      "Kích thước cố định, phải biết chính xác số lượng mục khi khởi tạo.",
      "Chỉ hỗ trợ truy cập tuần tự (sequential access).",
      "Không thể sử dụng vòng lặp để duyệt qua các phần tử.",
    ],
    answer: 1,
    explanation:
      "Hạn chế của mảng là bạn cần biết chính xác số lượng mục bạn sẽ sử dụng trong mảng [24]. Kích thước của mảng đã cố định [25].",
  },
  {
    id: 1522,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì xảy ra khi bạn cố gắng xóa một mục khỏi mảng tĩnh?",
    options: [
      "Mảng tự động dịch chuyển các mục để lấp đầy khoảng trống.",
      "Kích thước mảng giảm đi 1.",
      "Nó tạo ra các khoảng trống và phải dịch chuyển các mục thủ công để lấp đầy.",
      "Lỗi runtime ArrayIndexOutOfBoundsException.",
    ],
    answer: 2,
    explanation:
      "Khi bạn xóa các mục, nó tạo ra các khoảng trống kỳ lạ trong mảng, và bạn phải dịch chuyển các mục thủ công để lấp đầy những khoảng trống đó [26].",
  },
  {
    id: 1523,
    topic: "Data Structures",
    type: "radio",
    question: "Trong Java, mảng (Array) được coi là loại cấu trúc dữ liệu nào?",
    options: ["Primitive type.", "Object.", "Interface.", "Enum."],
    answer: 1,
    explanation:
      "Một mảng là một đối tượng và phải được tạo (sử dụng new) trước khi sử dụng [17, 27].",
  },
  {
    id: 1524,
    topic: "Data Structures",
    type: "radio",
    question: "Chỉ số (index) của mảng trong Java bắt đầu từ đâu?",
    options: ["1", "0", "Chiều dài mảng trừ 1", "Tùy thuộc vào kiểu dữ liệu."],
    answer: 1,
    explanation:
      "Mỗi ô trong mảng có một chỉ số bắt đầu từ 0 [17, 28]. Java arrays are zero-based [25, 29].",
  },
  {
    id: 1525,
    topic: "Data Structures",
    type: "radio",
    question:
      "Thuộc tính nào được sử dụng để lấy chiều dài (kích thước) của một mảng `a`?",
    options: ["a.size()", "a.length()", "a.capacity", "a.length"],
    answer: 3,
    explanation: "Độ dài của mảng a[] có thể truy xuất bằng a.length [17, 25].",
  },
  {
    id: 1526,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn truy cập một phần tử mảng bằng chỉ số không hợp lệ (ví dụ: chỉ số âm hoặc lớn hơn kích thước mảng - 1)?",
    options: [
      "Chỉ nhận giá trị null.",
      "Java sinh ngoại lệ ArrayIndexOutOfBoundsException và chấm dứt chương trình.",
      "Lỗi biên dịch.",
      "Tự động điều chỉnh kích thước mảng.",
    ],
    answer: 1,
    explanation:
      "Sử dụng chỉ số mảng không nằm giữa 0 và chiều dài mảng trừ đi một, Java sẽ sinh ngoại lệ ArrayIndexOutOfBoundsException [11, 30].",
  },
  {
    id: 1527,
    topic: "Data Structures",
    type: "radio",
    question: "Cơ chế truy cập nào là ưu điểm chính của Array?",
    options: [
      "Truy cập ngẫu nhiên nhanh (fast random access).",
      "Tự động sắp xếp các phần tử.",
      "Tối ưu cho việc chèn/xóa phần tử.",
      "Không cần cấp phát bộ nhớ.",
    ],
    answer: 0,
    explanation:
      "Mảng cung cấp cho bạn quyền truy cập ngẫu nhiên nhanh chóng bằng cách cho phép bạn sử dụng vị trí chỉ mục để đến bất kỳ phần tử nào trong mảng [27].",
  },
  {
    id: 1528,
    topic: "Data Structures",
    type: "radio",
    question: "Cách nào sau đây là cách tạo mảng hợp lệ?",
    options: [
      "String[] names = new String();",
      "int[] a; a = new int[23];",
      "Array<String> names = new Array<String>(10);",
      "int a = {1, 2, 3};",
    ],
    answer: 1,
    explanation:
      "Mảng là một đối tượng phải được tạo bằng từ khóa 'new' và khai báo kiểu đúng cú pháp, ví dụ: int[] a = new int[23]; [17].",
  },
  {
    id: 1529,
    topic: "Data Structures",
    type: "radio",
    question:
      "Làm thế nào để khởi tạo một mảng với các giá trị đã biết tại thời điểm biên dịch?",
    options: [
      "Sử dụng từ khóa `static`.",
      "Liệt kê các giá trị trong dấu ngoặc nhọn { } cách nhau bởi dấu phẩy.",
      "Sử dụng phương thức `fill()` của lớp Arrays.",
      "Sử dụng constructor không tham số.",
    ],
    answer: 1,
    explanation:
      "Khi có một số lượng nhỏ các giá trị, ta có thể khởi tạo mảng bằng cách liệt kê các giá trị trong dấu ngoặc nhọn, cách nhau bởi dấu phẩy, ví dụ: int[] b = {2, 3, 5, 7}; [17, 31].",
  },
  {
    id: 1530,
    topic: "Data Structures",
    type: "radio",
    question:
      "Cấu trúc dữ liệu nào trong Java được thiết kế để khắc phục các hạn chế về kích thước cố định của Array?",
    options: ["String", "Integer", "ArrayList", "Math class"],
    answer: 2,
    explanation:
      "Collections, như ArrayList, là một tập hợp các lớp và interface được cung cấp để đơn giản hóa việc quản lý nhiều mục cùng loại, khắc phục hạn chế của mảng (ví dụ: kích thước cố định) [26, 32].",
  },
  {
    id: 1531,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về mảng nhiều chiều (Multi-dimensional arrays) trong Java?",
    options: [
      "Chỉ hỗ trợ tối đa 2 chiều.",
      "Luôn có các dòng có độ dài bằng nhau.",
      "Được biểu diễn là 'mảng của các mảng'.",
      "Chỉ có thể lưu trữ kiểu dữ liệu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Java biểu diễn mảng hai chiều là 'mảng của các mảng' (array of arrays). Cách biểu diễn này cho phép các dòng không cần có độ dài bằng nhau [33, 34].",
  },
  {
    id: 1532,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong trường hợp nào, việc sử dụng Array sẽ gặp khó khăn so với ArrayList?",
    options: [
      "Khi cần lưu trữ một số lượng nhỏ các phần tử.",
      "Khi cần tối ưu cho truy cập ngẫu nhiên.",
      "Khi số lượng phần tử cần lưu trữ thường xuyên thay đổi (thêm/xóa).",
      "Khi cần tính toán kích thước cố định.",
    ],
    answer: 2,
    explanation:
      "Array có kích thước cố định [24, 25], khiến việc quản lý các bộ sưu tập có kích thước thay đổi (thêm/xóa) trở nên khó khăn, vì phải dịch chuyển thủ công các phần tử [26]. ArrayList xử lý vấn đề này tốt hơn [35].",
  },
  {
    id: 1533,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phần tử cuối cùng của một mảng `int[] a` có thể được truy cập bằng chỉ số nào?",
    options: ["a.length", "a.length - 1", "a.length + 1", "a"],
    answer: 1,
    explanation:
      "Chỉ số mảng chạy từ 0 đến N-1, với N là a.length. Do đó, phần tử cuối cùng là a[a.length - 1] [28].",
  },
  {
    id: 1534,
    topic: "Data Structures",
    type: "radio",
    question:
      "Đoạn code nào sau đây dùng để sao chép mảng một cách chính xác (deep copy) đối với mảng chứa kiểu nguyên thủy?",
    options: [
      "b = a;",
      "System.arraycopy(a, 0, b, 0, a.length);",
      "a.cloneTo(b);",
      "for (int i=0; i<a.length; i++) { b[i] = a[i]; }",
    ],
    answer: 1,
    explanation:
      "Việc sao chép các phần tử mảng có thể được thực hiện bằng cách lặp qua từng phần tử [36], hoặc bằng System.arraycopy(src, s_off, des, d_off, len) [36]. Đối với primitive values, System.arraycopy sao chép nội dung [24].",
  },
  {
    id: 1535,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì xảy ra khi bạn gán một mảng cho một mảng khác (ví dụ: `a = b;`)?",
    options: [
      "Các phần tử của b được sao chép vào a.",
      "Cả a và b cùng tham chiếu đến cùng một đối tượng mảng trong bộ nhớ Heap.",
      "Kích thước của a thay đổi nếu kích thước của b khác a.",
      "Mảng a bị xóa khỏi Heap.",
    ],
    answer: 1,
    explanation:
      "Đối với các đối tượng (như mảng), toán tử gán '=' làm cho hai tham chiếu cùng trỏ đến cùng một đối tượng [17, 37].",
  },
  {
    id: 1536,
    topic: "Data Structures",
    type: "radio",
    question:
      "Lớp tiện ích nào trong gói java.util cung cấp các phương thức static như `sort()`, `fill()`, và `binarySearch()` cho mảng?",
    options: ["Collection", "ArrayUtil", "Arrays", "List"],
    answer: 2,
    explanation:
      "Lớp Arrays trong gói java.util cung cấp các phương thức tĩnh như fill(), sort(), equals(), và binarySearch() [24].",
  },
  {
    id: 1537,
    topic: "Data Structures",
    type: "radio",
    question: "Trong bối cảnh Array, thuật ngữ 'zero-based' có nghĩa là gì?",
    options: [
      "Mọi phần tử trong mảng phải là số 0.",
      "Kích thước mảng không thể vượt quá 0.",
      "Chỉ số đầu tiên được sử dụng là 0.",
      "Các mảng được cấp phát tại địa chỉ bộ nhớ 0.",
    ],
    answer: 2,
    explanation:
      "Các chỉ số mảng được đánh số từ 0 [17, 25]. Array is zero-based [29].",
  },
  {
    id: 1538,
    topic: "Data Structures",
    type: "radio",
    question: "Khi nào thì mảng Array trong Java được cấp phát bộ nhớ?",
    options: [
      "Tại thời điểm biên dịch.",
      "Chỉ khi sử dụng các phần tử mảng.",
      "Khi sử dụng từ khóa `new` (cấp phát bộ nhớ động trên Heap).",
      "Khi khai báo.",
    ],
    answer: 2,
    explanation:
      "Mảng là một đối tượng và phải được tạo (sử dụng new) trước khi dùng. Quá trình này được gọi là cấp phát bộ nhớ [17, 25]. Tất cả các đối tượng Java đều được cấp phát động trên Heap [38].",
  },
  {
    id: 1539,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau đây sẽ in ra gì?",
    code: "int[] a = {1, 2, 3};\nint[] b = {1, 2, 3};\nSystem.out.println(a == b);",
    options: ["true", "false", "Compile Error", "1"],
    answer: 1,
    explanation:
      "Đối với đối tượng (như mảng), toán tử `==` so sánh tham chiếu. a và b là hai đối tượng mảng khác nhau trên Heap, ngay cả khi chúng có nội dung giống nhau. Do đó, so sánh tham chiếu trả về false [39-41].",
  },
  {
    id: 1540,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu cần tìm kiếm nhị phân (binary search) trong một mảng, điều kiện nào cần phải được đảm bảo để tránh lỗi logic?",
    options: [
      "Mảng phải chứa các phần tử Wrapper.",
      "Mảng phải có kích thước lớn hơn 10.",
      "Mảng phải được sắp xếp (sorted).",
      "Mảng phải là mảng hai chiều.",
    ],
    answer: 2,
    explanation:
      "Phương thức `binarySearch()` của lớp Arrays thực hiện tìm kiếm nhị phân trong mảng đã sắp xếp. Nó tạo ra lỗi logic nếu được sử dụng cho mảng chưa sắp xếp [24].",
  },
  {
    id: 1541,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi một mảng chứa tham chiếu đối tượng (ví dụ: `String[] names`), điều gì được sao chép khi sử dụng `System.arraycopy()`?",
    options: [
      "Nội dung (state) của các đối tượng được tham chiếu.",
      "Chỉ tham chiếu đối tượng.",
      "Cả nội dung và tham chiếu.",
      "Chỉ sao chép độ dài mảng.",
    ],
    answer: 1,
    explanation:
      "Khi sao chép mảng chứa đối tượng, nội dung được sao chép là 'Object reference' (tham chiếu đối tượng) [24].",
  },
  {
    id: 1542,
    topic: "Data Structures",
    type: "radio",
    question: "Lớp `Arrays` (java.util) không hỗ trợ phương thức static nào?",
    options: ["sort()", "get(index)", "fill()", "equals()"],
    answer: 1,
    explanation:
      "Các phương thức static được liệt kê của lớp Arrays là fill(), sort(), equals(), binarySearch() [24]. Phương thức get(index) thuộc về interface List (ví dụ: ArrayList) [42].",
  },
  {
    id: 1543,
    topic: "Data Structures",
    type: "radio",
    question:
      "Một trong những cách hiệu quả để lặp qua các phần tử trong một mảng là gì?",
    options: [
      "Sử dụng Iterator interface.",
      "Sử dụng vòng lặp for với bộ đếm là index.",
      "Sử dụng phương thức `next()`.",
      "Sử dụng lệnh `continue`.",
    ],
    answer: 1,
    explanation:
      "Cách tốt nhất để truy cập từng phần tử trong Array hoặc ArrayList là tạo một vòng lặp và sử dụng bộ đếm vòng lặp làm chỉ số [43].",
  },
  {
    id: 1544,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau đây sẽ gây ra ngoại lệ nào?",
    code: "int[] numbers = new int[44];\nSystem.out.println(numbers[44]);",
    options: [
      "NullPointerException",
      "NumberFormatException",
      "ArrayIndexOutOfBoundsException",
      "Lỗi biên dịch",
    ],
    answer: 2,
    explanation:
      "Mảng có kích thước 5 có các chỉ số từ 0 đến 4. Truy cập numbers[44] nằm ngoài phạm vi, gây ra ArrayIndexOutOfBoundsException [30].",
  },
  {
    id: 1545,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi khởi tạo một mảng Array (ví dụ: `int[] a = new int[23];`), các phần tử sẽ có giá trị mặc định là gì?",
    options: [
      "null",
      "-1",
      "0 (hoặc false cho boolean, null cho references)",
      "Giá trị ngẫu nhiên.",
    ],
    answer: 2,
    explanation:
      "Các biến instance được gán giá trị mặc định: 0/0.0/false cho primitives và null cho references [45, 46]. Mảng là object và các phần tử của nó sẽ được khởi tạo mặc định (0 cho int) [25, 34].",
  },
  {
    id: 1546,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là SAI về việc sử dụng Array trong Java?",
    options: [
      "Mảng có thể lưu trữ kiểu dữ liệu nguyên thủy.",
      "Mảng có thể lưu trữ tham chiếu đối tượng (object references).",
      "Mảng hỗ trợ tự động thay đổi kích thước khi thêm phần tử.",
      "Mảng sử dụng từ khóa `new` để cấp phát bộ nhớ.",
    ],
    answer: 2,
    explanation:
      "Mảng có kích thước cố định và không hỗ trợ tự động thay đổi kích thước [24, 25].",
  },
  {
    id: 1547,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu bạn muốn đảo ngược thứ tự của một mảng `b[]` mà không tạo mảng mới, bạn cần lặp qua bao nhiêu phần tử?",
    options: [
      "b.length",
      "b.length - 1",
      "b.length / 2",
      "Không thể thực hiện mà không tạo mảng mới.",
    ],
    answer: 2,
    explanation:
      "Để đảo ngược thứ tự, ta cần lặp qua b.length / 2 lần và tráo đổi các phần tử đối xứng qua trung tâm [31].",
  },
  {
    id: 1548,
    topic: "Data Structures",
    type: "radio",
    question: "Khi chuyển đổi Array sang ArrayList, lợi ích chính là gì?",
    options: [
      "Tăng tốc độ truy cập ngẫu nhiên.",
      "Mất khả năng lưu trữ đối tượng.",
      "Khắc phục giới hạn kích thước cố định của Array.",
      "Bắt buộc sử dụng Generics.",
    ],
    answer: 2,
    explanation:
      "ArrayList giải quyết các hạn chế về kích thước cố định của Array [35, 47]. ArrayList có thể phát triển để chứa nhiều đối tượng hơn [48].",
  },
  {
    id: 1549,
    topic: "Data Structures",
    type: "radio",
    question: "Trong mảng hai chiều `a[M][N]`, `a[i].length` cho biết điều gì?",
    options: [
      "Tổng số phần tử.",
      "Số lượng dòng (M).",
      "Số lượng cột (N) ở dòng thứ i.",
      "Chỉ số lớn nhất.",
    ],
    answer: 2,
    explanation:
      "Vì mảng hai chiều là mảng của các mảng, `a.length` là số dòng (M), và `a[i].length` là số phần tử (cột) ở dòng thứ i [49].",
  },
  {
    id: 1550,
    topic: "Data Structures",
    type: "radio",
    question:
      "Đoạn code nào sau đây được dùng để tìm phần tử lớn nhất trong mảng `a`?",
    options: [
      "Math.max(a);",
      "for (int x : a) max = x;",
      "sử dụng vòng lặp để so sánh từng phần tử với giá trị max ban đầu.",
      "sử dụng a.getMax();",
    ],
    answer: 2,
    explanation:
      "Để tìm giá trị lớn nhất, ta khởi tạo một biến max (ví dụ: Double.NEGATIVE_INFINITY) và lặp qua từng phần tử mảng, so sánh và cập nhật max [50].",
  },
  {
    id: 1551,
    topic: "Data Structures",
    type: "code",
    question: "Điều gì xảy ra với đoạn code khai báo Array sau đây?",
    code: "int[] a;\nfor (int i = 0; i < 10; i++)\na[i] = i * i;",
    options: [
      "Chạy bình thường.",
      "Lỗi biên dịch vì mảng a chưa được khởi tạo (chưa cấp phát bộ nhớ).",
      "Gây ra NullPointerException tại runtime.",
      "Kết quả là mảng 10 phần tử.",
    ],
    answer: 1,
    explanation:
      "Biến tham chiếu 'a' được khai báo nhưng chưa được khởi tạo bằng `new`, do đó nó là null. Cố gắng truy cập `a[i]` sẽ gây lỗi biên dịch hoặc NullPointerException nếu nó vượt qua biên dịch nhưng ở đây là lỗi biên dịch vì Java cần biết kích thước mảng trước khi gán giá trị [51].",
  },
  {
    id: 1552,
    topic: "Data Structures",
    type: "radio",
    question: "Trong mảng, các chỉ số cho phép bạn làm gì?",
    options: [
      "Thay đổi kích thước mảng.",
      "Truy cập từng mục riêng lẻ trong mảng.",
      "Đảm bảo mảng là bất biến.",
      "Ngăn chặn lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Mỗi ô trong mảng có một chỉ số, và các chỉ số này cho phép bạn truy cập từng mục riêng lẻ trong mảng [17].",
  },
  {
    id: 1553,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu cần lưu trữ một tập hợp các đối tượng nhưng không biết chính xác kích thước cuối cùng, nên sử dụng gì thay vì Array?",
    options: [
      "HashMap.",
      "ArrayList (hoặc các Collection khác).",
      "String Literal.",
      "Wrapper Class.",
    ],
    answer: 1,
    explanation:
      "ArrayList có thể được sử dụng để lưu trữ các đối tượng và có khả năng phát triển kích thước linh hoạt [32, 48], khắc phục hạn chế kích thước cố định của Array [24].",
  },
  {
    id: 1554,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mảng là một đối tượng, vậy nó được lưu trữ ở đâu trong bộ nhớ Java?",
    options: [
      "Stack memory.",
      "Static memory.",
      "Heap memory.",
      "String Pool.",
    ],
    answer: 2,
    explanation:
      "Trong Java, tất cả các đối tượng được cấp phát động trên Heap [38]. Mảng là một đối tượng và phải được tạo bằng new [17].",
  },
  {
    id: 1555,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì xảy ra nếu cố gắng gán giá trị cho một mảng chưa được khởi tạo bằng `new` (ví dụ: `int[] a; a = 5;`)?",
    options: [
      "Lỗi biên dịch vì chưa có không gian bộ nhớ cho mảng.",
      "Phần tử 0 được gán giá trị 5.",
      "NullPointerException.",
      "Array được khởi tạo tự động.",
    ],
    answer: 0,
    explanation:
      "Nếu `int[] a;` được khai báo, nó là một tham chiếu `null` (nếu là instance variable). Nếu cố gắng truy cập mà chưa khởi tạo bằng `new`, nó sẽ dẫn đến lỗi biên dịch nếu nằm ngoài một phương thức hoặc NullPointerException tại runtime (nếu nằm trong phương thức và không được khởi tạo) [51]. (Chọn lỗi biên dịch nếu nó được đặt như một trường hợp đơn giản).",
  },
  {
    id: 1556,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi sử dụng vòng lặp để duyệt qua mảng Array, `length` đóng vai trò gì?",
    options: [
      "Bộ đếm vòng lặp.",
      "Điều kiện dừng vòng lặp.",
      "Chỉ mục bắt đầu.",
      "Kiểu dữ liệu của mảng.",
    ],
    answer: 1,
    explanation:
      "Thuộc tính length của mảng thường được sử dụng làm điều kiện dừng trong vòng lặp for (ví dụ: `i < a.length`) [17].",
  },
  {
    id: 1557,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi bạn cần lưu trữ một tập hợp các đối tượng theo thứ tự và cần khả năng thêm/xóa linh hoạt, bạn nên chọn gì?",
    options: ["Array tĩnh.", "HashMap.", "ArrayList.", "StringBuffer."],
    answer: 2,
    explanation:
      "ArrayList là một List, hành xử tương tự Array nhưng đơn giản hơn trong việc quản lý, hỗ trợ thêm/xóa phần tử linh hoạt hơn [26, 42].",
  },
  {
    id: 1558,
    topic: "Data Structures",
    type: "radio",
    question:
      "Array được coi là 'Ordered Sequence' (Chuỗi có thứ tự) vì lý do nào?",
    options: [
      "Các phần tử được sắp xếp tự động.",
      "Các phần tử được truy cập bằng chỉ số (index) theo thứ tự từ 0.",
      "Nó là một lớp con của interface Set.",
      "Nó chỉ lưu trữ kiểu dữ liệu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Mảng cung cấp truy cập ngẫu nhiên nhanh bằng cách sử dụng chỉ số [27], ngụ ý một thứ tự dựa trên vị trí index.",
  },
  {
    id: 1559,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc khởi tạo mảng `int[] a = new int[23];`?",
    options: [
      "Mảng chứa 11 phần tử.",
      "Kích thước 10 được cố định trong suốt vòng đời của mảng.",
      "Mảng được lưu trữ trên Stack.",
      "Mảng này không cần từ khóa `new`.",
    ],
    answer: 1,
    explanation:
      "Array có kích thước cố định [24, 25] và được tạo bằng `new` [17] trên Heap [38].",
  },
  {
    id: 1560,
    topic: "Data Structures",
    type: "radio",
    question:
      "Để tìm kiếm một giá trị trong một mảng lớn chưa được sắp xếp, cần sử dụng phương pháp nào?",
    options: [
      "binarySearch() của Arrays.",
      "Lặp qua tất cả các phần tử (linear search).",
      "Sử dụng HashMap.",
      "Sử dụng Stack.",
    ],
    answer: 1,
    explanation:
      "Tìm kiếm trong Array thường yêu cầu lặp qua các phần tử. Nếu mảng chưa sắp xếp, `binarySearch()` sẽ gây ra lỗi logic [24]. HashMap tăng tốc tìm kiếm so với Array/ArrayList [52, 53], nhưng linear search là giải pháp cơ bản cho mảng chưa sắp xếp.",
  },
  {
    id: 1561,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khẳng định nào mô tả chính xác tính bất biến (immutability) của String trong Java?",
    options: [
      "String có thể thay đổi nhưng chỉ thông qua phương thức `set()`.",
      "Một khi đối tượng String được tạo, nó là một chuỗi ký tự không thể sửa đổi.",
      "String chỉ bất biến khi được tạo bằng String literal.",
      "String bất biến chỉ áp dụng cho Java versions cũ hơn 5.0.",
    ],
    answer: 1,
    explanation:
      "String là một chuỗi ký tự không thể sửa đổi (unmodifiable sequence of characters) [2, 18, 54]. Strings in Java are immutable [55].",
  },
  {
    id: 1562,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu String là bất biến, điều gì xảy ra khi bạn sử dụng toán tử cộng (+) để nối hai String?",
    options: [
      "Nội dung của String đầu tiên được thay đổi tại chỗ.",
      "Một đối tượng String mới được tạo ra trên Heap để chứa kết quả nối.",
      "Sử dụng String Pool để tối ưu hóa thay đổi.",
      "Hành động này bị cấm do tính bất biến.",
    ],
    answer: 1,
    explanation:
      "Khi nối String bằng toán tử `+`, một đối tượng String mới được tạo ra (hoặc được tham chiếu từ String Pool). Trong vòng lặp, việc nối tạo ra rất nhiều đối tượng String trung gian (abandoned objects) [55, 56].",
  },
  {
    id: 1563,
    topic: "Data Structures",
    type: "radio",
    question: "StringBuffer là gì?",
    options: [
      "Một chuỗi ký tự không thể sửa đổi (Immutable).",
      "Một chuỗi ký tự có thể sửa đổi (Mutable).",
      "Một lớp tiện ích cho việc chuyển đổi String.",
      "Một lớp cha của String.",
    ],
    answer: 1,
    explanation:
      "StringBuffer là chuỗi ký tự có thể sửa đổi (modifiable sequence of characters) [57, 58].",
  },
  {
    id: 1564,
    topic: "Data Structures",
    type: "radio",
    question: "Sự khác biệt chính giữa StringBuilder và StringBuffer là gì?",
    options: [
      "StringBuilder nhanh hơn và không đồng bộ hóa (non-synchronized), trong khi StringBuffer chậm hơn nhưng an toàn cho luồng (thread-safe).",
      "StringBuffer không thể sửa đổi, còn StringBuilder thì có.",
      "StringBuilder chỉ có thể sử dụng cho kiểu char[], còn StringBuffer thì không.",
      "StringBuffer đã bị loại bỏ (deprecated) từ JDK 5.0.",
    ],
    answer: 0,
    explanation:
      "Từ Java 5.0 trở đi, nên sử dụng StringBuilder thay vì StringBuffer, trừ khi việc thao tác chuỗi cần phải an toàn cho luồng (thread-safe). StringBuilder không đồng bộ hóa nên nhanh hơn [59].",
  },
  {
    id: 1565,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi thao tác với String (chèn, xóa, thay thế) trong một vòng lặp lớn, nên sử dụng gì để đạt hiệu suất tốt hơn String?",
    options: [
      "Chỉ sử dụng String Literal.",
      "Sử dụng String.intern().",
      "Sử dụng StringBuilder/StringBuffer.",
      "Sử dụng String.replace().",
    ],
    answer: 2,
    explanation:
      "StringBuilder/StringBuffer có thể hiệu quả hơn nhiều nếu bạn đang thao tác với String thường xuyên, vì chúng có thể sửa đổi (Mutable), tránh tạo ra các đối tượng trung gian [59].",
  },
  {
    id: 1566,
    topic: "Data Structures",
    type: "radio",
    question:
      "StringBuffer có constructor mặc định với kích thước ban đầu là bao nhiêu?",
    options: ["8", "10", "16", "32"],
    answer: 2,
    explanation:
      "Constructor StringBuffer() có kích thước mặc định là 16 [57].",
  },
  {
    id: 1567,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để nối (concatenate) một chuỗi vào cuối đối tượng StringBuffer?",
    options: [
      "concat(String)",
      "add(String)",
      "append(String)",
      "insert(String)",
    ],
    answer: 2,
    explanation:
      "StringBuffer/StringBuilder sử dụng phương thức append(String) để nối chuỗi [57, 60].",
  },
  {
    id: 1568,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu cần thêm một chuỗi vào giữa một StringBuffer/StringBuilder, phương thức nào nên được sử dụng?",
    options: [
      "insert(int offset, String s)",
      "replace(int start, int end, String s)",
      "setCharAt(int index, char ch)",
      "append(String)",
    ],
    answer: 0,
    explanation:
      "Phương thức insert(int offset, String s) được sử dụng để chèn chuỗi [57, 61].",
  },
  {
    id: 1569,
    topic: "Data Structures",
    type: "radio",
    question:
      "Sử dụng String.concat(String) khác với toán tử '+' cho String ở điểm nào?",
    options: [
      "Cả hai đều tạo ra đối tượng String mới.",
      "Chỉ String.concat() thay đổi String gốc.",
      "Toán tử '+' có thể thay đổi chuỗi gốc.",
      "Toán tử '+' không thể sử dụng cho String.",
    ],
    answer: 0,
    explanation:
      "Cả hai phương pháp đều dẫn đến việc tạo ra một đối tượng String mới vì String là bất biến. concat(String) là phương thức của String class, dùng để nối chuỗi [60, 62]. Toán tử '+' cũng nối (concatenates) các đối tượng String lại với nhau [62, 63].",
  },
  {
    id: 1570,
    topic: "Data Structures",
    type: "radio",
    question:
      "Tính bất biến (immutability) của String giúp ích gì trong cơ chế String Pool?",
    options: [
      "Cho phép Garbage Collector dọn dẹp Pool dễ dàng hơn.",
      "Đảm bảo rằng một tham chiếu không thể thay đổi giá trị của String đang được tham chiếu bởi một tham chiếu khác.",
      "Bắt buộc String phải được lưu trữ trên Heap.",
      "Cho phép String được sử dụng như kiểu primitive.",
    ],
    answer: 1,
    explanation:
      "JVM có thể tham chiếu nhiều biến đến cùng một đối tượng String trong Pool vì Strings là bất biến; một tham chiếu không thể thay đổi giá trị String mà tham chiếu khác đang trỏ đến [56].",
  },
  {
    id: 1571,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào của StringBuffer được dùng để xóa một đoạn chuỗi con (substring) từ vị trí bắt đầu đến vị trí kết thúc?",
    options: [
      "remove(int start, int end)",
      "delete(int start, int end)",
      "substring(int start, int end)",
      "clear()",
    ],
    answer: 1,
    explanation:
      "Phương thức delete(int start, int end) xóa một chuỗi con (substring) [61, 64].",
  },
  {
    id: 1572,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu một chuỗi `s` được tạo ra trong một vòng lặp bằng cách nối chuỗi liên tục (s = s + x;), số lượng đối tượng String được tạo ra là gì?",
    options: [
      "1 đối tượng.",
      "Tương đương với số lần lặp cộng 1.",
      "Không thể xác định.",
      "Luôn là 10 đối tượng.",
    ],
    answer: 1,
    explanation:
      "Trong vòng lặp, mỗi lần nối `s = s + x;` sẽ tạo ra một đối tượng String mới, cộng với đối tượng String ban đầu [55]. Nếu lặp N lần, sẽ có N+1 đối tượng.",
  },
  {
    id: 1573,
    topic: "Data Structures",
    type: "radio",
    question: "Lớp nào sau đây được tạo thành từ một mảng các ký tự (char [])?",
    options: ["Integer", "String", "Boolean", "Math"],
    answer: 1,
    explanation:
      "Một biến String được tạo thành từ một mảng các ký tự (char []) [16, 23].",
  },
  {
    id: 1574,
    topic: "Data Structures",
    type: "radio",
    question: "Phương thức `reverse()` được hỗ trợ bởi lớp nào?",
    options: ["String", "StringBuffer", "Character", "Object"],
    answer: 1,
    explanation:
      "Phương thức reverse() được hỗ trợ bởi StringBuffer/StringBuilder [33, 64].",
  },
  {
    id: 1575,
    topic: "Data Structures",
    type: "radio",
    question: "Phương thức `trim()` của String class có chức năng gì?",
    options: [
      "Xóa tất cả khoảng trắng trong chuỗi.",
      "Chỉ xóa khoảng trắng ở cuối chuỗi.",
      "Trả về một bản sao của chuỗi với khoảng trắng dẫn đầu và khoảng trắng theo sau bị loại bỏ.",
      "Cắt chuỗi tại vị trí được chỉ định.",
    ],
    answer: 2,
    explanation:
      "Phương thức String trim() trả về một bản sao của chuỗi với khoảng trắng dẫn đầu và khoảng trắng theo sau bị loại bỏ [65, 66].",
  },
  {
    id: 1576,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì là SAI khi thao tác với chuỗi bất biến (Immutable String)?",
    options: [
      "Các phương thức như `toUpperCase()` trả về một đối tượng String mới.",
      "Chúng có thể được lưu trữ trong String Pool.",
      "Chúng có thể được thay đổi bằng cách sử dụng toán tử `+`.",
      "Chúng không thể được Garbage Collected nếu bị bỏ rơi (abandoned) trong String Pool.",
    ],
    answer: 2,
    explanation:
      "Không thể thay đổi chuỗi bất biến. Toán tử `+` tạo ra một đối tượng mới chứ không thay đổi chuỗi gốc [55]. Các chuỗi bị bỏ rơi trong String Pool không được Garbage Collector dọn dẹp [56].",
  },
  {
    id: 1577,
    topic: "Data Structures",
    type: "radio",
    question:
      "Lớp String cung cấp phương thức nào để so sánh nội dung chuỗi mà không quan tâm đến chữ hoa/thường?",
    options: [
      "equals(String)",
      "equalsStrict(String)",
      "equalsIgnoreCase(String)",
      "compareTo(String)",
    ],
    answer: 2,
    explanation:
      "Phương thức boolean equalsIgnoreCase(String) được dùng cho mục đích so sánh không phân biệt chữ hoa, chữ thường [62, 67].",
  },
  {
    id: 1578,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào của String được dùng để trả về chuỗi con từ một chỉ số bắt đầu đến cuối chuỗi?",
    options: [
      "substring(int start, int end)",
      "substring(int startIndex)",
      "indexOf(String)",
      "charAt(int index)",
    ],
    answer: 1,
    explanation:
      "Phương thức String substring(int startIndex) trả về chuỗi con từ chỉ số bắt đầu đến hết [60, 65].",
  },
  {
    id: 1579,
    topic: "Data Structures",
    type: "radio",
    question:
      "Việc sử dụng StringBuilder/StringBuffer khi không cần thread safety là khuyến nghị từ phiên bản Java nào?",
    options: ["Java 1.0", "JDK 5.0", "JDK 8", "JDK 11"],
    answer: 1,
    explanation:
      "StringBuilder/StringBuffer là một trong những lớp được sử dụng phổ biến nhất. Kể từ Java 5.0, bạn nên sử dụng StringBuilder thay vì StringBuffer nếu không cần thread-safe [59].",
  },
  {
    id: 1580,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau đây sử dụng phương thức nào của StringBuffer?",
    code: "StringBuffer sb = new StringBuffer(\"Hello\");\nsb.setCharAt(0, 'J');",
    options: ["append()", "replace()", "setCharAt()", "insert()"],
    answer: 2,
    explanation:
      "Phương thức setCharAt(int index, char ch) thay thế một ký tự tại vị trí đã cho [33, 57].",
  },
  {
    id: 1581,
    topic: "Data Structures",
    type: "radio",
    question: "String có các phương thức tìm kiếm tiến (search forwards) nào?",
    options: [
      "only indexOf(String)",
      "indexOf(int ch) và indexOf(int ch, int from)",
      "lastIndexOf()",
      "delete()",
    ],
    answer: 1,
    explanation:
      "Các phương thức tìm kiếm tiến bao gồm int indexOf(int ch), int indexOf(int ch, int from), int indexOf(String), và int indexOf(String s, int from) [62, 65].",
  },
  {
    id: 1582,
    topic: "Data Structures",
    type: "radio",
    question: "Tính năng nào sau đây được hỗ trợ bởi String Class?",
    options: [
      "Xóa ký tự (delete()).",
      "Thay thế tất cả các lần xuất hiện của một ký tự bằng ký tự khác (replace()).",
      "Thay đổi kích thước chuỗi (setSize()).",
      "Ghi đè chuỗi gốc.",
    ],
    answer: 1,
    explanation:
      "Phương thức String replace(char oldChar, char newChar) trả về một chuỗi mới mà tất cả các lần xuất hiện của oldChar được thay thế bằng newChar [65, 66].",
  },
  {
    id: 1583,
    topic: "Data Structures",
    type: "radio",
    question:
      "Tại sao việc sử dụng toán tử '+' để nối chuỗi trong vòng lặp lớn lại là 'lãng phí bộ nhớ'?",
    options: [
      "Toán tử '+' là một checked exception.",
      "Nó tạo ra nhiều đối tượng String trung gian bị bỏ rơi, không được GC thu thập ngay lập tức.",
      "Nó khiến String Pool bị tràn.",
      "Toán tử '+' chậm hơn StringBuffer/StringBuilder.",
    ],
    answer: 1,
    explanation:
      "Trong vòng lặp, việc nối chuỗi tạo ra nhiều đối tượng String trung gian (do String bất biến), và các chuỗi này (nếu không được tham chiếu) sẽ ngồi đó lãng phí bộ nhớ [55, 56].",
  },
  {
    id: 1584,
    topic: "Data Structures",
    type: "radio",
    question: "Phương thức `length()` của String dùng để làm gì?",
    options: [
      "Đếm số byte của chuỗi.",
      "Đếm số ký tự trong mảng ký tự làm nên chuỗi.",
      "Kiểm tra xem chuỗi có rỗng hay không.",
      "Trả về độ dài tối đa của chuỗi.",
    ],
    answer: 1,
    explanation:
      "Phương thức length() đếm số lượng ký tự trong mảng ký tự đó [16, 60, 62].",
  },
  {
    id: 1585,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau đây có compile không, và nếu có thì output là gì?",
    code: 'String s = "Hello";\ns.toUpperCase();\nSystem.out.println(s);',
    options: [
      "Compile thành công, output là HELLO.",
      "Compile thành công, output là Hello.",
      "Lỗi biên dịch vì String là bất biến.",
      "Runtime Exception.",
    ],
    answer: 1,
    explanation:
      "String là bất biến. Phương thức toUpperCase() trả về một String MỚI là HELLO, nhưng nó không được gán lại cho s, do đó s vẫn là 'Hello'. [66].",
  },
  {
    id: 1586,
    topic: "Data Structures",
    type: "radio",
    question:
      "Để chuyển một đối tượng StringBuffer thành String, bạn sử dụng phương thức nào?",
    options: [
      "convertToString()",
      "toString()",
      "toImmutableString()",
      "getString()",
    ],
    answer: 1,
    explanation:
      "StringBuffer cung cấp phương thức String toString() để chuyển đổi nội dung thành String [57, 60].",
  },
  {
    id: 1587,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong trường hợp nào, bạn nên chọn StringBuffer thay vì StringBuilder?",
    options: [
      "Khi cần hiệu suất cao nhất.",
      "Khi cần thao tác chuỗi trong môi trường đơn luồng (single-threaded).",
      "Khi cần thao tác chuỗi trong môi trường đa luồng (multi-threaded) và cần thread-safe.",
      "Khi chuỗi không cần thay đổi.",
    ],
    answer: 2,
    explanation:
      "Nên sử dụng StringBuilder, trừ khi thao tác chuỗi cần phải an toàn cho luồng, khi đó nên dùng StringBuffer [59].",
  },
  {
    id: 1588,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của việc sử dụng phương thức `charAt(int index)` trong String/StringBuffer là gì?",
    options: [
      "Trả về chỉ số của ký tự.",
      "Trả về một chuỗi con.",
      "Trả về ký tự tại vị trí (index) được chỉ định.",
      "Thay thế ký tự tại vị trí đó.",
    ],
    answer: 2,
    explanation:
      "Phương thức char charAt(int index) trả về ký tự tại vị trí index [57, 60, 62].",
  },
  {
    id: 1589,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức `lastIndexOf(String)` trong String Class được dùng để làm gì?",
    options: [
      "Tìm vị trí của lần xuất hiện đầu tiên của chuỗi con.",
      "Tìm vị trí của lần xuất hiện cuối cùng của chuỗi con (tìm kiếm ngược).",
      "Chỉ dùng để tìm ký tự.",
      "Thay thế chuỗi con.",
    ],
    answer: 1,
    explanation:
      "Các phương thức lastIndexOf() được sử dụng để tìm kiếm ngược (search backwards) vị trí của ký tự hoặc chuỗi con [65].",
  },
  {
    id: 1590,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu bạn muốn thay thế một đoạn chuỗi con trong StringBuffer, bạn sử dụng phương thức nào?",
    options: [
      "replace(int start, int end, String s)",
      "update(String s)",
      "substring(int start, int end)",
      "set(String s)",
    ],
    answer: 0,
    explanation:
      "StringBuffer/StringBuilder hỗ trợ phương thức replace(int start, int end, String s) để thay thế một phần chuỗi [61].",
  },
  {
    id: 1591,
    topic: "Data Structures",
    type: "radio",
    question: "Đâu là một constructor hợp lệ để khởi tạo StringBuffer?",
    options: [
      "StringBuffer(byte[])",
      "StringBuffer(String)",
      "StringBuffer(char[])",
      "StringBuffer(Object)",
    ],
    answer: 1,
    explanation:
      "StringBuffer có thể được khởi tạo bằng StringBuffer(String), StringBuffer(int length), hoặc StringBuffer() [57].",
  },
  {
    id: 1592,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào trong String Class chuyển đổi String thành một mảng các ký tự (char array)?",
    options: ["toCharArray()", "toCharBuffer()", "getChars()", "split()"],
    answer: 0,
    explanation:
      "String class cung cấp phương thức char [] toCharArray() [66].",
  },
  {
    id: 1593,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của việc String Class có phương thức `length()` (dạng method) thay vì chỉ là field `length` như Array là gì?",
    options: [
      "Đó chỉ là một quy ước.",
      "Vì String là một đối tượng, không phải là mảng nguyên thủy.",
      "Để ẩn giấu chi tiết triển khai bên trong.",
      "Không có sự khác biệt.",
    ],
    answer: 1,
    explanation:
      "String là một class [16], còn Array là một object nhưng có thể được xem là kiểu dữ liệu đặc biệt, có thuộc tính `length` là một trường (field) [18, 25].",
  },
  {
    id: 1594,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào trong String Class được dùng để tìm kiếm tiến vị trí của một ký tự (dưới dạng int ch) từ một chỉ số bắt đầu cụ thể?",
    options: [
      "indexOf(int ch, int from)",
      "search(int ch)",
      "charAt(int from)",
      "startsWith(int ch, int from)",
    ],
    answer: 0,
    explanation:
      "Phương thức int indexOf(int ch, int from) được dùng để tìm kiếm tiến [65].",
  },
  {
    id: 1595,
    topic: "Data Structures",
    type: "radio",
    question:
      "Để tối ưu hóa việc tạo String bằng cách sử dụng các giá trị primitive (ví dụ: int), String Class cung cấp phương thức nào?",
    options: ["format()", "valueOf()", "parsePrimitive()", "concat()"],
    answer: 1,
    explanation:
      "String Class có phương thức valueOf(int i) (và các primitives khác) để tạo ra String từ primitive [61].",
  },
  {
    id: 1596,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu cần tạo một String mới bằng cách thay thế tất cả các ký tự cũ bằng ký tự mới trong String gốc, String Class sử dụng phương thức nào?",
    options: [
      "replace(char old, char new)",
      "replaceAll(String old, String new)",
      "update(char old, char new)",
      "setCharAt()",
    ],
    answer: 0,
    explanation:
      "Phương thức String replace(char oldChar, char newChar) trả về một chuỗi mới mà tất cả các lần xuất hiện của oldChar được thay thế bằng newChar [65, 66].",
  },
  {
    id: 1597,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng thay đổi nội dung của một String (ví dụ: gán ký tự mới) bằng cách sử dụng phương thức `setCharAt()`?",
    options: [
      "Thao tác thành công nếu chuỗi được tạo bằng `new`.",
      "String Class không có phương thức `setCharAt()`.",
      "Gây ra NullPointerException.",
      "Gây ra StringIndexOutOfBoundsException.",
    ],
    answer: 1,
    explanation:
      "String là bất biến và không có phương thức setCharAt() [18, 60, 66]. Phương thức này chỉ có trong StringBuffer/StringBuilder [33, 57].",
  },
  {
    id: 1598,
    topic: "Data Structures",
    type: "radio",
    question:
      "StringBuffer có thể được khởi tạo bằng cách sử dụng một mảng byte (byte[]) không?",
    options: [
      "Có.",
      "Không.",
      "Chỉ khi sử dụng String.intern().",
      "Chỉ khi sử dụng Generics.",
    ],
    answer: 1,
    explanation:
      "Các constructor được liệt kê cho StringBuffer là: StringBuffer(String), StringBuffer(int length), StringBuffer() [57]. Constructor của String class có thể nhận byte[] [18], nhưng StringBuffer thì không (dựa trên nguồn).",
  },
  {
    id: 1599,
    topic: "Data Structures",
    type: "radio",
    question: "Phương thức `delete(int index)` trong StringBuffer làm gì?",
    options: [
      "Xóa tất cả các ký tự từ chỉ số đó đến cuối.",
      "Xóa chính xác 01 ký tự tại vị trí index.",
      "Xóa toàn bộ chuỗi.",
      "Không có phương thức này.",
    ],
    answer: 1,
    explanation: "Phương thức delete(int index) xóa 01 ký tự [64].",
  },
  {
    id: 1600,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là lợi ích của tính bất biến (immutability) của String?",
    options: [
      "Tăng tốc độ Garbage Collection.",
      "Cho phép sử dụng String Pool để chia sẻ đối tượng String có cùng giá trị, tiết kiệm bộ nhớ.",
      "Giảm lỗi NumberFormatException.",
      "Cho phép String được sử dụng như một tham chiếu.",
    ],
    answer: 1,
    explanation:
      "Strings bất biến cho phép JVM sử dụng String Pool, nơi các đối tượng String có cùng giá trị có thể được tham chiếu lại, giảm sử dụng bộ nhớ [56, 68].",
  },
  {
    id: 1601,
    topic: "Data Structures",
    type: "radio",
    question: "String Pool (String Constant Pool) là gì?",
    options: [
      "Một khu vực lưu trữ String trong Stack memory.",
      "Một khu vực lưu trữ đặc biệt trong Heap, lưu trữ String literals.",
      "Một lớp tiện ích để xử lý String.",
      "Một giao diện (interface) để so sánh String.",
    ],
    answer: 1,
    explanation:
      "String Pool là khu vực lưu trữ đặc biệt trong heap, lưu trữ các string literal, nhằm giảm sử dụng bộ nhớ và cải thiện hiệu suất [68, 69].",
  },
  {
    id: 1602,
    topic: "Data Structures",
    type: "radio",
    question:
      'Khi tạo String bằng String Literal (ví dụ: `String s = "Java";`), điều gì xảy ra nếu "Java" đã tồn tại trong String Pool?',
    options: [
      "Một đối tượng mới luôn được tạo ra trên Heap.",
      "JVM tạo ra một bản sao mới trong Pool.",
      "JVM trả về một tham chiếu đến thể hiện đã được pooled (tồn tại) đó.",
      "Gây ra lỗi biên dịch.",
    ],
    answer: 2,
    explanation:
      "Khi tạo một string literal, JVM kiểm tra Pool; nếu có, JVM trả về một tham chiếu đến thể hiện đã được pooled [68].",
  },
  {
    id: 1603,
    topic: "Data Structures",
    type: "radio",
    question:
      'Khi sử dụng từ khóa `new` để tạo String (ví dụ: `String s = new String("Java");`), đối tượng được tạo ở đâu?',
    options: [
      "Luôn luôn trong String Pool.",
      "Trong Heap, bên ngoài String Pool.",
      "Trong Stack.",
      "Trong Static Memory.",
    ],
    answer: 1,
    explanation:
      "Sử dụng từ khóa new tạo một chuỗi mới trong heap (bên ngoài pool) [70-72].",
  },
  {
    id: 1604,
    topic: "Data Structures",
    type: "radio",
    question: "Mục đích của việc duy trì String Pool là gì?",
    options: [
      "Đảm bảo tính bất biến của String.",
      "Tăng cường tính đa hình.",
      "Giảm sử dụng bộ nhớ và cải thiện hiệu suất bằng cách tránh tạo các đối tượng String trùng lặp.",
      "Cung cấp các phương thức tiện ích cho String.",
    ],
    answer: 2,
    explanation:
      "String Pool được duy trì bởi lớp String nhằm giảm sử dụng bộ nhớ và cải thiện hiệu suất [68, 69].",
  },
  {
    id: 1605,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để ép buộc một đối tượng String, dù được tạo bằng `new`, được đặt vào String Pool hoặc tham chiếu đến một đối tượng có sẵn trong Pool?",
    options: ["toPool()", "pool()", "intern()", "valueOf()"],
    answer: 2,
    explanation:
      "Phương thức intern() đặt một chuỗi vào String Pool hoặc tham chiếu đến một đối tượng chuỗi hiện có trong Pool với cùng giá trị [72].",
  },
  {
    id: 1606,
    topic: "Data Structures",
    type: "code",
    question:
      "Đoạn code sau đây tạo ra bao nhiêu đối tượng String 'Java' trên Heap (bao gồm cả Pool và Heap)?",
    code: 'String s1 = "Java";\nString s2 = new String("Java");',
    options: ["1", "2", "3", "0"],
    answer: 1,
    explanation:
      "s1 tạo một đối tượng trong Pool. s2 tạo một đối tượng mới trên Heap. Tổng cộng có 2 đối tượng String 'Java' [68, 70, 71].",
  },
  {
    id: 1607,
    topic: "Data Structures",
    type: "radio",
    question: "String Pool còn được gọi bằng tên nào khác?",
    options: [
      "String Dynamic Pool.",
      "String Intern Pool hoặc String Constant Pool.",
      "Stack String Area.",
      "String Memory Cache.",
    ],
    answer: 1,
    explanation:
      "String Pool còn được gọi là String Intern Pool hoặc String Constant Pool [68, 69].",
  },
  {
    id: 1608,
    topic: "Data Structures",
    type: "radio",
    question:
      'Điều gì xảy ra nếu hai String Literal có cùng giá trị (ví dụ: `"Python"` và `"Python"`)?',
    options: [
      "Chúng là hai đối tượng khác nhau trên Heap.",
      "Chúng tham chiếu đến cùng một đối tượng trong String Pool.",
      "Chỉ cái đầu tiên được thêm vào Pool, cái thứ hai được đặt trên Heap.",
      "Gây ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Vì cả hai đều là literal và có cùng giá trị, chúng cùng trỏ đến cùng một thể hiện trong String Pool [68, 72].",
  },
  {
    id: 1609,
    topic: "Data Structures",
    type: "radio",
    question: "String Class quản lý String Pool bằng cách nào?",
    options: [
      "Sử dụng Garbage Collector.",
      "Duy trì một vùng lưu trữ đặc biệt trong Heap.",
      "Sử dụng interface Iterator.",
      "Tạo ra các String mới cho mỗi lần tham chiếu.",
    ],
    answer: 1,
    explanation:
      "String Pool được duy trì bởi lớp String. Nó là một khu vực lưu trữ đặc biệt trong Heap [68].",
  },
  {
    id: 1610,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu một đối tượng String được tạo bằng `new`, nó có thể được làm cho trở thành 'interned' không?",
    options: [
      "Không, chỉ literal mới được interned.",
      "Có, bằng cách gọi phương thức `intern()`.",
      "Chỉ khi đối tượng đó được Garbage Collected.",
      "Chỉ khi sử dụng phương thức `valueOf()`.",
    ],
    answer: 1,
    explanation:
      "Mặc dù `new` tạo String ngoài Pool, ta có thể gọi `intern()` để ép nó vào Pool hoặc tham chiếu đến đối tượng có sẵn [72].",
  },
  {
    id: 1611,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về Heap Memory trong Java?",
    options: [
      "Chỉ lưu trữ primitive data.",
      "Nơi các biến cục bộ (local variables) được lưu trữ.",
      "Nơi tất cả các đối tượng được phân bổ động.",
      "Heap được quản lý hoàn toàn bằng phương thức `System.gc()`.",
    ],
    answer: 2,
    explanation:
      "Trong Java, tất cả các đối tượng được phân bổ động trên Heap [38, 73].",
  },
  {
    id: 1612,
    topic: "Data Structures",
    type: "code",
    question:
      'Nếu s5 được tạo bằng new String("Python"), s1 được tạo bằng literal. Kết quả của `s1 == s5` là gì?',
    code: 'String s1 = "Python";\nString s5 = new String("Python");\nSystem.out.println(s1 == s5);',
    options: ["true", "false", "Lỗi biên dịch", "Phụ thuộc vào JVM"],
    answer: 1,
    explanation:
      "s1 là tham chiếu đến đối tượng trong Pool. s5 là tham chiếu đến đối tượng mới trên Heap. `==` so sánh tham chiếu, do đó kết quả là false [39, 40, 72].",
  },
  {
    id: 1613,
    topic: "Data Structures",
    type: "radio",
    question:
      "Khi một String Literal được Garbage Collected, nó sẽ xảy ra ở đâu?",
    options: [
      "String Pool không được Garbage Collector dọn dẹp.",
      "Trong Heap, nhưng chỉ sau khi Pool bị xóa.",
      "Trong Stack memory.",
      "Trong Static memory.",
    ],
    answer: 0,
    explanation:
      "Garbage Collector không đi vào String Pool. Các String bị bỏ rơi trong Pool sẽ chỉ ngồi đó lãng phí bộ nhớ [56].",
  },
  {
    id: 1614,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về việc String là một class?",
    options: [
      "Nó bắt buộc phải bắt đầu bằng chữ thường.",
      "Nó không có bất kỳ phương thức nào.",
      "Nó bắt đầu bằng chữ hoa 'S' và cung cấp các phương thức như length().",
      "Nó có thể được sử dụng như primitive type.",
    ],
    answer: 2,
    explanation:
      "String là một class, bắt đầu bằng chữ hoa 'S' và là một đối tượng, có các phương thức như length() và equals() [16].",
  },
  {
    id: 1615,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu hai đối tượng String, `s1` và `s2`, được so sánh bằng `s1.equals(s2)` trả về true, điều gì có thể xảy ra khi so sánh bằng `s1 == s2`?",
    options: [
      "Luôn luôn true.",
      "Luôn luôn false.",
      "Có thể true (nếu chúng cùng là literal hoặc interned) hoặc false (nếu là hai đối tượng riêng biệt trên Heap).",
      "Gây ra lỗi biên dịch.",
    ],
    answer: 2,
    explanation:
      "`.equals()` so sánh nội dung (đã bằng). `==` so sánh tham chiếu. Nếu chúng là hai đối tượng khác nhau trên Heap (tạo bằng `new`), `==` sẽ false [39]. Nếu chúng là cùng một đối tượng (literal hoặc interned), `==` sẽ true [72].",
  },
  {
    id: 1616,
    topic: "Data Structures",
    type: "radio",
    question: "String Pool được duy trì bởi lớp nào?",
    options: ["Lớp Object.", "Lớp Math.", "Lớp String.", "Lớp Character."],
    answer: 2,
    explanation: "String Pool được duy trì bởi lớp String [68].",
  },
  {
    id: 1617,
    topic: "Data Structures",
    type: "radio",
    question:
      "Điều gì là SAI về String literals và String objects được tạo bằng `new`?",
    options: [
      "Literal được ưu tiên đặt trong String Pool.",
      "Đối tượng `new` luôn nằm ngoài Pool ban đầu.",
      "Cả hai đều là Immutable.",
      "Cả hai đều không thể được làm cho trở thành 'interned'.",
    ],
    answer: 3,
    explanation:
      "Các đối tượng tạo bằng `new` vẫn có thể được làm cho trở thành 'interned' bằng cách gọi phương thức `intern()` [72].",
  },
  {
    id: 1618,
    topic: "Data Structures",
    type: "code",
    question:
      "Đoạn code sau đây tạo ra bao nhiêu đối tượng String 'Data Science' trong String Pool?",
    code: 'String str2 = "Data Science";\nString str6 = new String ("Data Science");\nString str7 = new String("Data Science").intern();',
    options: ["1", "2", "3", "0"],
    answer: 0,
    explanation:
      "str2 tạo ra 1 đối tượng trong Pool. str6 tạo ra 1 đối tượng trên Heap, nhưng tham chiếu literal trong constructor có thể đã được Pool trước đó. str7 gọi intern(), trỏ đến đối tượng đã có trong Pool. Do đó, chỉ có 1 đối tượng 'Data Science' trong Pool [70, 72].",
  },
  {
    id: 1619,
    topic: "Data Structures",
    type: "radio",
    question: "Tham chiếu String (String variable) được lưu trữ ở đâu?",
    options: [
      "Trên Stack (nếu là local variable) hoặc Heap (nếu là instance variable).",
      "Luôn trên Heap.",
      "Luôn trên Stack.",
      "Trong String Pool.",
    ],
    answer: 0,
    explanation:
      "Các biến cục bộ (Local variables) và thông tin về lệnh gọi phương thức được lưu trên Stack [38, 74]. Tham chiếu là một biến [38]. Đối tượng String thực tế được lưu trên Heap [38].",
  },
  {
    id: 1620,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về String Pool?",
    options: [
      "Nó nằm trong Static memory.",
      "Nó chỉ lưu trữ chuỗi rỗng.",
      "Nó là một vùng lưu trữ đặc biệt trong Heap.",
      "Nó được tạo ra để lưu trữ String Mutable.",
    ],
    answer: 2,
    explanation: "String Pool là một khu vực lưu trữ đặc biệt trong heap [68].",
  },
  {
    id: 1621,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu hai String được so sánh bằng `==` và trả về true, điều này ngụ ý gì?",
    options: [
      "Chúng có cùng nội dung nhưng khác đối tượng.",
      "Chúng trỏ đến cùng một địa chỉ bộ nhớ (cùng một đối tượng).",
      "Chúng đã được tạo bằng `new`.",
      "Chúng đã được tạo bằng `equals()`.",
    ],
    answer: 1,
    explanation:
      "Toán tử `==` so sánh tham chiếu, tức là kiểm tra xem cả hai đối tượng có trỏ đến cùng một vị trí bộ nhớ hay không [39, 40].",
  },
  {
    id: 1622,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu s2 và s3 trỏ đến cùng một đối tượng, kết quả của `s2 == s3` là gì?",
    code: 'String s1 = new String("Hello");\nString s2 = new String("Hello");\nString s3 = s2;\nSystem.out.println(s2 == s3);',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "s3 được gán giá trị của s2 (tham chiếu được sao chép). Do đó, cả hai tham chiếu trỏ đến cùng một đối tượng. `==` so sánh tham chiếu nên trả về true [39, 75].",
  },
  {
    id: 1623,
    topic: "Data Structures",
    type: "radio",
    question: "String là Immutable vì lý do nào?",
    options: [
      "Vì nó là kiểu primitive.",
      "Vì nó được lưu trữ trên Stack.",
      "Vì mục đích bảo mật và tiết kiệm bộ nhớ (sử dụng Pool).",
      "Vì nó không có constructor.",
    ],
    answer: 2,
    explanation:
      "Strings bất biến vì mục đích bảo mật và tiết kiệm bộ nhớ (conserving memory) [55, 56].",
  },
  {
    id: 1624,
    topic: "Data Structures",
    type: "radio",
    question:
      "Mục đích của việc sử dụng String.intern() trên một String được tạo bằng `new` là gì?",
    options: [
      "Bắt buộc đối tượng đó được Garbage Collected.",
      "Bắt buộc đối tượng đó được đưa vào Stack.",
      "Bắt buộc đối tượng đó được chia sẻ trong String Pool nếu chưa có.",
      "Chỉ để so sánh nội dung.",
    ],
    answer: 2,
    explanation:
      "Phương thức intern() đặt một chuỗi vào String Pool hoặc tham chiếu đến một đối tượng chuỗi hiện có trong Pool với cùng giá trị [72].",
  },
  {
    id: 1625,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu String được tạo ra từ một `StringBuffer`, nó sẽ ở trong String Pool không?",
    options: [
      "Có, luôn luôn.",
      "Không, nó là một đối tượng mới trên Heap.",
      "Nó là một literal.",
      "Nó là một đối tượng String, vị trí của nó phụ thuộc vào việc có gọi `intern()` hay không.",
    ],
    answer: 1,
    explanation:
      "String có constructor String(StringBuffer) [18]. Kết quả là một đối tượng String mới (Immutable) trên Heap. Việc nó có vào Pool hay không phụ thuộc vào `intern()`.",
  },
  {
    id: 1626,
    topic: "Data Structures",
    type: "radio",
    question: "Khẳng định nào sau đây là ĐÚNG về String trong Java?",
    options: [
      "Nó là một kiểu dữ liệu nguyên thủy.",
      "Nó được bọc bởi lớp Wrapper Character.",
      "Nó có các phương thức như `length()` và `equals()`.",
      "Nó được Garbage Collected ngay lập tức sau khi bị bỏ rơi.",
    ],
    answer: 2,
    explanation:
      "String là một class và cung cấp các phương thức như length() và equals() [16].",
  },
  {
    id: 1627,
    topic: "Data Structures",
    type: "radio",
    question:
      "Để so sánh hai đối tượng String có nội dung giống nhau nhưng được tạo bằng `new` (hai đối tượng Heap khác nhau), bạn nên sử dụng phương thức nào?",
    options: ["==", "compare()", "equals()", "intern()"],
    answer: 2,
    explanation:
      "Sử dụng .equals() để xem hai đối tượng khác nhau có bằng nhau không (so sánh nội dung) [76]. So sánh bằng `==` sẽ trả về false [39].",
  },
  {
    id: 1628,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về String Constant Pool?",
    options: [
      "Nó chỉ lưu trữ String có kích thước nhỏ.",
      "Nó nhằm mục đích tối đa hóa việc sử dụng bộ nhớ.",
      "Nó tối ưu hóa việc tạo String literal.",
      "Nó là một phần của Stack memory.",
    ],
    answer: 2,
    explanation:
      "String Constant Pool (String Pool) nhằm mục đích giảm sử dụng bộ nhớ và cải thiện hiệu suất bằng cách tối ưu hóa việc lưu trữ string literals [68, 69].",
  },
  {
    id: 1629,
    topic: "Data Structures",
    type: "radio",
    question:
      'Nếu một chuỗi được tạo bằng `new String("A")` và sau đó được gọi `intern()`, và sau đó một String literal `"A"` được tạo, điều gì xảy ra?',
    options: [
      'Hai đối tượng "A" khác nhau tồn tại trong Pool.',
      "Hai tham chiếu String trỏ đến cùng một đối tượng trong Pool.",
      "Sẽ có lỗi runtime.",
      "Tham chiếu literal sẽ trỏ ra ngoài Pool.",
    ],
    answer: 1,
    explanation:
      'Lần đầu tiên `intern()` được gọi, nó thêm "A" vào Pool. Literal "A" sau đó sẽ tìm thấy đối tượng đó và tham chiếu đến cùng một vị trí [68, 72].',
  },
  {
    id: 1630,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu `str1` và `str2` được tạo như sau, kết quả của `str1.equals(str2)` là gì?",
    code: 'String str1 = new String("C++");\nString str2 = new String("C++");\nSystem.out.println(str1.equals(str2));',
    options: ["true", "false", "Lỗi biên dịch", "Phụ thuộc vào intern()"],
    answer: 0,
    explanation:
      "Phương thức equals() so sánh nội dung của chuỗi. Mặc dù chúng là hai đối tượng khác nhau, nội dung của chúng là 'C++', do đó trả về true [16, 76].",
  },
  {
    id: 1631,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì mô tả tốt nhất bộ nhớ Heap?",
    options: [
      "Bộ nhớ chỉ chứa code của chương trình.",
      "Bộ nhớ được quản lý bằng Stack Pointer.",
      "Bộ nhớ động chứa tất cả các đối tượng và biến thể hiện (instance variables).",
      "Bộ nhớ tĩnh cho hằng số.",
    ],
    answer: 2,
    explanation:
      "Heap memory chứa dữ liệu động (Dynamic data), bao gồm Objects & instance variables được tạo bằng new [38].",
  },
  {
    id: 1632,
    topic: "Data Structures",
    type: "radio",
    question:
      "Lý do quan trọng nhất khiến String được thiết kế Immutable là gì?",
    options: [
      "Để làm cho việc debug dễ dàng hơn.",
      "Để cho phép chúng được sử dụng như keys trong HashMap (Hashmap keys need to be immutable).",
      "Để cho phép chia sẻ đối tượng an toàn trong String Pool.",
      "Để bắt buộc sử dụng StringBuilder.",
    ],
    answer: 2,
    explanation:
      "Strings là bất biến vì một trong những lý do chính là để cho phép chia sẻ đối tượng an toàn trong String Pool (nếu String thay đổi được, việc chia sẻ sẽ không an toàn) [56].",
  },
  {
    id: 1633,
    topic: "Data Structures",
    type: "radio",
    question: "Các biến primitive data được lưu trữ chủ yếu ở đâu?",
    options: [
      "Heap memory.",
      "Stack memory.",
      "String Pool.",
      "Static memory.",
    ],
    answer: 1,
    explanation:
      "Các biến cục bộ (Local variables) và primitive data được lưu trữ trên Stack memory [38, 74].",
  },
  {
    id: 1634,
    topic: "Data Structures",
    type: "radio",
    question: "Điều gì là ĐÚNG về String Pool so với Heap chung?",
    options: [
      "String Pool được dọn dẹp thường xuyên bởi GC.",
      "String Pool là nơi lưu trữ các đối tượng String Mutable.",
      "String Pool nằm trong Heap nhưng có quy tắc quản lý riêng biệt (ví dụ: GC).",
      "String Pool nằm ngoài Heap.",
    ],
    answer: 2,
    explanation:
      "String Pool là một khu vực đặc biệt trong Heap [68]. GC không đi vào String Pool [56].",
  },
  {
    id: 1635,
    topic: "Data Structures",
    type: "radio",
    question:
      "String được tạo ra từ String literal có phương thức nào để chuyển đổi tất cả các ký tự thành chữ thường?",
    options: ["toLowerCase()", "toLower()", "lowerCase()", "getLowerCase()"],
    answer: 0,
    explanation:
      "String class cung cấp phương thức String toLowerCase() [62, 66].",
  },
  {
    id: 1636,
    topic: "Data Structures",
    type: "radio",
    question:
      "Nếu String `s1` được tạo bằng literal và `s2` được tạo bằng `new`, làm thế nào để so sánh chúng một cách tối ưu về mặt nội dung?",
    options: [
      "Sử dụng `s1 == s2`.",
      "Sử dụng `s1.compareTo(s2) == 0`.",
      "Sử dụng `s1.intern() == s2.intern()`.",
      "Sử dụng `s1.equals(s2)`.",
    ],
    answer: 3,
    explanation:
      "Phương thức equals() so sánh nội dung chuỗi [16, 76]. compareTo() cũng so sánh nội dung nhưng trả về số nguyên [62].",
  },
  {
    id: 1637,
    topic: "Data Structures",
    type: "radio",
    question:
      "Trong trường hợp nào, `s1.equals(s2)` và `s1 == s2` đều trả về true?",
    options: [
      "Khi cả hai được tạo bằng `new`.",
      "Khi `s1` được gán cho `s2` (s2 = s1).",
      "Khi nội dung của chúng khác nhau.",
      "Khi chúng là String literals có nội dung khác nhau.",
    ],
    answer: 1,
    explanation:
      "Nếu s2 = s1, chúng trỏ đến cùng một đối tượng, nên `==` là true [37]. Nội dung cũng giống nhau nên `equals()` là true.",
  },
  {
    id: 1638,
    topic: "Data Structures",
    type: "radio",
    question:
      "Phương thức `compareTo(String)` của String Class trả về giá trị nào nếu hai chuỗi bằng nhau?",
    options: ["True.", "False.", "Một số nguyên dương.", "0."],
    answer: 3,
    explanation:
      "Phương thức compareTo(String) trả về 0 nếu hai chuỗi bằng nhau [62].",
  },
  {
    id: 1639,
    topic: "Data Structures",
    type: "radio",
    question: "Khi String là bất biến, các phương thức như `replace()` làm gì?",
    options: [
      "Thay đổi String tại chỗ, nhưng chỉ trong Heap.",
      "Tạo và trả về một đối tượng String mới với nội dung đã được sửa đổi.",
      "Sử dụng StringBuffer để thực hiện thay đổi.",
      "Gây ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Phương thức replace() trả về một chuỗi mới [65], do String là bất biến, nó không thể thay đổi đối tượng gốc [55].",
  },
  {
    id: 1640,
    topic: "Data Structures",
    type: "radio",
    question:
      "Sự khác biệt giữa `String(String)` và `String(char[])` khi khởi tạo String là gì?",
    options: [
      "Cả hai đều tạo một đối tượng String mới.",
      "Chỉ `String(String)` sử dụng String Pool.",
      "Chỉ `String(char[])` sử dụng String Pool.",
      "Cả hai đều là Immutable.",
    ],
    answer: 3,
    explanation:
      "Cả hai đều là constructor để tạo String [18] và String là Immutable [18, 55].",
  },
  {
    id: 1641,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Test";\nString s2 = "Test";\nSystem.out.println(s1 == s2);',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào nội dung"],
    answer: 0,
    explanation:
      "Cả hai được tạo bằng String literal, nên chúng trỏ đến cùng một đối tượng trong String Pool. `==` so sánh tham chiếu, kết quả là true [68, 77].",
  },
  {
    id: 1642,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = new String("Hello");\nString s2 = new String("Hello");\nSystem.out.println(s1 == s2);',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 1,
    explanation:
      "Cả hai đều được tạo bằng `new`, là hai đối tượng khác nhau trên Heap, ngay cả khi nội dung giống nhau. `==` so sánh tham chiếu, kết quả là false [39, 40].",
  },
  {
    id: 1643,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = new String("Java");\nString s2 = new String("Java");\nSystem.out.println(s1.equals(s2));',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào intern()"],
    answer: 0,
    explanation:
      "Phương thức equals() so sánh nội dung. Nội dung là như nhau, nên trả về true [16, 76].",
  },
  {
    id: 1644,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "World";\nString s2 = "World";\nSystem.out.println(s1.equals(s2));',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "equals() so sánh nội dung. Nội dung giống nhau, nên trả về true [16, 76].",
  },
  {
    id: 1645,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String str1 = "Python";\nString str2 = "Python";\nString str4 = new String("Python").intern();\nSystem.out.println(str1 == str4);',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "str1 là literal (trong Pool). str4 gọi intern(), nên nó cũng trỏ đến đối tượng trong Pool. `==` so sánh tham chiếu, kết quả là true [72].",
  },
  {
    id: 1646,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Test";\nString s2 = s1;\nSystem.out.println(s1 == s2);',
    options: ["true", "false", "Lỗi biên dịch", "1"],
    answer: 0,
    explanation:
      "s2 được gán tham chiếu của s1, nên chúng trỏ đến cùng một đối tượng. `==` so sánh tham chiếu, kết quả là true [37].",
  },
  {
    id: 1647,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "A";\nString s2 = new String("A");\nSystem.out.println(s1.equals(s2));',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào Heap"],
    answer: 0,
    explanation:
      "equals() so sánh nội dung, nội dung là 'A', kết quả là true [16, 76].",
  },
  {
    id: 1648,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String str1 = "Data Science";\nString str3 = new String("Data Science");\nSystem.out.println(str1 == str3);',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào GC"],
    answer: 1,
    explanation:
      "str1 (Pool) và str3 (Heap) là hai đối tượng khác nhau, có tham chiếu khác nhau. `==` so sánh tham chiếu, kết quả là false [39, 70, 72].",
  },
  {
    id: 1649,
    topic: "Data Structures",
    type: "code",
    question:
      "Điều gì xảy ra nếu cố gắng so sánh String với Integer bằng `==`?",
    code: 'String s = "5";\nInteger i = 5;\nSystem.out.println(s == i);',
    options: [
      "true (nhờ Autoboxing/Unboxing)",
      "Lỗi biên dịch: toán tử `==` không thể áp dụng cho String và Integer.",
      "false",
      "5",
    ],
    answer: 1,
    explanation:
      "Lỗi biên dịch vì toán tử `==` không thể áp dụng cho hai kiểu đối tượng không liên quan, hoặc so sánh String và int/Integer (trừ khi có ép kiểu rõ ràng, nhưng vẫn không hợp lệ với String) [78]. `==` chỉ hợp lệ cho primitives hoặc so sánh reference/primitive với Wrapper (nhờ Unboxing) hoặc hai references cùng loại [39, 79].",
  },
  {
    id: 1650,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "abc";\nString s2 = new String(s1);\nSystem.out.println(s1.equals(s2));',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "s2 được tạo bằng constructor String(String) [18]. Dù s1 và s2 là hai đối tượng khác nhau (s1 trong Pool, s2 trên Heap), equals() so sánh nội dung, kết quả là true [16, 76].",
  },
  {
    id: 1651,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "hello";\nString s2 = "HE" + "LLO";\nSystem.out.println(s1.equalsIgnoreCase(s2));',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào Heap"],
    answer: 0,
    explanation:
      "s1 là 'hello', s2 là 'HELLO'. equalsIgnoreCase() so sánh nội dung mà không phân biệt chữ hoa, chữ thường, kết quả là true [62, 67].",
  },
  {
    id: 1652,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "ABC";\nString s2 = new String("ABC");\nSystem.out.println(s1.compareTo(s2));',
    options: ["0", "Một số nguyên dương", "Một số nguyên âm", "true"],
    answer: 0,
    explanation:
      "compareTo() trả về 0 nếu các chuỗi là bằng nhau về mặt từ điển (nội dung) [62]. Kết quả là 0.",
  },
  {
    id: 1653,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Java";\nString s2 = new String("Java");\nSystem.out.println(s1.intern() == s2.intern());',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "Cả hai đều gọi intern(), đảm bảo chúng trỏ đến cùng một đối tượng duy nhất trong String Pool. `==` so sánh tham chiếu, kết quả là true [72].",
  },
  {
    id: 1654,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu `s1` và `s2` là String literals, so sánh nào sau đây luôn trả về true?",
    code: 'String s1 = "Literal";\nString s2 = "Literal";\n// A: s1 == s2 \n// B: s1.equals(s2)',
    options: ["Chỉ A.", "Chỉ B.", "Cả A và B.", "Không có cái nào."],
    answer: 2,
    explanation:
      "Vì là literals cùng giá trị, chúng trỏ đến cùng một đối tượng (A: true) [68, 77] và có cùng nội dung (B: true) [16, 76].",
  },
  {
    id: 1655,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Hello";\nString s2 = new String(s1);\nSystem.out.println(s1.startsWith("H"));',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "Phương thức boolean startWith(String) kiểm tra xem chuỗi có bắt đầu bằng chuỗi con được chỉ định hay không [62]. 'Hello' bắt đầu bằng 'H', kết quả là true.",
  },
  {
    id: 1656,
    topic: "Data Structures",
    type: "code",
    question: "Điều gì là ĐÚNG về so sánh giữa `s1` và `s2`?",
    code: 'String s1 = new String("Code");\nString s2 = s1;\nSystem.out.println(s1.equals(s2) + " " + (s1 == s2));',
    options: ["true false", "false true", "true true", "false false"],
    answer: 2,
    explanation:
      "s2 = s1 khiến cả hai trỏ đến cùng một đối tượng. Do đó, `equals()` (so sánh nội dung) là true, và `==` (so sánh tham chiếu) là true [37, 76].",
  },
  {
    id: 1657,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Test";\nString s2 = "Test";\nSystem.out.println(s1 == s2.intern());',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào Heap"],
    answer: 0,
    explanation:
      "s1 là literal (trong Pool). s2.intern() trả về tham chiếu từ Pool. Chúng trỏ đến cùng một đối tượng, kết quả là true [68, 72].",
  },
  {
    id: 1658,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu `s` là một StringBuffer, so sánh nào sau đây có thể được sử dụng để kiểm tra nội dung String?",
    code: 'StringBuffer sb = new StringBuffer("data");\nString s = "data";\n// A: sb.equals(s)\n// B: sb.toString().equals(s)\n// C: sb == s',
    options: ["Chỉ A.", "Chỉ B.", "Chỉ C.", "A và B."],
    answer: 1,
    explanation:
      "StringBuffer không ghi đè equals() để so sánh nội dung String. Cần chuyển StringBuffer sang String bằng toString() rồi so sánh nội dung với String khác bằng equals() [57].",
  },
  {
    id: 1659,
    topic: "Data Structures",
    type: "code",
    question: "Trong tình huống nào, `==` so sánh nội dung thay vì tham chiếu?",
    options: [
      "Khi so sánh hai String literals.",
      "Khi so sánh hai String objects.",
      "Khi so sánh hai kiểu dữ liệu nguyên thủy.",
      "Khi so sánh một String với null.",
    ],
    answer: 2,
    explanation:
      "Toán tử `==` áp dụng cho primitive types (e.g., int, char, double, boolean...) để so sánh giá trị (nội dung) [39, 79].",
  },
  {
    id: 1660,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "a" + "b";\nString s2 = "ab";\nSystem.out.println(s1 == s2);',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "Trình biên dịch Java tối ưu hóa việc nối các hằng số String (constant folding). s1 và s2 đều được coi là String literals có giá trị 'ab' và cùng trỏ đến Pool. `==` là true [68].",
  },
  {
    id: 1661,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Data";\nString s2 = "Data";\nSystem.out.println(s1.compareTo(s2));',
    options: ["true", "0", "Một số nguyên dương", "Một số nguyên âm"],
    answer: 1,
    explanation: "compareTo(String) trả về 0 nếu các chuỗi bằng nhau [62].",
  },
  {
    id: 1662,
    topic: "Data Structures",
    type: "code",
    question:
      "Điều gì xảy ra nếu so sánh hai String literals 'A' và 'a' bằng `equals()`?",
    code: 'String s1 = "A";\nString s2 = "a";\nSystem.out.println(s1.equals(s2));',
    options: ["true", "false", "Lỗi biên dịch", "0"],
    answer: 1,
    explanation:
      "equals() phân biệt chữ hoa, chữ thường. Nội dung khác nhau, kết quả là false [16, 76].",
  },
  {
    id: 1663,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Test";\nString s2 = new String("Test");\nSystem.out.println(s1.equalsIgnoreCase(s2));',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "equalsIgnoreCase() so sánh nội dung mà không phân biệt hoa/thường. Nội dung giống nhau, kết quả là true [62, 67].",
  },
  {
    id: 1664,
    topic: "Data Structures",
    type: "code",
    question:
      "Để đảm bảo so sánh `s1 == s2` trả về true, dù `s2` được tạo bằng `new`, bạn phải làm gì?",
    code: 'String s1 = "Code";\nString s2 = new String("Code");\n// Phải thêm lệnh nào ở đây?',
    options: [
      "s1 = s2;",
      "s2 = s2.intern();",
      "s1 = s1.intern();",
      "s2.toUpperCase();",
    ],
    answer: 1,
    explanation:
      "Để `s1 == s2` là true, `s2` phải trỏ đến đối tượng trong Pool mà `s1` đang trỏ tới. `s2 = s2.intern()` làm cho tham chiếu `s2` trỏ đến đối tượng trong Pool [72].",
  },
  {
    id: 1665,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "123";\nString s2 = "123";\nString s3 = "1" + "23";\nSystem.out.println(s1 == s3);',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 0,
    explanation:
      "s3 là sự nối hằng số, được tối ưu hóa thành literal '123' và được đặt trong Pool (hoặc tham chiếu lại). Vì s1 cũng là literal '123' trong Pool, `==` trả về true [68].",
  },
  {
    id: 1666,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu `s1` là literal, `s2` là literal. Điều gì là ĐÚNG về so sánh tham chiếu và nội dung?",
    code: 'String s1 = "Data";\nString s2 = "Data";',
    options: [
      "s1 == s2 là false, s1.equals(s2) là false.",
      "s1 == s2 là true, s1.equals(s2) là true.",
      "s1 == s2 là false, s1.equals(s2) là true.",
      "s1 == s2 là true, s1.equals(s2) là false.",
    ],
    answer: 1,
    explanation:
      "Hai literals cùng giá trị trỏ đến cùng một đối tượng (== true) [68, 77]. Nội dung cũng giống nhau (equals true) [16, 76].",
  },
  {
    id: 1667,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = new String("Test");\nString s2 = new String("Test");\nSystem.out.println(s1.hashCode() == s2.hashCode());',
    options: ["true", "false", "Lỗi biên dịch", "Tùy thuộc vào JVM"],
    answer: 0,
    explanation:
      "Mặc dù String được tạo bằng `new` (hai đối tượng khác nhau), lớp String ghi đè phương thức `hashCode()` để trả về cùng một giá trị nếu nội dung chuỗi bằng nhau. Do đó, nếu `s1.equals(s2)` là true, `hashCode()` phải khớp (Java Object Law for HashCode() and equals()) [80].",
  },
  {
    id: 1668,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "hello";\nString s2 = "HE" + "LLO";\nSystem.out.println(s1 == s2.toLowerCase().intern());',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 1,
    explanation:
      "s1 là 'hello'. s2.toLowerCase() tạo ra 'hello' trên Heap. .intern() trả về tham chiếu đến đối tượng 'hello' trong Pool. Vì s1 cũng trỏ đến 'hello' trong Pool, so sánh tham chiếu sẽ là true. (Chỉnh sửa: s1 đã là literal 'hello' trong Pool. s2.toLowerCase() tạo ra 'hello'.intern(). Vì 'hello' đã có trong Pool, s2.toLowerCase().intern() sẽ trỏ đến cùng đối tượng với s1. Kết quả là true) [66, 68, 72].",
  },
  {
    id: 1669,
    topic: "Data Structures",
    type: "code",
    question:
      "Điều gì là ĐÚNG nếu `s1` được tạo bằng literal và `s2` được tạo bằng `new`?",
    code: 'String s1 = "Final";\nString s2 = new String("Final");',
    options: [
      "s1 == s2 là true.",
      "s1.compareTo(s2) trả về một giá trị khác 0.",
      "s1.equals(s2) là true.",
      "s2 được tự động interned.",
    ],
    answer: 2,
    explanation:
      "s1 và s2 là hai đối tượng khác nhau (== false). equals() so sánh nội dung, kết quả là true [16, 76].",
  },
  {
    id: 1670,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Hello";\nString s2 = new String(s1);\nSystem.out.println(s1.length() == s2.length());',
    options: ["true", "false", "Lỗi biên dịch", "5"],
    answer: 0,
    explanation:
      "length() trả về độ dài chuỗi (5). Cả hai có cùng độ dài. Kết quả là true [16, 62].",
  },
  {
    id: 1671,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Key";\nString s2 = "Key";\nSystem.out.println(s1.indexOf("e"));',
    options: ["0", "1", "2", "-1"],
    answer: 1,
    explanation:
      "indexOf(int ch) tìm kiếm tiến ký tự, 'e' nằm ở index 1 (bắt đầu từ 0) [65].",
  },
  {
    id: 1672,
    topic: "Data Structures",
    type: "code",
    question:
      "Điều gì xảy ra nếu so sánh hai String bằng `==` và kết quả là false, nhưng sau đó gọi `intern()` và so sánh lại bằng `==`?",
    code: 'String s1 = new String("X");\nString s2 = new String("X");\n// s1 == s2 là false\ns1 = s1.intern();\ns2 = s2.intern();\nSystem.out.println(s1 == s2);',
    options: [
      "Luôn là false.",
      "Luôn là true.",
      "Gây ra NullPointerException.",
      "Lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Gọi intern() đảm bảo rằng s1 và s2 đều trỏ đến cùng một đối tượng duy nhất trong Pool, do đó `s1 == s2` sẽ là true [72].",
  },
  {
    id: 1673,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "apple";\nString s2 = "banana";\nSystem.out.println(s1.compareTo(s2) < 0);',
    options: ["true", "false", "Lỗi biên dịch", "Một số nguyên âm"],
    answer: 0,
    explanation:
      "Phương thức compareTo() trả về một số âm nếu đối tượng hiện tại ('apple') được coi là nhỏ hơn (less than) đối tượng được chỉ định ('banana'). 'apple' đứng trước 'banana' theo thứ tự từ điển, nên so sánh là true [62].",
  },
  {
    id: 1674,
    topic: "Data Structures",
    type: "code",
    question:
      "Điều gì xảy ra khi so sánh một String với một tham chiếu null bằng `equals()`?",
    code: 'String s = "Data";\nString n = null;\nSystem.out.println(s.equals(n));',
    options: [
      "Gây ra NullPointerException.",
      "Trả về true.",
      "Trả về false.",
      "Lỗi biên dịch.",
    ],
    answer: 2,
    explanation:
      "Phương thức equals() có thể xử lý tham chiếu null (trả về false). Tuy nhiên, nếu bạn gọi n.equals(s) khi n là null, nó sẽ ném ra NullPointerException [81]. Trong trường hợp này, `s.equals(n)` là false.",
  },
  {
    id: 1675,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Java";\nString s2 = "Java";\nSystem.out.println(s1.charAt(2));',
    options: ["J", "a", "v", "Lỗi runtime"],
    answer: 2,
    explanation:
      "charAt(int index) trả về ký tự tại vị trí index. Index 2 là 'v' ('J' là 0, 'a' là 1, 'v' là 2) [57, 62].",
  },
  {
    id: 1676,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Data";\nString s2 = "data";\nSystem.out.println(s1.equals(s2));',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 1,
    explanation:
      "equals() phân biệt chữ hoa, chữ thường. 'Data' khác 'data', kết quả là false [16, 76].",
  },
  {
    id: 1677,
    topic: "Data Structures",
    type: "code",
    question:
      'Sử dụng String literal và String `s = new String("A").intern();`, so sánh nào sau đây cho kết quả true?',
    code: 'String s1 = "A";\nString s2 = new String("A").intern();',
    options: [
      "s1 == s2",
      "s1.substring(0) == s2.substring(0)",
      "s1.toUpperCase() == s2.toUpperCase()",
      "s1 != s2",
    ],
    answer: 0,
    explanation:
      "s1 là literal (trong Pool). s2.intern() đảm bảo nó trỏ đến cùng đối tượng đó trong Pool. `==` so sánh tham chiếu, kết quả là true [68, 72].",
  },
  {
    id: 1678,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "test";\nString s2 = "TEST";\nSystem.out.println(s1.equalsIgnoreCase(s2));',
    options: ["true", "false", "Lỗi biên dịch", "0"],
    answer: 0,
    explanation:
      "equalsIgnoreCase() so sánh nội dung, không phân biệt hoa/thường. Nội dung giống nhau, kết quả là true [62, 67].",
  },
  {
    id: 1679,
    topic: "Data Structures",
    type: "code",
    question:
      "Nếu `s1` và `s2` là hai đối tượng Heap khác nhau, điều gì là ĐÚNG về so sánh tham chiếu và nội dung?",
    code: 'String s1 = new String("X");\nString s2 = new String("X");',
    options: [
      "s1 == s2 là true, s1.equals(s2) là true.",
      "s1 == s2 là false, s1.equals(s2) là true.",
      "s1 == s2 là true, s1.equals(s2) là false.",
      "s1 == s2 là false, s1.equals(s2) là false.",
    ],
    answer: 1,
    explanation:
      "Hai đối tượng khác nhau (== false) [39]. Cùng nội dung (equals true) [16, 76].",
  },
  {
    id: 1680,
    topic: "Data Structures",
    type: "code",
    question: "Đoạn code sau in ra gì?",
    code: 'String s1 = "Example";\nString s2 = s1.concat("s");\nSystem.out.println(s1 == s2);',
    options: ["true", "false", "Lỗi biên dịch", "null"],
    answer: 1,
    explanation:
      "Phương thức concat() tạo ra một đối tượng String mới ('Examples') vì String là bất biến. s1 vẫn trỏ đến 'Example'. Vì s1 và s2 trỏ đến các đối tượng khác nhau, `==` so sánh tham chiếu, kết quả là false [55, 60].",
  },
  {
    id: 1681,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics (Kiểu chung) được giới thiệu trong phiên bản JDK nào của Java?",
    options: ["JDK 1.4", "JDK 5.0", "JDK 7", "JDK 8"],
    answer: 1,
    explanation: "Generics được giới thiệu trong JDK 5.0 [1].",
  },
  {
    id: 1682,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lợi ích chính của Generics là tăng cường tính toàn vẹn kiểu dữ liệu (Type Safety) bằng cách phát hiện các lỗi kiểu dữ liệu ở thời điểm nào?",
    options: [
      "Runtime (Thời gian chạy)",
      "Compile-time (Thời gian biên dịch)",
      "Deployment time",
      "Initialization time",
    ],
    answer: 1,
    explanation:
      "Generics giúp bạn tạo các collection an toàn kiểu dữ liệu (type-safe collections) nơi nhiều vấn đề được phát hiện ở thời điểm biên dịch thay vì thời gian chạy [2-4].",
  },
  {
    id: 1683,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trước khi có Generics, các Collection như ArrayList được khai báo để chứa kiểu gì, dẫn đến cần ép kiểu thủ công (casting)?",
    options: ["Integer", "String", "Object", "Primitive types"],
    answer: 2,
    explanation:
      "Trước JDK 5.0, tất cả các triển khai collection đều được khai báo để giữ kiểu Object, khiến chúng không an toàn về kiểu dữ liệu và cần ép kiểu thủ công [3, 5, 6].",
  },
  {
    id: 1684,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về Generics?",
    options: [
      "Nó loại bỏ nhu cầu sử dụng Object class.",
      "Nó giúp mã nguồn ngắn gọn hơn nhưng vẫn yêu cầu ép kiểu thủ công.",
      "Nó loại bỏ nhu cầu ép kiểu (casting) và giúp mã nguồn dễ hiểu hơn.",
      "Nó cho phép sử dụng kiểu dữ liệu nguyên thủy làm tham số kiểu.",
    ],
    answer: 2,
    explanation: "Generics loại bỏ nhu cầu ép kiểu (casting) [7, 8].",
  },
  {
    id: 1685,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp khai báo Generics như `ArrayList<String> list = new ArrayList<>();`, ký hiệu kim cương `<>` dùng để làm gì?",
    options: [
      "Chỉ định rằng class là trừu tượng.",
      "Là một toán tử so sánh (Comparison Operator).",
      "Khai báo tham số kiểu (Type Parameter) khi khởi tạo đối tượng.",
      "Khai báo một phương thức tĩnh.",
    ],
    answer: 2,
    explanation:
      "Ký hiệu `<String>` trong ngoặc nhọn là 'type parameter' [9]. Ký hiệu kim cương `<>` được sử dụng để chỉ định kiểu dữ liệu khi khởi tạo Generics [7, 10].",
  },
  {
    id: 1686,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Generics, tham số kiểu (Type Parameter) chấp nhận kiểu dữ liệu nào?",
    options: [
      "Giá trị (Values)",
      "Kiểu (Classes hoặc Interfaces)",
      "Kiểu nguyên thủy (Primitives)",
      "Biến (Variables)",
    ],
    answer: 1,
    explanation:
      "Sự khác biệt chính là tham số phương thức chấp nhận giá trị làm đầu vào, trong khi tham số kiểu chấp nhận kiểu (class, interface...) làm đầu vào [1].",
  },
  {
    id: 1687,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Ký hiệu kim cương `<>` trong Java, được sử dụng khi khởi tạo một Generics object, đã được giới thiệu để làm cho code ngắn gọn hơn ở phiên bản JDK nào?",
    options: ["JDK 1.5", "JDK 6", "JDK 7", "JDK 8"],
    answer: 2,
    explanation:
      "Mặc dù Generics được giới thiệu trong JDK 5.0 [1], ký hiệu kim cương `<>` để rút gọn cú pháp khởi tạo Generics được giới thiệu trong JDK 7 (thông tin này cần được suy luận từ bối cảnh tiến hóa của Java, nhưng tài liệu chỉ đề cập đến cú pháp chung của Generics [10] mà không nêu rõ phiên bản JDK 7 cho ký hiệu kim cương. Tuy nhiên, ví dụ `Pair<String> o=new Pair<>('1st','2nd');` [10] ngụ ý sử dụng cú pháp này. Nếu chỉ dựa vào các nguồn đã cho, chúng ta có thể khẳng định cú pháp này được sử dụng, nhưng không có thông tin rõ ràng về JDK 7).",
  },
  {
    id: 1688,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì xảy ra nếu bạn cố gắng khai báo `ArrayList<int>`?",
    options: [
      "Chương trình chạy bình thường vì có tính năng autoboxing.",
      "Sẽ gây ra lỗi biên dịch vì kiểu nguyên thủy không thể là tham số kiểu Generics.",
      "Sẽ gây ra lỗi runtime.",
      "Nó được tự động chuyển đổi thành `ArrayList<Integer>`.",
    ],
    answer: 1,
    explanation:
      "Sẽ gây ra lỗi biên dịch vì bạn chỉ có thể chỉ định kiểu class hoặc interface, KHÔNG phải kiểu nguyên thủy (primitives) [11].",
  },
  {
    id: 1689,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để sử dụng Generics với các kiểu dữ liệu nguyên thủy (như `int`), người lập trình phải sử dụng loại class nào?",
    options: [
      "Final classes",
      "Abstract classes",
      "Wrapper classes",
      "Utility classes",
    ],
    answer: 2,
    explanation:
      "Vì các kiểu nguyên thủy không thể được sử dụng làm tham số kiểu Generics, bạn phải sử dụng các lớp Wrapper tương ứng (Integer, Boolean, Character, v.v.) [11, 12].",
  },
  {
    id: 1690,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong khai báo `public class Pair<K, V>`, `K` và `V` được gọi là gì?",
    options: [
      "Generic objects",
      "Generic variables",
      "Type parameters",
      "Bounded types",
    ],
    answer: 2,
    explanation:
      "Generics cho phép các class chấp nhận tham số kiểu (type parameters) khi định nghĩa chúng [1].",
  },
  {
    id: 1691,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi tạo một phương thức Generics, danh sách tham số kiểu (`<K, V>`) phải xuất hiện ở đâu trong khai báo phương thức?",
    options: [
      "Sau tên phương thức.",
      "Sau kiểu trả về (return type).",
      "Trước kiểu trả về (return type).",
      "Chỉ được khai báo trong class Generics.",
    ],
    answer: 2,
    explanation:
      "Cú pháp cho một phương thức generic bao gồm một danh sách các tham số kiểu nằm trong ngoặc nhọn `<>`, xuất hiện trước kiểu trả về của phương thức [13-15].",
  },
  {
    id: 1692,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt cơ bản về tính đa hình (polymorphism) giữa mảng thông thường và Collection Generics là gì?",
    options: [
      "Mảng không hỗ trợ đa hình, Collection thì có.",
      "Mảng cho phép gán mảng con (subclass array) cho tham chiếu mảng cha (superclass array), Collection Generics KHÔNG cho phép.",
      "Collection Generics cho phép gán `List<Dog>` cho `List<Animal>`, mảng thì không.",
      "Mảng chỉ chứa kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Mảng có thể chấp nhận tham chiếu đa hình (ví dụ: `Animal[] animals = new Dog[]`), nhưng Collection Generics không có mối quan hệ kế thừa giữa các kiểu Generics khác nhau, do đó `ArrayList<Animal>` không thể chấp nhận `ArrayList<Dog>` [16-18].",
  },
  {
    id: 1693,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử `Animal` là lớp cha của `Cat`. Khai báo nào sau đây sẽ gây ra lỗi biên dịch trong Java Generics?",
    options: [
      "Animal[] animals = new Cat[19];",
      "List<Animal> animals = new ArrayList<Animal>();",
      "List<Cat> cats = new ArrayList<Cat>();",
      "List<Animal> animals = new ArrayList<Cat>();",
    ],
    answer: 3,
    explanation:
      "Trong Generics, không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: `List<Animal>` và `List<Cat>`). Do đó, `List<Animal>` không thể là tham chiếu cho `new ArrayList<Cat>()` [18, 20, 21].",
  },
  {
    id: 1694,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard không giới hạn (Unbounded Wildcard) được ký hiệu như thế nào?",
    options: ["`? extends Object`", "`? super Object`", "`<?>`", "`<T>`"],
    answer: 2,
    explanation:
      "Wildcard không giới hạn được chỉ định bằng ký tự wildcard `?` (ví dụ: `List<?>`) [22, 23].",
  },
  {
    id: 1695,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard không giới hạn (`List<?>`) hữu ích trong trường hợp nào sau đây?",
    options: [
      "Khi cần thêm các phần tử kiểu cụ thể vào list.",
      "Khi viết phương thức sử dụng các chức năng không phụ thuộc vào tham số kiểu (ví dụ: `size()` hoặc `clear()`).",
      "Khi cần giới hạn kiểu chỉ là lớp con của một lớp cụ thể.",
      "Khi cần giới hạn kiểu chỉ là lớp cha của một lớp cụ thể.",
    ],
    answer: 1,
    explanation:
      "Wildcard không giới hạn hữu ích khi mã sử dụng các phương thức trong lớp generic không phụ thuộc vào tham số kiểu (ví dụ: `List.size()` hoặc `List.clear()`) hoặc khi phương thức chỉ sử dụng chức năng của lớp Object [22].",
  },
  {
    id: 1696,
    topic: "Generics & Collections",
    type: "radio",
    question: "Upper-bounded wildcard được khai báo bằng cú pháp nào?",
    options: [
      "`? super Type`",
      "`? extends Type`",
      "`<>`",
      "`? super T & extends B`",
    ],
    answer: 1,
    explanation:
      "Upper-bounded wildcard được khai báo bằng cách sử dụng ký tự wildcard `?` theo sau là từ khóa `extends`, tiếp theo là giới hạn trên (upper bound) [24, 25].",
  },
  {
    id: 1697,
    topic: "Generics & Collections",
    type: "radio",
    question: "Lower-bounded wildcard được khai báo bằng cú pháp nào?",
    options: [
      "`? super Type`",
      "`? extends Type`",
      "`<T extends Type>`",
      "`?`",
    ],
    answer: 0,
    explanation:
      "Lower-bounded wildcard được thể hiện bằng cách sử dụng ký tự wildcard `?` theo sau là từ khóa `super`, sau đó là giới hạn dưới (lower bound) [26].",
  },
  {
    id: 1698,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một phương thức làm việc trên `List<Integer>`, `List<Double>`, và `List<Number>`, bạn nên sử dụng kiểu tham số hóa nào?",
    options: [
      "`List<Object>`",
      "`List<? extends Number>`",
      "`List<? super Integer>`",
      "`List<?>`",
    ],
    answer: 1,
    explanation:
      "Upper-bounded wildcard cho phép nới lỏng các ràng buộc đối với một biến. Ví dụ: `List<? extends Number>` sẽ chấp nhận các kiểu là `Number` hoặc bất kỳ lớp con nào của `Number` (như `Integer`, `Double`) [24].",
  },
  {
    id: 1699,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, từ khóa `extends` trong khai báo Bounded Type (ví dụ: `<T extends BoundingType>`) có ý nghĩa gì?",
    options: [
      "Chỉ giới hạn cho các Class.",
      "Chỉ giới hạn cho các Interface.",
      "Có nghĩa là 'extends' (kế thừa class) HOẶC 'implements' (triển khai interface).",
      "Chỉ áp dụng cho kiểu dữ liệu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Trong Generics, từ khóa `extends` thực sự có nghĩa là 'is-a', và hoạt động cho cả Class và Interface (tức là 'extends or implements') [27, 28].",
  },
  {
    id: 1700,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Multiple Bounding Types (Giới hạn đa kiểu), điều gì là bắt buộc?",
    options: [
      "Chỉ có thể bao gồm nhiều Interface.",
      "Phải bao gồm chính xác một Class, và Class đó phải được đặt trước bất kỳ Interface nào.",
      "Phải sử dụng từ khóa `super` thay vì `extends`.",
      "Không có giới hạn nào về số lượng Class hay Interface.",
    ],
    answer: 1,
    explanation:
      "Chỉ một class có thể được bao gồm trong nhiều giới hạn, và T phải là kiểu con của BoundingType [29, 30]. Mặc dù không nói rõ 'đặt trước', theo quy ước chung (và ví dụ), class thường được đặt trước các interface trong danh sách giới hạn [30].",
  },
  {
    id: 1701,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của việc sử dụng Bounded Type Parameters (Tham số kiểu bị giới hạn) là gì?",
    options: [
      "Cho phép Generics hoạt động với kiểu nguyên thủy.",
      "Giới hạn kiểu dữ liệu Generics để nó có thể truy cập các phương thức cụ thể (ví dụ: `compareTo()`).",
      "Bắt buộc phải sử dụng Wildcard không giới hạn.",
      "Ngăn chặn việc sử dụng toán tử kim cương `<>`.",
    ],
    answer: 1,
    explanation:
      "Bounded Types được sử dụng để giới hạn kiểu dữ liệu T, ví dụ: `<T extends Comparable<T>>` được sử dụng để đảm bảo kiểu T có thể so sánh được (sử dụng `compareTo()`) [29, 31].",
  },
  {
    id: 1702,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử bạn có một lớp `Pair<K, V>`. Khai báo nào sau đây là KHÔNG có mối quan hệ kế thừa trong Generics?",
    options: [
      "Class Dog extends Animal.",
      "Pair<String, Integer>",
      "List<? extends Number>",
      "Pair<Integer, String> và Pair<Double, String>",
    ],
    answer: 3,
    explanation:
      "Không có mối quan hệ kế thừa nào giữa các kiểu generic khác nhau (ví dụ: `Pair<Animal>` và `Pair<Cat>`) [20]. Do đó, `Pair<Integer, String>` và `Pair<Double, String>` không có mối quan hệ kế thừa trực tiếp trong Generics.",
  },
  {
    id: 1703,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mối quan hệ giữa `ArrayList<Animal>` và `ArrayList<Dog>` (khi Dog là lớp con của Animal) trong Generics là gì?",
    options: [
      "Có mối quan hệ kế thừa thông thường.",
      "Có mối quan hệ kế thừa ngược lại (Downcasting).",
      "Không có mối quan hệ kế thừa nào.",
      "Chúng có thể được gán cho nhau mà không cần Wildcard.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa nào giữa các kiểu generic khác nhau [18, 20].",
  },
  {
    id: 1704,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo là `public static <T extends Comparable<T>> T min(T[] a)`, mục đích của giới hạn `<T extends Comparable<T>>` là gì?",
    options: [
      "Chỉ cho phép kiểu `T` là các Wrapper Class.",
      "Đảm bảo rằng các phần tử trong mảng `a` có thể sử dụng phương thức `compareTo()` để so sánh.",
      "Bắt buộc `T` phải là một interface.",
      "Ngăn chặn việc so sánh các đối tượng.",
    ],
    answer: 1,
    explanation:
      "Giới hạn này đảm bảo rằng kiểu `T` phải triển khai interface `Comparable<T>`, cho phép so sánh các phần tử (ví dụ: `smallest.compareTo(a[i]) > 0`) [29, 31].",
  },
  {
    id: 1705,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi nào thì nên sử dụng Wildcard không giới hạn (`List<?>`)?",
    options: [
      "Khi phương thức cần chèn (insert) các phần tử mới.",
      "Khi bạn chỉ muốn đọc các phần tử và không quan tâm đến kiểu cụ thể của chúng (sử dụng các phương thức của `Object`).",
      "Khi bạn cần truy cập các phương thức cụ thể của lớp con.",
      "Khi giới hạn kiểu ở thời điểm biên dịch.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcards hữu ích khi bạn đang viết một phương thức có thể được triển khai bằng cách sử dụng chức năng do lớp Object cung cấp (ví dụ: in ấn) hoặc khi không phụ thuộc vào tham số kiểu [22].",
  },
  {
    id: 1706,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong bối cảnh Bounded Types, nếu một kiểu `T` bị giới hạn bởi cả class và interface (ví dụ: `<T extends Number & Comparable<T>>`), điều gì là đúng?",
    options: [
      "Cú pháp này không hợp lệ.",
      "T phải là lớp con của Number VÀ triển khai Comparable.",
      "T phải là lớp con của Number HOẶC triển khai Comparable.",
      "Chỉ có thể sử dụng một giới hạn duy nhất (Class hoặc Interface).",
    ],
    answer: 1,
    explanation:
      "Cú pháp này cho phép nhiều giới hạn (`<T extends superClassName & Interface>`). T phải là kiểu con của Class và triển khai tất cả các Interface được liệt kê [29, 30].",
  },
  {
    id: 1707,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của Lower-bounded wildcard `? super Integer` là gì?",
    options: [
      "Chỉ cho phép list chứa các phần tử thuộc kiểu Integer.",
      "Cho phép list chứa Integer và các lớp con của Integer.",
      "Cho phép list chứa Integer và các lớp cha của Integer (ví dụ: Number, Object).",
      "Giới hạn kiểu chỉ có thể là interface.",
    ],
    answer: 2,
    explanation:
      "Lower-bounded wildcard giới hạn kiểu không xác định là kiểu cha (supertype) của một kiểu cụ thể. `List<? super Integer>` làm việc với `List<Integer>`, `List<Number>`, và `List<Object>` [26].",
  },
  {
    id: 1708,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử bạn có `List<String> list = new ArrayList<>();`. Kiểu dữ liệu nào được trả về khi bạn gọi `list.get(0)`?",
    options: ["Object", "String", "T (Tham số kiểu)", "V (Tham số kiểu)"],
    answer: 1,
    explanation:
      "Với Generics, các đối tượng đi ra khỏi List với kiểu cụ thể của chúng (ví dụ: `String s = list.get(0)`) mà không cần ép kiểu [7, 32].",
  },
  {
    id: 1709,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi khai báo một phương thức Generic với tham số kiểu T, điều gì được coi là quy ước đặt tên (convention) cho tham số kiểu tổng quát?",
    options: ["E", "K", "V", "T"],
    answer: 3,
    explanation:
      "Quy ước là sử dụng một chữ cái duy nhất. T thường được sử dụng cho kiểu tổng quát (general type) [33]. (E là cho Element, K là cho Key, V là cho Value).",
  },
  {
    id: 1710,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một lớp không Generics và muốn một phương thức của lớp đó là Generic, bạn phải khai báo tham số kiểu ở đâu?",
    options: [
      "Trong định nghĩa class.",
      "Sau tên phương thức, trước kiểu trả về.",
      "Ngay sau từ khóa `public` hoặc `static` và trước kiểu trả về.",
      "Không thể có phương thức Generic trong lớp không Generics.",
    ],
    answer: 2,
    explanation:
      "Đối với phương thức Generic, danh sách tham số kiểu nằm trong ngoặc nhọn `<>` xuất hiện trước kiểu trả về của phương thức [13, 15].",
  },
  {
    id: 1711,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn không sử dụng Generics khi khai báo một Collection (ví dụ: `List list = new ArrayList()`) và cố gắng lấy một phần tử?",
    options: [
      "Phần tử đó luôn là kiểu String.",
      "Phần tử đó được trả về dưới dạng kiểu Object và cần ép kiểu thủ công.",
      "Sẽ gây ra lỗi biên dịch.",
      "Phần tử được tự động chuyển thành kiểu của biến nhận.",
    ],
    answer: 1,
    explanation:
      "Code without generics: `List list = new ArrayList(); ... String s= (String) list.get(0);` [7]. Đối tượng được lấy ra dưới dạng `Object` và cần ép kiểu [5, 34].",
  },
  {
    id: 1712,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics giải quyết vấn đề gì khi làm việc với Collections mà chỉ chấp nhận `Object`?",
    options: [
      "Deadlock",
      "Sự thiếu hụt bộ nhớ Heap",
      "Thiếu cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch (No mechanism for checking errors)",
      "Thiếu các phương thức `size()` và `clear()`",
    ],
    answer: 2,
    explanation:
      "Hạn chế của việc sử dụng Object là cần ép kiểu liên tục và không có cơ chế kiểm tra lỗi [35]. Generics giải quyết vấn đề này bằng cách cung cấp Type Safety [2].",
  },
  {
    id: 1713,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard `List<?>`, bạn có được phép chèn (add) một phần tử mới vào danh sách (ngoại trừ giá trị `null`) không?",
    options: [
      "Có, nếu phần tử đó là Object.",
      "Không, vì trình biên dịch không thể đảm bảo kiểu dữ liệu an toàn.",
      "Chỉ nếu phần tử đó là String.",
      "Có, nếu list rỗng.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcard (`?`) chỉ cho phép đọc, không cho phép viết (chèn) vì trình biên dịch không thể biết kiểu của `?` (thông tin này cần được suy luận từ cơ chế hoạt động, nhưng sources chỉ tập trung vào việc đọc/in ấn [22, 36]). *Tái kiểm tra các nguồn: Các nguồn nhấn mạnh rằng `List<?>` chủ yếu dùng cho các hoạt động độc lập với kiểu, như `size()` và `clear()` [22]. Việc chèn bị cấm vì lý do Type Safety.*",
  },
  {
    id: 1714,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Bounded Type `<T extends BoundingType>`, nếu `BoundingType` là một Interface (ví dụ: `Serializable`), thì `T` phải làm gì?",
    options: [
      "Kế thừa (extends) Interface đó.",
      "Triển khai (implements) Interface đó.",
      "Chỉ là kiểu nguyên thủy.",
      "Là kiểu `Object`.",
    ],
    answer: 1,
    explanation:
      "Trong Generics, từ khóa `extends` có nghĩa là 'extends or implements'. Nếu `BoundingType` là một Interface, `T` phải triển khai nó (implements) [28].",
  },
  {
    id: 1715,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử bạn cần một phương thức để thêm các đối tượng `Integer` vào một danh sách, và phương thức này cần hoạt động với `List<Integer>`, `List<Number>`, và `List<Object>`. Bạn nên sử dụng Wildcard nào?",
    options: [
      "`List<? extends Number>`",
      "`List<?>`",
      "`List<? super Integer>`",
      "`List<Integer>`",
    ],
    answer: 2,
    explanation:
      "Lower-bounded wildcard (`? super Integer`) được sử dụng cho các hoạt động ghi/chèn (insert), cho phép danh sách chấp nhận `Integer` và bất kỳ kiểu cha nào của `Integer` (Number, Object) [26].",
  },
  {
    id: 1716,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một phương thức chấp nhận tham số là `List<? extends Animal> a`, điều gì là ĐÚNG?",
    options: [
      "Phương thức này có thể thêm đối tượng `Animal` mới vào list `a`.",
      "Phương thức này chỉ được phép đọc (read) các phần tử từ list `a` dưới dạng `Animal`.",
      "Phương thức này chỉ chấp nhận `List<Animal>` (không chấp nhận `List<Cat>`).",
      "Wildcard này là Lower Bounded.",
    ],
    answer: 1,
    explanation:
      "Upper-bounded wildcard (`? extends Type`) thường được sử dụng cho các hoạt động đọc/truy xuất (read), vì không thể đảm bảo kiểu cụ thể của phần tử, ngăn cản việc chèn [24]. Ví dụ cho thấy khi duyệt qua `ArrayList<? extends Animal>`, các phần tử được đọc ra dưới dạng `Animal` [37].",
  },
  {
    id: 1717,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong thiết kế class `Pair<K, V>`, nếu bạn muốn sử dụng Generic methods để so sánh hai đối tượng `Pair`, cú pháp khai báo phương thức trong class `Util` sẽ như thế nào?",
    options: [
      "`public static boolean compare(Pair<K, V> p1, Pair<K, V> p2)`",
      "`public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2)`",
      "`public boolean compare(Pair p1, Pair p2)`",
      "`public static boolean compare<K, V>(...)`",
    ],
    answer: 1,
    explanation:
      "Ví dụ về phương thức Generic: `public static <K,V> boolean compare(Pair<K,V> p1, Pair<K,V> p2)` [14].",
  },
  {
    id: 1718,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong ví dụ `ArrayList<String> a = new ArrayList<>();`, mục đích của việc chỉ định `<String>` là gì?",
    options: [
      "Để list chỉ có thể chứa các đối tượng `Object`.",
      "Để chỉ định kiểu dữ liệu của các phần tử được phép thêm vào ArrayList.",
      "Để bắt buộc sử dụng Wrapper Class.",
      "Để kích hoạt Downcasting.",
    ],
    answer: 1,
    explanation:
      "ArrayList sử dụng Generics để cho phép bạn chỉ định kiểu dữ liệu của các phần tử mà bạn dự định thêm vào ArrayList [7].",
  },
  {
    id: 1719,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về Generics Methods?",
    options: [
      "Phạm vi (scope) của tham số kiểu bị giới hạn trong class.",
      "Phạm vi của tham số kiểu bị giới hạn trong phương thức mà nó được khai báo.",
      "Nó không thể có tham số kiểu riêng.",
      "Nó không cần khai báo tham số kiểu trước kiểu trả về.",
    ],
    answer: 1,
    explanation:
      "Generics methods giới thiệu tham số kiểu riêng của chúng, tương tự như kiểu generic, nhưng phạm vi của tham số kiểu bị giới hạn trong phương thức mà nó được khai báo [13].",
  },
  {
    id: 1720,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi gọi một phương thức Generic như `Util.compare(p1, p2)`, điều gì xảy ra nếu bạn bỏ qua việc chỉ định rõ ràng các tham số kiểu (ví dụ: `Util.<Integer, String>compare(p1, p2)`)?",
    options: [
      "Luôn gây ra lỗi biên dịch.",
      "Trình biên dịch sẽ tự động suy luận kiểu cần thiết.",
      "Phương thức sẽ luôn sử dụng kiểu Object.",
      "Chỉ sử dụng được nếu phương thức là private.",
    ],
    answer: 1,
    explanation:
      "Các tham số kiểu có thể được bỏ qua, trình biên dịch sẽ suy luận kiểu cần thiết [14].",
  },
  {
    id: 1721,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lý do tại sao `ArrayList<Animal>` không thể chấp nhận `ArrayList<Dog>` (khi không sử dụng Wildcard) là vì nếu nó được phép, bạn có thể thêm đối tượng thuộc kiểu nào vào `ArrayList<Dog>`?",
    options: [
      "Chỉ đối tượng Dog.",
      "Bất kỳ đối tượng nào khác (ví dụ: Cat), dẫn đến vi phạm Type Safety.",
      "Chỉ đối tượng Animal.",
      "Chỉ đối tượng Object.",
    ],
    answer: 1,
    explanation:
      "Nếu việc gán `ArrayList<Dog>` cho `ArrayList<Animal>` được phép, người ta có thể thêm một đối tượng `Cat` vào list (vì `Cat` là `Animal`), nhưng list này ban đầu chỉ được thiết kế để chứa `Dog`, dẫn đến lỗi kiểu dữ liệu tiềm tàng (Type Safety breach) [38]. (Đây là lý do sâu xa của việc không có quan hệ kế thừa giữa các Generics types [20]).",
  },
  {
    id: 1722,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Bounded Type, nếu bạn muốn giới hạn kiểu `T` phải là một lớp con của `Number` và triển khai `Comparable<T>`, cú pháp nào là đúng?",
    options: [
      "`<T extends Number implements Comparable<T>>`",
      "`<T extends Number & Comparable<T>>`",
      "`<T super Number & Comparable<T>>`",
      "`<T extends Comparable<T> | Number>`",
    ],
    answer: 1,
    explanation:
      "Cú pháp cho nhiều giới hạn là sử dụng `&` [29]. Ví dụ: `public static <T extends Number & Comparable<T> & Serializable>` [30].",
  },
  {
    id: 1723,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một phương thức Generic để tìm phần tử nhỏ nhất trong mảng kiểu `T`, và bạn cần so sánh chúng (ví dụ: `smallest > a[i]`), bạn phải làm gì?",
    options: [
      "Không thể thực hiện được trong Generics.",
      "Sử dụng Upper-bounded type với `Comparable<T>`.",
      "Sử dụng Unbounded wildcard.",
      "Chỉ cần sử dụng kiểu `Object`.",
    ],
    answer: 1,
    explanation:
      "Toán tử `>` không áp dụng cho các đối tượng. Để so sánh, cần ràng buộc kiểu `T` phải triển khai `Comparable` (`<T extends Comparable<T>>`), sau đó sử dụng `compareTo()` [29, 31].",
  },
  {
    id: 1724,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard `List<?>`, bạn có thể gọi phương thức nào trên các phần tử lấy ra từ list?",
    options: [
      "Bất kỳ phương thức nào của kiểu `T` (tham số gốc).",
      "Chỉ các phương thức được định nghĩa trong `Object` class.",
      "Chỉ các phương thức `static`.",
      "Chỉ phương thức `add()`.",
    ],
    answer: 1,
    explanation:
      "Khi sử dụng tham chiếu kiểu `Object` hoặc `List<?>`, bạn chỉ có thể gọi các phương thức được định nghĩa trong class `Object` (vì trình biên dịch không thể đảm bảo kiểu cụ thể của đối tượng) [22, 39].",
  },
  {
    id: 1725,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để viết một phương thức có thể chấp nhận `List<Dog>`, `List<Animal>`, hoặc `List<Object>` cho mục đích chèn (insertion), bạn nên sử dụng giới hạn nào nếu `Dog` là giới hạn dưới?",
    options: [
      "`List<? super Dog>`",
      "`List<? extends Animal>`",
      "`List<Dog>`",
      "`List<? extends Object>`",
    ],
    answer: 0,
    explanation:
      "Khi muốn chèn, ta sử dụng Lower-bounded wildcard. `? super Dog` sẽ chấp nhận các list có kiểu là `Dog` hoặc bất kỳ kiểu cha nào của nó (Animal, Object) [26].",
  },
  {
    id: 1726,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một mảng bình thường (`Animal[]`) chấp nhận gán một mảng lớp con (`Dog[]`), điều này có thể dẫn đến lỗi gì ở thời điểm runtime nếu cố gắng chèn một kiểu không tương thích?",
    options: [
      "StackOverflowError",
      "ArrayStoreException",
      "NumberFormatException",
      "NullPointerException",
    ],
    answer: 1,
    explanation:
      "Sự khác biệt giữa mảng và Generics: mảng sẽ biên dịch nhưng ném ra `ArrayStoreException` nếu bạn cố gắng chèn kiểu không tương thích (ví dụ: cố gắng thêm `Cat` vào `Dog[]` đang được tham chiếu bởi `Animal[]`) [38].",
  },
  {
    id: 1727,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `List<? extends Number>` là để làm việc với các Collection có kiểu phần tử là `Number` VÀ kiểu phần tử là gì?",
    options: [
      "Các lớp cha của Number.",
      "Các lớp con của Number.",
      "Bất kỳ kiểu nào, bao gồm cả String.",
      "Chỉ kiểu Object.",
    ],
    answer: 1,
    explanation:
      "Upper bounded wildcard `? extends Number` làm việc trên `Number` và các lớp con của `Number` (ví dụ: `Integer`, `Double`) [24].",
  },
  {
    id: 1728,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong Java, `List` là gì trong Collection Framework?",
    options: [
      "Một class concrete.",
      "Một interface (Giao diện).",
      "Một primitive type.",
      "Một Wrapper class.",
    ],
    answer: 1,
    explanation:
      "Collection framework cung cấp nhiều interface như `List`, `Queue` [40]. `List` trong Java là một interface [41].",
  },
  {
    id: 1729,
    topic: "Generics & Collections",
    type: "radio",
    question: "Giao diện `Iterator` trong Java sử dụng Generics để làm gì?",
    options: [
      "Để giới hạn số lượng phần tử.",
      "Để chỉ định kiểu của phần tử được trả về bởi phương thức `next()`.",
      "Để ép kiểu các đối tượng thành kiểu nguyên thủy.",
      "Để loại bỏ nhu cầu sử dụng vòng lặp `while`.",
    ],
    answer: 1,
    explanation:
      "Giao diện `Iterator<E>` có phương thức `E next()` [42]. Generics (E) chỉ định kiểu của phần tử khi duyệt qua Collection [43].",
  },
  {
    id: 1730,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong trường hợp nào, `Class<?>` thường được sử dụng?",
    options: [
      "Khi cần lưu trữ kiểu nguyên thủy.",
      "Khi cần đảm bảo tính đa hình cho `List<T>`.",
      "Khi các phương thức trong `Class<?>` không phụ thuộc vào tham số kiểu `T`.",
      "Khi cần giới hạn kiểu bằng `super`.",
    ],
    answer: 2,
    explanation:
      "`Class<?>` thường được sử dụng vì hầu hết các phương thức trong `Class<?>` không phụ thuộc vào tham số kiểu `T` [22].",
  },
  {
    id: 1731,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng sử dụng toán tử so sánh `>` để so sánh trực tiếp hai đối tượng Generic kiểu `T` (không có giới hạn)?",
    options: [
      "Lỗi biên dịch (Compile error).",
      "Kết quả là `true` nếu chúng là cùng một thể hiện.",
      "Kết quả là `false` nếu chúng có giá trị khác nhau.",
      "Sử dụng được nếu `T` là Wrapper Class.",
    ],
    answer: 0,
    explanation:
      "Toán tử `>` chỉ áp dụng cho các kiểu nguyên thủy, không thể sử dụng để so sánh các đối tượng. Điều này dẫn đến lỗi biên dịch, đòi hỏi phải sử dụng Bounded Type với `Comparable` [31].",
  },
  {
    id: 1732,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Multiple Bounding Types, vị trí của Class (nếu có) phải như thế nào so với các Interface?",
    options: [
      "Class phải luôn đứng cuối.",
      "Class phải luôn đứng đầu.",
      "Thứ tự không quan trọng.",
      "Không được phép kết hợp Class và Interface.",
    ],
    answer: 1,
    explanation:
      "Mặc dù tài liệu không rõ ràng về luật chính thức, ví dụ: `<T extends Number & Comparable<T> & Serializable>` [30] cho thấy Class (`Number`) đứng đầu.",
  },
  {
    id: 1733,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard được sử dụng để nới lỏng các hạn chế về kiểu khi bạn muốn làm gì với Collection?",
    options: [
      "Chèn dữ liệu (Write operations).",
      "Truy xuất dữ liệu (Read operations).",
      "Xóa dữ liệu (Delete operations).",
      "Tạo bản sao mới.",
    ],
    answer: 1,
    explanation:
      "Upper-bounded wildcard được sử dụng để nới lỏng các ràng buộc trên một biến [24], chủ yếu cho các hoạt động đọc (read) [44].",
  },
  {
    id: 1734,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của Generics là gì trong việc tái sử dụng code?",
    options: [
      "Giới hạn code chỉ cho một kiểu dữ liệu duy nhất.",
      "Cho phép tái sử dụng cùng một đoạn code với các kiểu dữ liệu đầu vào khác nhau.",
      "Buộc các lớp phải kế thừa từ Object.",
      "Định nghĩa các hằng số toán học.",
    ],
    answer: 1,
    explanation:
      "Định nghĩa tham số kiểu cho phép bạn tái sử dụng cùng một đoạn code với các kiểu đầu vào khác nhau [1]. Cơ bản là: làm thế nào cùng một đoạn code có thể được tái sử dụng cho các kiểu dữ liệu khác nhau [45].",
  },
  {
    id: 1735,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard `List<?>` trong một phương thức, kiểu dữ liệu trả về của phương thức `next()` trong `Iterator` là gì?",
    options: ["Object", "Wildcard (?)", "T (Tham số kiểu)", "String"],
    answer: 0,
    explanation:
      "Khi `List<?>` được sử dụng, `Iterator<?>` được tạo ra, và `it.next()` sẽ trả về `Object` [36]. (Nếu không có Generics, tất cả đều là Object [5]).",
  },
  {
    id: 1736,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics trong Java giúp loại bỏ rủi ro nào thường gặp khi sử dụng Collections dựa trên kiểu `Object`?",
    options: [
      "Lỗi cú pháp (Syntax errors).",
      "Lỗi logic (Logic errors).",
      "Lỗi ép kiểu ClassCastException ở thời điểm chạy (Runtime errors).",
      "Lỗi cấp phát bộ nhớ (Memory allocation errors).",
    ],
    answer: 2,
    explanation:
      "Sử dụng Collections không có Generics dẫn đến lỗi runtime (ví dụ: ClassCastException) [35]. Generics giúp loại bỏ những lỗi kiểu này ở thời điểm biên dịch.",
  },
  {
    id: 1737,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một lớp Generic tùy chỉnh (ví dụ: Pair), bạn định nghĩa tham số kiểu (ví dụ: K) ở đâu?",
    options: [
      "Trong constructor.",
      "Ngay sau tên class.",
      "Trong phương thức main().",
      "Trong tệp riêng biệt.",
    ],
    answer: 1,
    explanation:
      "Bạn có thể định nghĩa kiểu generic riêng bằng cách khai báo tham số generic khi định nghĩa class, ví dụ: `public class Pair<K>` [10, 46].",
  },
  {
    id: 1738,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Types, biểu thức `<T extends BoundingType>` yêu cầu T phải thỏa mãn điều kiện nào?",
    options: [
      "T phải là lớp cha (supertype) của BoundingType.",
      "T phải là lớp con (subtype) của BoundingType.",
      "T phải là interface.",
      "BoundingType phải là kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation: "T phải là kiểu con (subtype) của BoundingType [29].",
  },
  {
    id: 1739,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, từ khóa `super` được sử dụng để định nghĩa loại Wildcard nào?",
    options: [
      "Unbounded wildcard.",
      "Upper-bounded wildcard.",
      "Lower-bounded wildcard.",
      "Type parameter.",
    ],
    answer: 2,
    explanation:
      "Lower-bounded wildcard được biểu thị bằng ký tự `?` theo sau là từ khóa `super` và giới hạn dưới [26].",
  },
  {
    id: 1740,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của việc sử dụng Lower Bounded Wildcard là để tối đa hóa sự linh hoạt trong hoạt động nào với Collection?",
    options: [
      "Đọc dữ liệu (Read operations).",
      "Lọc dữ liệu.",
      "Chèn/Ghi dữ liệu (Insert/Write operations).",
      "Chỉ sử dụng `size()` và `clear()`.",
    ],
    answer: 2,
    explanation:
      "Lower bounded wildcards được sử dụng khi bạn muốn chèn các đối tượng vào list (`List<? super Integer>`) [26].",
  },
  {
    id: 1741,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về Generics Type Parameters so với Method Parameters?",
    options: [
      "Tham số phương thức chấp nhận kiểu dữ liệu (types), còn Tham số kiểu chấp nhận giá trị (values).",
      "Tham số kiểu chấp nhận kiểu dữ liệu (types), còn Tham số phương thức chấp nhận giá trị (values).",
      "Cả hai đều chấp nhận giá trị.",
      "Cả hai đều chỉ chấp nhận kiểu Object.",
    ],
    answer: 1,
    explanation:
      "Tham số phương thức chấp nhận giá trị làm đầu vào, trong khi tham số kiểu chấp nhận kiểu (classes, interface...) làm đầu vào [1].",
  },
  {
    id: 1742,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một phương thức chấp nhận tham số `List<? super Dog>`, list nào sau đây là KHÔNG hợp lệ để truyền vào phương thức đó?",
    options: [
      "List<Dog>",
      "List<Animal>",
      "List<Object>",
      "List<Cat> (Cat là lớp con của Dog)",
    ],
    answer: 3,
    explanation:
      "Lower-bounded wildcard `? super Dog` chỉ chấp nhận `Dog` và các lớp cha của `Dog`. `Cat` là lớp con của `Dog`, không phải là lớp cha hoặc chính `Dog`.",
  },
  {
    id: 1743,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong khai báo `Pair<K, V>`, quy ước đặt tên cho tham số kiểu đại diện cho khóa (Key) là gì?",
    options: ["E", "T", "K", "N"],
    answer: 2,
    explanation:
      "K (cho Key) và V (cho Value) là các quy ước thường thấy trong các Generics class như `Pair` hoặc `Map` [10, 13].",
  },
  {
    id: 1744,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi nào thì nên sử dụng cú pháp phương thức Generic (khai báo `<T>` trước kiểu trả về), thay vì sử dụng Wildcard (ví dụ: `? extends Animal`)?",
    options: [
      "Khi bạn chỉ cần đọc dữ liệu.",
      "Khi bạn cần giới hạn kiểu bằng `super`.",
      "Khi bạn cần sử dụng cùng một tham số kiểu (`T`) cho nhiều tham số (arguments) của phương thức.",
      "Khi bạn muốn phương thức chỉ hoạt động với `Object`.",
    ],
    answer: 2,
    explanation:
      "Nếu bạn muốn phương thức có hai arguments mà cả hai đều là list của một kiểu mở rộng `Animal`, việc khai báo tham số kiểu một lần (`<T extends Animal>`) sẽ hiệu quả hơn việc sử dụng Wildcard cho từng tham số [47, 48].",
  },
  {
    id: 1745,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi bạn khai báo `List<? extends Number> list`, bạn có thể thêm đối tượng `Long` vào list đó không?",
    options: [
      "Có, vì Long là lớp con của Number.",
      "Không, vì Upper Bounded Wildcard ngăn chặn việc chèn các phần tử mới.",
      "Chỉ nếu bạn ép kiểu nó thành Number.",
      "Chỉ nếu list là ArrayList.",
    ],
    answer: 1,
    explanation:
      "Upper Bounded Wildcards (`? extends Type`) thường ngăn chặn việc chèn các phần tử mới (write operations) để duy trì Type Safety [24, 44].",
  },
  {
    id: 1746,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào sau đây được sử dụng để giới hạn kiểu không xác định là kiểu cha (supertype) của một kiểu cụ thể?",
    options: [
      "Upper-bounded wildcard.",
      "Lower-bounded wildcard.",
      "Unbounded wildcard.",
      "Double-bounded wildcard.",
    ],
    answer: 1,
    explanation:
      "Lower-bounded wildcard giới hạn kiểu không xác định là kiểu cha (supertype) của một kiểu cụ thể [26].",
  },
  {
    id: 1747,
    topic: "Generics & Collections",
    type: "radio",
    question: "Lớp `ArrayList` trong Java sử dụng Generics để làm gì?",
    options: [
      "Để giới hạn kích thước của mảng nội bộ.",
      "Để cho phép chỉ định kiểu dữ liệu của các phần tử được thêm vào ArrayList.",
      "Để thực hiện tự động hóa việc boxing/unboxing.",
      "Để áp dụng giới hạn đa kiểu (Multiple Bounds).",
    ],
    answer: 1,
    explanation:
      "ArrayList sử dụng Generics để cho phép bạn chỉ định kiểu dữ liệu của các phần tử mà bạn dự định thêm vào ArrayList [7].",
  },
  {
    id: 1748,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu bạn có `List<T>`, tại sao bạn không cần ép kiểu khi gọi `T t = list.get(0);`?",
    options: [
      "Vì `T` luôn là kiểu `Object`.",
      "Vì Generics đảm bảo tính Type Safety và loại bỏ nhu cầu ép kiểu.",
      "Vì phương thức `get()` trả về kiểu `Object` một cách ngầm định.",
      "Vì `List` là một interface.",
    ],
    answer: 1,
    explanation: "Generics loại bỏ nhu cầu ép kiểu (No need for casting) [7].",
  },
  {
    id: 1749,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn tạo một Collection có thể chứa các đối tượng thuộc mọi kiểu, bạn có thể khai báo nó như thế nào mà không cần sử dụng Wildcard?",
    options: ["`List<T>`", "`List<Object>`", "`List<String>`", "`List<E>`"],
    answer: 1,
    explanation:
      "Vì mọi class trong Java đều kế thừa từ `Object`, `List<Object>` có thể chứa bất kỳ đối tượng nào [6, 49].",
  },
  {
    id: 1750,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Tham số kiểu Generics `E` thường được sử dụng trong Collections để đại diện cho điều gì?",
    options: [
      "Key (Khóa).",
      "Value (Giá trị).",
      "Element (Phần tử) mà Collection sẽ giữ.",
      "Type (Kiểu tổng quát).",
    ],
    answer: 2,
    explanation:
      "Quy ước là sử dụng 'E' để đại diện cho 'type of the Element the collection will hold' [33].",
  },
  {
    id: 1751,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử `ArrayList<Dog>` được khởi tạo. Nếu bạn gọi `get(0)`, kiểu tham chiếu nào được trả về?",
    options: ["Object", "Dog", "Animal", "E"],
    answer: 1,
    explanation:
      "Khi sử dụng Generics, đối tượng đi ra khỏi `ArrayList<Dog>` dưới dạng tham chiếu `Dog`, không cần ép kiểu [32, 50].",
  },
  {
    id: 1752,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một hàm để in tất cả các phần tử của một `List` bất kỳ kiểu nào, bạn nên sử dụng Wildcard nào?",
    options: [
      "`List<T>`",
      "`List<? extends Object>`",
      "`List<?>`",
      "`List<? super Object>`",
    ],
    answer: 2,
    explanation:
      "Unbounded wildcard `List<?>` được sử dụng cho các phương thức không phụ thuộc vào kiểu cụ thể của phần tử, ví dụ như in ra (chỉ sử dụng phương thức `toString()` của Object) [22, 36].",
  },
  {
    id: 1753,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, tại sao `List<Integer>` không thể gán cho `List<Number>` (khi Integer là lớp con của Number)?",
    options: [
      "Vì `List` là một Interface.",
      "Vì thiếu `Comparable`.",
      "Vì không có mối quan hệ kế thừa giữa các kiểu Generics khác nhau.",
      "Vì Integer không phải là `final`.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: `List<Integer>` và `List<Number>`) [18, 20].",
  },
  {
    id: 1754,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cú pháp `<T extends BoundingType>` có thể được sử dụng để giới hạn kiểu `T` phải triển khai Interface nào?",
    options: [
      "Chỉ Interface `Cloneable`.",
      "Chỉ Interface `Serializable`.",
      "Bất kỳ Interface nào.",
      "Chỉ Interface `Number`.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `extends` trong Generics có nghĩa là 'extends or implements', và áp dụng cho cả Class và Interface [28, 29].",
  },
  {
    id: 1755,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một phương thức Generic để tìm giá trị tối đa và tối thiểu trong một mảng, bạn phải giới hạn kiểu `T` bằng Interface nào?",
    options: ["Collection", "Comparable", "Serializable", "Iterator"],
    answer: 1,
    explanation:
      "Cần giới hạn kiểu `T` phải triển khai `Comparable` để có thể so sánh các phần tử (ví dụ: `minmax` method) [29, 51].",
  },
  {
    id: 1756,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard `? super Type` thường được sử dụng trong ngữ cảnh nào?",
    options: [
      "Khi bạn chỉ cần lấy ra (get) các phần tử.",
      "Khi bạn cần đưa vào (put) các phần tử.",
      "Để ngăn chặn mọi thao tác đọc và ghi.",
      "Để đảm bảo kiểu `Type` là lớp con của `Object`.",
    ],
    answer: 1,
    explanation:
      "Lower Bounded Wildcards được sử dụng khi bạn muốn chèn/ghi (insert/write) các phần tử [26].",
  },
  {
    id: 1757,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Unbounded Wildcard có thể được coi là tương đương với giới hạn nào sau đây?",
    options: [
      "`? extends Object`",
      "`? super Object`",
      "`<T extends Object>`",
      "Không có giới hạn nào tương đương.",
    ],
    answer: 0,
    explanation:
      "Mặc dù `List<?>` và `List<? extends Object>` có ý nghĩa thực tế tương tự, `List<?>` là cú pháp chính cho Unbounded Wildcard [22]. Tuy nhiên, vì `Object` là lớp cha của mọi thứ [49], `? extends Object` là cách để diễn đạt Unbounded Wildcard bằng cú pháp Upper-bounded [25].",
  },
  {
    id: 1758,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu bạn gọi một phương thức Generic, trình biên dịch sử dụng kỹ thuật nào để xác định kiểu tham số?",
    options: [
      "Upcasting.",
      "Type Erasure.",
      "Type Inference (Suy luận kiểu).",
      "Downcasting.",
    ],
    answer: 2,
    explanation:
      "Khi gọi một phương thức Generic, nếu tham số kiểu bị bỏ qua, trình biên dịch sẽ suy luận kiểu cần thiết (Type Inference) [14].",
  },
  {
    id: 1759,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì KHÔNG thể được sử dụng làm tham số kiểu Generics?",
    options: [
      "Một Class.",
      "Một Interface.",
      "Một Primitive Type.",
      "Một Wrapper Class.",
    ],
    answer: 2,
    explanation:
      "Quy tắc cho Generics là bạn chỉ có thể chỉ định kiểu class hoặc interface, không phải kiểu nguyên thủy (primitives) [11].",
  },
  {
    id: 1760,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để làm cho code Generic hoạt động với các kiểu khác nhau, trước JDK 5.0, giải pháp là sử dụng kế thừa (inheritance) và ép kiểu lên (upcast) mọi thứ thành kiểu nào?",
    options: ["Primitive type.", "List.", "Object class.", "Wrapper class."],
    answer: 2,
    explanation:
      "Giải pháp trước đây là sử dụng kế thừa, vì tất cả các class đều kế thừa từ `Object`, nên các đối tượng có thể được ép kiểu lên thành kiểu `Object` [52].",
  },
  {
    id: 1761,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Hạn chế của việc sử dụng kiểu `Object` trong Collection thay vì Generics là gì?",
    options: [
      "Sử dụng quá nhiều bộ nhớ Heap.",
      "Yêu cầu ép kiểu liên tục và không có cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch.",
      "Gây ra lỗi StackOverflow.",
      "Cấm sử dụng Wrapper Class.",
    ],
    answer: 1,
    explanation:
      "Hạn chế là cần ép kiểu liên tục (casting is required all the time) và không có cơ chế kiểm tra lỗi [35].",
  },
  {
    id: 1762,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi bạn khai báo `ArrayList<Dog> list = new ArrayList<Dog>()`, điều này đảm bảo điều gì?",
    options: [
      "Không có đối tượng nào khác ngoài `Dog` có thể được thêm vào list.",
      "List luôn có kích thước cố định.",
      "Luôn cần ép kiểu khi lấy ra.",
      "List sẽ luôn được sắp xếp theo thứ tự bảng chữ cái.",
    ],
    answer: 0,
    explanation:
      "Generics cho phép bạn tạo ra các Collection an toàn về kiểu, ngăn không cho bạn đặt một đối tượng không phải là `Dog` vào `ArrayList<Dog>` [2, 32].",
  },
  {
    id: 1763,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là SAI về mối quan hệ kế thừa giữa các kiểu Generics?",
    options: [
      "`List<String>` không có quan hệ kế thừa với `List<Object>`.",
      "`Pair<Animal>` không có quan hệ kế thừa với `Pair<Cat>`.",
      "Mảng thông thường (ví dụ: `Dog[]`) hỗ trợ đa hình, nhưng Generics Collection thì không.",
      "`List<T>` có thể kế thừa từ `List<E>`.",
    ],
    answer: 3,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau [18, 20].",
  },
  {
    id: 1764,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một phương thức chấp nhận `List<? extends Pet>`, list này có thể chứa đối tượng nào nếu `RoboDog` triển khai `Pet` nhưng không kế thừa `Animal`?",
    options: [
      "Chỉ các lớp con của `Animal`.",
      "Chỉ các lớp cha của `Pet`.",
      "Bất kỳ lớp nào triển khai `Pet` (ví dụ: `RoboDog`).",
      "Không thể chứa `RoboDog`.",
    ],
    answer: 2,
    explanation:
      "Wildcard có thể sử dụng cho các lớp từ các cây kế thừa khác nhau, miễn là chúng thỏa mãn giới hạn (ví dụ: triển khai interface `Pet`) [53]. Trong Generics, `extends` có thể nghĩa là `implements` [28].",
  },
  {
    id: 1765,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để khai báo một biến `Pair` có thể giữ bất kỳ cặp kiểu nào, bạn có thể sử dụng cú pháp Wildcard nào?",
    options: [
      "`Pair<?, ?>`",
      "`Pair<? extends Object, ? super Object>`",
      "`Pair<Object, Object>`",
      "`Pair<T, E>`",
    ],
    answer: 0,
    explanation:
      "Wildcard không giới hạn (`?`) được sử dụng để chỉ kiểu không xác định. Đối với `Pair<K, V>`, cần hai wildcard [22, 23].",
  },
  {
    id: 1766,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Types, nếu bạn khai báo `<T extends Comparable<T> & Serializable>`, điều này có ý nghĩa gì?",
    options: [
      "T phải là lớp con của `Comparable` hoặc triển khai `Serializable`.",
      "T phải triển khai cả hai interface `Comparable` và `Serializable` (vì không có Class nào được chỉ định trước).",
      "Đây là cú pháp không hợp lệ vì không có Class nào được chỉ định.",
      "T phải là kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Nếu chỉ có các interface được liệt kê, `T` phải triển khai tất cả chúng. Cú pháp này là hợp lệ [30].",
  },
  {
    id: 1767,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một phương thức Generic để tìm kiếm/đọc (search/read) các phần tử thuộc kiểu `T`, bạn nên sử dụng Wildcard nào?",
    options: [
      "Lower-bounded wildcard.",
      "Unbounded wildcard.",
      "Upper-bounded wildcard.",
      "Không cần Wildcard.",
    ],
    answer: 2,
    explanation:
      "Upper-bounded wildcard (`? extends Type`) được sử dụng cho các hoạt động đọc (read operations) [24, 44].",
  },
  {
    id: 1768,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, việc sử dụng từ khóa `extends` trong Bounded Types (ví dụ: `<T extends Number>`) áp dụng cho các kiểu nào?",
    options: [
      "Chỉ Class.",
      "Chỉ Interface.",
      "Class và Interface.",
      "Chỉ Primitive types.",
    ],
    answer: 2,
    explanation:
      "T và BoundingType có thể là class hoặc interface [29]. `extends` có nghĩa là 'extends or implements' [28].",
  },
  {
    id: 1769,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là cần thiết khi lấy đối tượng ra từ `ArrayList<Object>` mà bạn muốn gán cho một lớp con cụ thể (ví dụ: `Dog`)?",
    options: [
      "Không cần làm gì, nó tự động.",
      "Cần ép kiểu thủ công (casting).",
      "Cần sử dụng Wildcard.",
      "Cần dùng toán tử kim cương `<>`.",
    ],
    answer: 1,
    explanation:
      "Các đối tượng đi ra khỏi `ArrayList<Object>` dưới dạng kiểu `Object` và không thể được gán cho một kiểu tham chiếu khác mà không có ép kiểu [34, 54].",
  },
  {
    id: 1770,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cú pháp Generic `List<E>` được sử dụng để chỉ định kiểu của các phần tử trong `List`. `E` trong trường hợp này là viết tắt của gì?",
    options: ["Exception", "Entity", "Element", "Extension"],
    answer: 2,
    explanation: "Quy ước là sử dụng 'E' để đại diện cho Element [33].",
  },
  {
    id: 1771,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử bạn có `List<Animal> list`. Việc gán `List<Animal> list2 = list;` có hợp lệ không?",
    options: [
      "Có, vì chúng là cùng một kiểu Generics.",
      "Không, vì không có mối quan hệ kế thừa.",
      "Chỉ khi sử dụng Wildcard.",
      "Chỉ hợp lệ với `List<Object>`.",
    ],
    answer: 0,
    explanation:
      "Quan hệ kế thừa chỉ bị phá vỡ khi các tham số kiểu là khác nhau. Hai kiểu Generics giống nhau có quan hệ gán bình thường [21].",
  },
  {
    id: 1772,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lợi ích nào sau đây KHÔNG phải là lợi ích trực tiếp của việc sử dụng Generics?",
    options: [
      "Giảm lỗi ClassCastException ở runtime.",
      "Tăng Type Safety.",
      "Loại bỏ nhu cầu sử dụng Wrapper Class.",
      "Mã rõ ràng và dễ đọc hơn (không cần ép kiểu).",
    ],
    answer: 2,
    explanation:
      "Generics vẫn yêu cầu sử dụng Wrapper Class cho các kiểu nguyên thủy (vì không thể dùng primitive type làm tham số kiểu) [11].",
  },
  {
    id: 1773,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi bạn khai báo `ArrayList<Integer> list = new ArrayList<>();` và thêm một `int` (ví dụ: `list.add(5);`), cơ chế nào của Java cho phép điều này xảy ra?",
    options: ["Downcasting", "Upcasting", "Autoboxing", "Type Erasure"],
    answer: 2,
    explanation:
      "Autoboxing là tính năng tự động chuyển đổi từ kiểu nguyên thủy (`int`) sang đối tượng Wrapper (`Integer`), cho phép chèn chúng vào Collection Generics [11, 12].",
  },
  {
    id: 1774,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong một lớp Generic tùy chỉnh, bạn có thể định nghĩa bao nhiêu tham số kiểu?",
    options: [
      "Chỉ một.",
      "Tối đa hai (K và V).",
      "Bất kỳ số lượng nào.",
      "Chỉ giới hạn bởi số lượng Interface mà nó triển khai.",
    ],
    answer: 2,
    explanation:
      "Bạn có thể bao gồm nhiều tham số (include more parameter), ví dụ: `Pair<K, V>` [10]. Số lượng không bị giới hạn trong nguồn.",
  },
  {
    id: 1775,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn giới hạn một tham số kiểu `T` phải là một lớp con của `Animal`, cú pháp nào là đúng?",
    options: [
      "`<T super Animal>`",
      "`<T implements Animal>`",
      "`<T extends Animal>`",
      "`<T>`",
    ],
    answer: 2,
    explanation: "Sử dụng Bounded Type Parameters với `extends` [29].",
  },
  {
    id: 1776,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Upper Bounded Wildcard (`? extends Type`), `Type` đại diện cho điều gì đối với kiểu không xác định?",
    options: [
      "Giới hạn dưới (Lower bound).",
      "Giới hạn trên (Upper bound).",
      "Kiểu Wildcard.",
      "Kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Upper-bounded wildcard được theo sau bởi từ khóa `extends`, tiếp theo là giới hạn trên [24].",
  },
  {
    id: 1777,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard được sử dụng để giới hạn kiểu không xác định là kiểu cha (supertype) của một kiểu cụ thể, cho phép linh hoạt tối đa trong hoạt động gì?",
    options: [
      "Sắp xếp (Sorting).",
      "Tìm kiếm (Searching).",
      "Chèn phần tử (Adding elements).",
      "So sánh (Comparing).",
    ],
    answer: 2,
    explanation:
      "Lower-bounded wildcard cho phép tính linh hoạt tối đa, ví dụ, khi chèn đối tượng `Integer` vào các list có kiểu cha của nó [26].",
  },
  {
    id: 1778,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Unbounded Wildcard có thể được sử dụng trong tình huống nào sau đây?",
    options: [
      "Khi cần truyền một đối tượng `Dog` vào `List<Cat>`.",
      "Khi cần gọi các phương thức chỉ có trong lớp con.",
      "Khi phương thức chỉ cần truy cập các phương thức cơ bản của `Object` (ví dụ: `toString()`).",
      "Khi cần xác định kiểu chính xác ở runtime.",
    ],
    answer: 2,
    explanation:
      "Unbounded wildcard hữu ích khi bạn chỉ sử dụng các chức năng được cung cấp bởi lớp `Object` [22].",
  },
  {
    id: 1779,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu không sử dụng Generics, việc lấy đối tượng ra từ Collection (dưới dạng `Object`) và gán cho một kiểu cụ thể (ví dụ: `String s = (String) list.get(0);`) có thể gây ra lỗi gì ở runtime nếu kiểu bị sai?",
    options: [
      "ArithmeticException",
      "IndexOutOfBoundsException",
      "ClassCastException",
      "InterruptedException",
    ],
    answer: 2,
    explanation:
      "Nếu list không có generics, bạn có thể nhầm lẫn chèn một kiểu khác (ví dụ: `Pumpkin` vào list của `Cat`), dẫn đến lỗi `ClassCastException` ở runtime [3, 35].",
  },
  {
    id: 1780,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Ký hiệu `<T extends Comparable<T>>` là một ví dụ điển hình của loại Generics nào?",
    options: [
      "Unbounded type.",
      "Lower bounded type.",
      "Upper bounded type.",
      "Wildcard type.",
    ],
    answer: 2,
    explanation:
      "Đây là cú pháp của Bounded Type Parameters, và vì nó sử dụng `extends`, nó là Upper Bounded [29].",
  },
  {
    id: 1781,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp `<T extends BoundingType>`, nếu `BoundingType` là một Class, `T` phải là gì của `BoundingType`?",
    options: ["Lớp cha.", "Cùng cấp.", "Lớp con (subtype).", "Interface."],
    answer: 2,
    explanation: "T phải là kiểu con (subtype) của BoundingType [29].",
  },
  {
    id: 1782,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi khai báo một Generics Method, tại sao tham số kiểu (ví dụ: `<T>`) phải đứng trước kiểu trả về?",
    options: [
      "Để giới hạn phạm vi của `T` chỉ trong phương thức đó.",
      "Để JVM có thể thực hiện Type Erasure.",
      "Để phân biệt nó với tham số kiểu của Class.",
      "Vì đây là quy tắc cú pháp bắt buộc của Java.",
    ],
    answer: 3,
    explanation:
      "Cú pháp cho một phương thức generic bao gồm danh sách tham số kiểu nằm trong ngoặc nhọn `<>`, xuất hiện trước kiểu trả về của phương thức [13, 15].",
  },
  {
    id: 1783,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là SAI về Generics trong Java?",
    options: [
      "Generics đảm bảo tính Type Safety.",
      "Generics sử dụng ký hiệu kim cương `<>`.",
      "Generics cho phép đa hình giữa `List<A>` và `List<B>` nếu B là lớp con của A.",
      "Generics loại bỏ việc ép kiểu thủ công khi trích xuất dữ liệu từ Collection.",
    ],
    answer: 2,
    explanation:
      "Generics không cho phép đa hình giữa các kiểu Generics khác nhau (`List<A>` và `List<B>`) [18, 20].",
  },
  {
    id: 1784,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử bạn có `List<Animal> list`. Nếu bạn muốn in các phần tử mà không cần biết kiểu cụ thể, bạn có thể truyền nó cho phương thức chấp nhận tham số nào?",
    options: [
      "`List<Object>`",
      "`List<? extends Animal>`",
      "`List<?>`",
      "Cả B và C đều đúng.",
    ],
    answer: 3,
    explanation:
      "Cả `List<? extends Animal>` (Upper Bounded, đọc) và `List<?>` (Unbounded, đọc/in) đều có thể được sử dụng để in các phần tử [22, 24, 36].",
  },
  {
    id: 1785,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard `List<?>`, bạn vẫn có thể thực hiện thao tác nào sau đây trên list?",
    options: [
      "Thêm đối tượng `Object`.",
      "Gọi `list.size()`.",
      "Gọi phương thức tùy chỉnh của kiểu `T`.",
      "Thêm đối tượng `String`.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcard hữu ích khi code sử dụng các phương thức không phụ thuộc vào tham số kiểu, ví dụ: `List.size()` và `List.clear()` [22].",
  },
  {
    id: 1786,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo chấp nhận `List<? super String>`, kiểu list nào sau đây sẽ gây lỗi biên dịch khi được truyền vào?",
    options: [
      "`List<String>`",
      "`List<Object>`",
      "`List<Comparable>`",
      "`List<Integer>`",
    ],
    answer: 3,
    explanation:
      "`? super String` chấp nhận `String` và các kiểu cha của `String`. `Integer` không phải là kiểu cha của `String`.",
  },
  {
    id: 1787,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard, nếu bạn lấy ra một phần tử và cố gắng gọi một phương thức không có trong `Object` class, điều gì xảy ra?",
    options: [
      "Lỗi runtime.",
      "Lỗi biên dịch.",
      "Phương thức đó sẽ tự động được thêm vào `Object` class.",
      "Không có gì xảy ra.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch kiểm tra kiểu tham chiếu trước khi cho phép gọi một phương thức. Nếu tham chiếu là `Object` (`List<?>` trả về `Object`), bạn chỉ có thể gọi các phương thức `Object` [39, 55].",
  },
  {
    id: 1788,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu bạn có một Generic Method, tham số kiểu (Type Parameter) của nó bị giới hạn phạm vi ở đâu?",
    options: [
      "Toàn bộ project.",
      "Toàn bộ Class.",
      "Chỉ trong Method đó.",
      "Chỉ trong tệp tin.",
    ],
    answer: 2,
    explanation:
      "Phạm vi của tham số kiểu bị giới hạn trong phương thức mà nó được khai báo [13].",
  },
  {
    id: 1789,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics trong Java được thiết kế để áp dụng chủ yếu cho loại code nào?",
    options: [
      "Các thuật toán số học.",
      "Các lớp giao diện người dùng (GUI).",
      "Các Collection (Cấu trúc dữ liệu chứa các phần tử khác).",
      "Các Constructor.",
    ],
    answer: 2,
    explanation:
      "Hầu như tất cả code Generics bạn viết sẽ liên quan đến Collection. Mặc dù Generics có thể được sử dụng theo những cách khác, mục đích chính là để tạo các collection an toàn về kiểu dữ liệu [2, 56].",
  },
  {
    id: 1790,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi khai báo `List<? extends T>`, Wildcard này thể hiện mối quan hệ kế thừa nào giữa kiểu không xác định và kiểu `T`?",
    options: [
      "Kiểu không xác định là siêu lớp của T.",
      "Kiểu không xác định là lớp con của T (hoặc chính T).",
      "Kiểu không xác định phải là kiểu Object.",
      "Không có mối quan hệ kế thừa nào.",
    ],
    answer: 1,
    explanation:
      "Upper bounded wildcard giới hạn kiểu không xác định là `T` hoặc bất kỳ lớp con nào của `T` [24, 57].",
  },
  {
    id: 1791,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG khi sử dụng `ArrayList<Integer>`?",
    options: [
      "Chỉ có thể thêm đối tượng `Integer` vào list.",
      "Chỉ có thể thêm kiểu nguyên thủy `int` vào list.",
      "Có thể thêm cả `int` (Autoboxing) và `Integer` vào list.",
      "Chỉ có thể thêm đối tượng `Number`.",
    ],
    answer: 2,
    explanation:
      "Nhờ tính năng Autoboxing, bạn có thể đưa các kiểu nguyên thủy (`int`) vào `ArrayList<Integer>` một cách tự động [11]. Bạn cũng có thể thêm đối tượng `Integer` trực tiếp.",
  },
  {
    id: 1792,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào sau đây nên được sử dụng khi bạn muốn đảm bảo tính an toàn kiểu dữ liệu (Type Safety) cho các thao tác chèn (add)?",
    options: ["`?`", "`? extends T`", "`? super T`", "`<T>`"],
    answer: 2,
    explanation:
      "Lower Bounded Wildcard (`? super T`) được sử dụng cho các hoạt động ghi/chèn (put) [26].",
  },
  {
    id: 1793,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn định nghĩa một lớp `Pair` có thể chứa hai kiểu dữ liệu khác nhau (ví dụ: `String` và `Integer`), cú pháp khai báo class sẽ như thế nào?",
    options: [
      "`public class Pair<K, V>`",
      "`public class Pair<T>`",
      "`public class Pair`",
      "`public class Pair<?>`",
    ],
    answer: 0,
    explanation:
      "Để có hai tham số kiểu độc lập, bạn cần khai báo cả K và V: `public class Pair<K, V>` [10, 13].",
  },
  {
    id: 1794,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về Bounded Types với nhiều Interface?",
    options: [
      "Bạn có thể liệt kê nhiều Class.",
      "Bạn có thể liệt kê nhiều Interface, sử dụng `&` giữa chúng.",
      "Bạn phải sử dụng `|` để phân tách các Interface.",
      "Nó chỉ hoạt động với Unbounded Wildcard.",
    ],
    answer: 1,
    explanation:
      "Có thể chỉ định nhiều kiểu ràng buộc (Multiple bounding types), bao gồm nhiều Interface, ví dụ: `& Serializable & Cloneable` [30].",
  },
  {
    id: 1795,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong tình huống nào, việc sử dụng Generics là ít quan trọng nhất?",
    options: [
      "Khi làm việc với các kiểu dữ liệu phức tạp.",
      "Khi cần lưu trữ và thao tác với các phần tử trong Collection.",
      "Khi làm việc với các thuật toán độc lập với kiểu dữ liệu.",
      "Khi bạn chắc chắn rằng Collection sẽ chỉ chứa kiểu `Object` và bạn không bao giờ truy cập vào các phương thức cụ thể của lớp con.",
    ],
    answer: 3,
    explanation:
      "Nếu bạn chỉ sử dụng các phương thức của `Object` và không cần kiểm tra kiểu nghiêm ngặt (ví dụ: chỉ in ra), Unbounded Wildcard hoặc `List<Object>` là đủ [22].",
  },
  {
    id: 1796,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Ký hiệu kim cương `<>` là cách viết tắt cho cú pháp Generics được sử dụng ở đâu?",
    options: [
      "Khai báo tham số kiểu của Class.",
      "Khai báo tham số kiểu của Method.",
      "Khởi tạo đối tượng (Constructor Call).",
      "Sử dụng Bounded Type.",
    ],
    answer: 2,
    explanation:
      "Ví dụ: `Pair<String> o=new Pair<>('1st','2nd')` [10]. Ký hiệu này được sử dụng khi gọi constructor.",
  },
  {
    id: 1797,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lợi ích chính nào của Generics đã được chứng minh trong ví dụ `List<String> list = new ArrayList(); list.add(“hello Java”); String s= list.get(0);` so với phiên bản không có Generics?",
    options: [
      "Mã được biên dịch nhanh hơn.",
      "Loại bỏ yêu cầu ép kiểu `(String)`.",
      "Cho phép lưu trữ kiểu nguyên thủy.",
      "Đảm bảo tính tương thích ngược.",
    ],
    answer: 1,
    explanation:
      "Code with generics: `String s= list.get(0)` (không cần ép kiểu) [7].",
  },
  {
    id: 1798,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn khai báo `List<? extends Animal> list`, và `Cat` là lớp con của `Animal`, việc gọi `list.get(0)` sẽ trả về kiểu dữ liệu nào?",
    options: ["Cat", "Object", "Animal", "Tùy thuộc vào phần tử được lưu trữ."],
    answer: 2,
    explanation:
      "Dù list chứa gì (Dog hay Cat), Upper Bound là `Animal`, nên khi đọc ra, bạn có thể tham chiếu nó là `Animal` [37].",
  },
  {
    id: 1799,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào sau đây được sử dụng để chỉ kiểu không xác định (unknown type)?",
    options: ["`#`", "`&`", "`?`", "`@`"],
    answer: 2,
    explanation:
      "Ký tự wildcard `?` được sử dụng để chỉ kiểu không xác định [22-24, 26].",
  },
  {
    id: 1800,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mối quan hệ nào sau đây tồn tại giữa `List<Object>` và `List<String>` trong Generics?",
    options: [
      "List<Object> là lớp cha của List<String>.",
      "List<String> là lớp con của List<Object>.",
      "Không có mối quan hệ kế thừa.",
      "Chúng là cùng một kiểu.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa nào giữa các kiểu generic khác nhau [18, 20].",
  },
  {
    id: 1801,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo chấp nhận `List<? super Integer>`, list nào sau đây sẽ hợp lệ?",
    options: ["List<Double>", "List<String>", "List<Number>", "List<Byte>"],
    answer: 2,
    explanation:
      "`? super Integer` chấp nhận `Integer` và các kiểu cha của nó, bao gồm `Number` và `Object` [26].",
  },
  {
    id: 1802,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Tại sao Generics không cho phép `List<Animal> animals = new ArrayList<Dog>();`?",
    options: [
      "Vì nó phá vỡ khả năng chèn các kiểu khác nhau (ví dụ: Cat) vào list của Dog, vi phạm Type Safety.",
      "Vì `ArrayList` không triển khai `List`.",
      "Vì `Dog` không phải là `final`.",
      "Vì cần sử dụng Unbounded Wildcard.",
    ],
    answer: 0,
    explanation:
      "Nếu được phép, bạn có thể thêm một đối tượng không phải Dog (ví dụ Cat, nếu Cat cũng là Animal) vào list mà lẽ ra chỉ chứa Dog, vi phạm tính an toàn kiểu [18, 20, 44].",
  },
  {
    id: 1803,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, bạn có thể khai báo một biến tham chiếu với kiểu nào sau đây?",
    options: [
      "`List<primitive>`",
      "`ArrayList<Integer>`",
      "`List<?>`",
      "Cả B và C đều đúng.",
    ],
    answer: 3,
    explanation:
      "`ArrayList<Integer>` là hợp lệ [7]. `List<?>` là Unbounded Wildcard và là một kiểu tham chiếu hợp lệ [22, 23]. `List<primitive>` là không hợp lệ [11].",
  },
  {
    id: 1804,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Bounded Type `<T extends Class & Interface>`, nếu Class là `Number`, điều này đảm bảo rằng `T` là lớp con của `Number` VÀ điều gì?",
    options: [
      "T phải là kiểu nguyên thủy.",
      "T phải triển khai Interface.",
      "T phải là kiểu `Object`.",
      "T phải là kiểu `String`.",
    ],
    answer: 1,
    explanation:
      "T phải là kiểu con của Class VÀ triển khai tất cả các Interface được liệt kê [29, 30].",
  },
  {
    id: 1805,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của việc sử dụng Unbounded Wildcard là để cho phép phương thức hoạt động với một list có kiểu phần tử như thế nào?",
    options: [
      "Bất kỳ kiểu nào, miễn là nó có thể được xử lý như Object.",
      "Chỉ String.",
      "Chỉ các lớp cha của Object.",
      "Chỉ các kiểu được xác định rõ ràng.",
    ],
    answer: 0,
    explanation:
      "Unbounded wildcard (`List<?>`) chấp nhận một list của bất kỳ kiểu nào, và cho phép truy cập các phương thức của Object [22].",
  },
  {
    id: 1806,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Ký hiệu kim cương `<>` được sử dụng để làm gì khi khởi tạo Generics object?",
    options: [
      "Chỉ định giới hạn trên.",
      "Chỉ định giới hạn dưới.",
      "Cho phép trình biên dịch suy luận kiểu tham số, tránh lặp lại tên kiểu.",
      "Yêu cầu ép kiểu thủ công.",
    ],
    answer: 2,
    explanation:
      "Ký hiệu `<>` được sử dụng để khai báo biến, và trình biên dịch sẽ suy luận kiểu cần thiết [10].",
  },
  {
    id: 1807,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về Generics Methods?",
    options: [
      "Nó phải được khai báo trong một Generic Class.",
      "Nó không thể được gọi mà không chỉ định tham số kiểu rõ ràng.",
      "Nó có thể giới thiệu các tham số kiểu riêng biệt so với tham số kiểu của Class.",
      "Nó không thể sử dụng Wildcard.",
    ],
    answer: 2,
    explanation:
      "Generic methods giới thiệu tham số kiểu riêng của chúng, độc lập với tham số kiểu của class [13].",
  },
  {
    id: 1808,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Types, nếu kiểu `BoundingType` là `Comparable`, `extends` trong cú pháp này thực chất đại diện cho hành động nào?",
    options: [
      "Kế thừa Class.",
      "Triển khai Interface.",
      "Chỉ cho phép so sánh số nguyên.",
      "Ép kiểu lên.",
    ],
    answer: 1,
    explanation:
      "`Comparable` là một Interface [58]. Trong Generics, `extends` áp dụng cho cả việc kế thừa và triển khai [28].",
  },
  {
    id: 1809,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard (`? extends T`) chủ yếu được sử dụng để làm gì?",
    options: [
      "Lưu trữ một kiểu dữ liệu duy nhất.",
      "Cho phép đọc một tập hợp các kiểu con của T.",
      "Cho phép ghi một tập hợp các kiểu cha của T.",
      "Buộc các lớp phải là `final`.",
    ],
    answer: 1,
    explanation:
      "Upper Bounded Wildcard được sử dụng để làm việc trên `T` hoặc các kiểu con của `T` [24, 57].",
  },
  {
    id: 1810,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào sau đây nên được sử dụng khi bạn muốn list có thể chứa một kiểu cụ thể và tất cả các kiểu cha (superclasses) của nó?",
    options: ["`? extends T`", "`? super T`", "`<?>`", "`<T>`"],
    answer: 1,
    explanation:
      "Lower Bounded Wildcard (`? super T`) giới hạn kiểu không xác định là kiểu cha (supertype) của T [26].",
  },
  {
    id: 1811,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sử dụng Generics giúp tránh lỗi nào sau đây khi truy cập các phương thức của đối tượng?",
    options: [
      "Lỗi cú pháp.",
      "Lỗi logic.",
      "Lỗi kiểu dữ liệu ở compile-time.",
      "Lỗi NullPointer.",
    ],
    answer: 2,
    explanation:
      "Generics giúp bạn phát hiện lỗi kiểu ở thời điểm biên dịch (compile-time) [2, 3].",
  },
  {
    id: 1812,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi định nghĩa một class Generic, nếu bạn muốn tham số kiểu có thể là bất kỳ kiểu nào, bạn có thể bỏ qua việc sử dụng Bounded Type. Kiểu này ngầm định kế thừa từ lớp nào?",
    options: ["Interface", "String", "Wrapper", "Object"],
    answer: 3,
    explanation:
      "Tất cả các class đều kế thừa từ `Object` [49]. Nếu không có giới hạn, tham số kiểu mặc định giới hạn là `Object`.",
  },
  {
    id: 1813,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard (`List<?>`), tại sao bạn không thể thêm một đối tượng `Object` vào list?",
    options: [
      "Vì `Object` là lớp cha.",
      "Vì trình biên dịch không thể chắc chắn liệu đối tượng đó có tương thích với kiểu không xác định hay không.",
      "Vì Unbounded Wildcard chỉ áp dụng cho `String`.",
      "Vì nó phá vỡ tính đa hình.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcard ngăn chặn việc thêm phần tử vì không thể biết kiểu của `?`, do đó không đảm bảo an toàn kiểu [44]. (Chỉ có thể thêm `null`).",
  },
  {
    id: 1814,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giả sử bạn có `List<Number> numbers = new ArrayList<>();`. Nếu bạn cố gắng gán `List<Integer> integers = numbers;`, điều gì xảy ra?",
    options: [
      "Hợp lệ, vì Integer là lớp con của Number.",
      "Lỗi biên dịch.",
      "Lỗi runtime.",
      "Hợp lệ nếu sử dụng Wildcard.",
    ],
    answer: 1,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu Generics khác nhau, ngay cả khi tham số kiểu có mối quan hệ kế thừa [18, 20, 21].",
  },
  {
    id: 1815,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương pháp nào thường được sử dụng trong các lớp Wrapper để chuyển đổi chuỗi số thành giá trị số nguyên thủy?",
    options: ["`typeValue()`", "`valueOf()`", "`parseXXX()`", "`toString()`"],
    answer: 2,
    explanation:
      "Các phương thức của kiểu `parseXXX()` được sử dụng để chuyển đổi chuỗi thành kiểu dữ liệu nguyên thủy (ví dụ: `Integer.parseInt()`) [12, 59, 60].",
  },
  {
    id: 1816,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi bạn sử dụng Generics, bạn phải sử dụng các kiểu Wrapper Class cho các kiểu nguyên thủy vì chúng là gì?",
    options: [
      "Là các interface.",
      "Là các đối tượng (object).",
      "Là các hằng số.",
      "Là các kiểu `final`.",
    ],
    answer: 1,
    explanation:
      "Wrapper class gói gọn một kiểu dữ liệu nguyên thủy, mang lại cho nó vẻ ngoài của một đối tượng [12, 36]. Generics yêu cầu tham số kiểu phải là class hoặc interface [11].",
  },
  {
    id: 1817,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp `<T extends BoundingType>`, `T` có thể là một kiểu cụ thể nào (ví dụ: `Integer`) không?",
    options: [
      "Không, `T` luôn là một kiểu trừu tượng.",
      "Có, nếu `BoundingType` là `final`.",
      "Có, `T` đại diện cho kiểu dữ liệu được cung cấp khi khởi tạo.",
      "Chỉ nếu nó không có giới hạn nào.",
    ],
    answer: 2,
    explanation:
      "Tham số kiểu T được thay thế bằng kiểu cụ thể khi khởi tạo (ví dụ: `Pair<String>`) [10, 61].",
  },
  {
    id: 1818,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard (`? extends T`) cho phép truy xuất đối tượng dưới dạng kiểu nào?",
    options: [
      "Chỉ kiểu Object.",
      "Kiểu T (Giới hạn trên).",
      "Kiểu cụ thể của phần tử.",
      "Kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Upper Bounded là giới hạn trên. Khi đọc ra, bạn có thể tham chiếu phần tử bằng giới hạn trên đó (Type T) [37].",
  },
  {
    id: 1819,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một hàm có thể chấp nhận `List<Number>` và `List<Object>`, bạn nên sử dụng Wildcard nào?",
    options: [
      "`List<? extends Number>`",
      "`List<? super Number>`",
      "`List<Integer>`",
      "`List<Double>`",
    ],
    answer: 1,
    explanation:
      "`? super Number` chấp nhận `Number` và các kiểu cha của nó (ví dụ: `Object`) [26].",
  },
  {
    id: 1820,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Unbounded Wildcard (`List<?>`) khác với `List<Object>` ở điểm nào?",
    options: [
      "Cả hai đều không thể chèn (put) các phần tử.",
      "`List<?>` có thể được gán cho `List<String>`, còn `List<Object>` thì không.",
      "`List<Object>` có thể chèn các đối tượng, còn `List<?>` thì không (ngoại trừ null).",
      "Không có sự khác biệt.",
    ],
    answer: 2,
    explanation:
      "`List<Object>` có thể chấp nhận việc chèn bất kỳ đối tượng nào (vì mọi thứ là Object) [49]. `List<?>` ngăn chặn việc chèn để đảm bảo tính Type Safety [44]. (Đây là sự khác biệt chính trong ngữ cảnh Wildcard).",
  },
  {
    id: 1821,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cú pháp Generic nào sau đây là TƯƠNG ĐƯƠNG với `List<? extends Animal>` (khi Animal là lớp cơ sở/class)?",
    options: [
      "`List<? super Animal>`",
      "`<T extends Animal> List<T>`",
      "`<T super Animal> List<T>`",
      "`List<Object>`",
    ],
    answer: 1,
    explanation:
      "Hai cú pháp này thực hiện cùng một việc: chấp nhận List của Animal và các lớp con của nó, thường cho hoạt động đọc [47].",
  },
  {
    id: 1822,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn gọi `list.get(0)` trên một `List` không có Generics và không ép kiểu?",
    options: [
      "Lỗi biên dịch nếu bạn gán kết quả cho một kiểu cụ thể (ví dụ: String).",
      "Lỗi runtime.",
      "Nó tự động trả về kiểu String.",
      "Nó tự động trả về kiểu Integer.",
    ],
    answer: 0,
    explanation:
      "Khi không có Generics, `list.get(0)` trả về `Object`. Nếu bạn gán `Object` cho `String s = list.get(0);` mà không ép kiểu, sẽ gây lỗi biên dịch vì kiểu không khớp [7, 55].",
  },
  {
    id: 1823,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong việc định nghĩa Generic class `public class MyList<T>`, nếu `T` không bị giới hạn, thì `T` có thể đại diện cho kiểu nào?",
    options: [
      "Bất kỳ Class hoặc Interface nào.",
      "Chỉ các Wrapper Class.",
      "Chỉ các Class có sẵn trong JDK.",
      "Chỉ các Primitive Types.",
    ],
    answer: 0,
    explanation:
      "Nếu không bị giới hạn, T có thể là bất kỳ Class hoặc Interface nào, ngầm định kế thừa từ Object [1, 49].",
  },
  {
    id: 1824,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard được gọi là 'Upper Bounded' vì nó giới hạn ở phía nào của cây kế thừa?",
    options: [
      "Phía lớp con.",
      "Phía lớp cha.",
      "Phía ngang hàng.",
      "Không liên quan đến kế thừa.",
    ],
    answer: 1,
    explanation:
      "Upper Bound là giới hạn trên của cây kế thừa (Type T và các lớp con) [24].",
  },
  {
    id: 1825,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard được gọi là 'Lower Bounded' vì nó giới hạn ở phía nào của cây kế thừa?",
    options: [
      "Phía lớp con.",
      "Phía lớp cha (Type T và các lớp cha).",
      "Phía ngang hàng.",
      "Không liên quan đến kế thừa.",
    ],
    answer: 1,
    explanation:
      "Lower Bounded là giới hạn dưới của cây kế thừa (Type T và các lớp cha) [26].",
  },
  {
    id: 1826,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Types, nếu bạn muốn so sánh đối tượng, bạn nên sử dụng `extends` với Interface nào?",
    options: ["Serializable", "Cloneable", "Comparable", "Iterator"],
    answer: 2,
    explanation:
      "Interface `Comparable` chứa phương thức `compareTo()` được sử dụng để so sánh đối tượng [29, 58].",
  },
  {
    id: 1827,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cú pháp nào sau đây là hợp lệ cho Multiple Bounding Types?",
    options: [
      "`<T extends Interface1, Class1>`",
      "`<T extends Interface1 | Interface2>`",
      "`<T extends Class1 & Interface1 & Interface2>`",
      "`<T implements Class1 & Interface1>`",
    ],
    answer: 2,
    explanation:
      "Cú pháp cho nhiều giới hạn là sử dụng `&`, và class (nếu có) phải đứng trước các interface [29, 30].",
  },
  {
    id: 1828,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của việc sử dụng Generics là để tạo ra các thuật toán và cấu trúc dữ liệu như Stack hoặc Linked List, độc lập với điều gì?",
    options: [
      "Tên biến.",
      "Hệ điều hành.",
      "Kiểu dữ liệu của các mục.",
      "Số lượng phương thức.",
    ],
    answer: 2,
    explanation:
      "Hầu hết các thuật toán và cấu trúc dữ liệu (e.g., stacks, linked list) đều độc lập với kiểu dữ liệu của các mục. Generics cho phép tái sử dụng code này [45].",
  },
  {
    id: 1829,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một phương thức chấp nhận tham số `List<? super String>`, bạn có thể thêm đối tượng nào vào list đó?",
    options: [
      "Chỉ String.",
      "String và Object.",
      "String và các lớp con của String.",
      "Bất kỳ kiểu nào.",
    ],
    answer: 1,
    explanation:
      "Lower Bounded Wildcard cho phép thêm các đối tượng có kiểu là `String` (giới hạn dưới) hoặc bất kỳ lớp con nào của `String`. Tuy nhiên, vì `String` là `final`, nó chỉ có thể là `String`.",
  },
  {
    id: 1830,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt về Type Safety giữa Generic Collection và Array là gì?",
    options: [
      "Cả hai đều kiểm tra Type Safety ở runtime.",
      "Array kiểm tra Type Safety ở compile-time, Generics ở runtime.",
      "Generics kiểm tra Type Safety ở compile-time, Array kiểm tra ở runtime (ArrayStoreException).",
      "Cả hai đều không kiểm tra Type Safety.",
    ],
    answer: 2,
    explanation:
      "Generics kiểm tra Type Safety ở compile time [3, 4]. Array hỗ trợ đa hình nhưng việc chèn sai kiểu dẫn đến `ArrayStoreException` ở runtime [38].",
  },
  {
    id: 1831,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong khai báo Generics, ký hiệu `T` được sử dụng như một tham số kiểu thường có ý nghĩa gì?",
    options: ["Key", "Value", "Element", "Type (Kiểu chung)"],
    answer: 3,
    explanation: "T là quy ước cho Type (kiểu chung) [33].",
  },
  {
    id: 1832,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một Generic Method mà không có ràng buộc (unbounded), cú pháp khai báo tham số kiểu là gì?",
    options: ["`<T extends Object>`", "`<T>`", "`<T super Object>`", "`<?>`"],
    answer: 1,
    explanation:
      "Phương thức Generic không có ràng buộc sử dụng `<T>` trước kiểu trả về [15]. (Cú pháp `<T extends Object>` là tương đương về mặt giới hạn).",
  },
  {
    id: 1833,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard `List<?>` trong một phương thức, bạn có thể gọi phương thức `size()` trên list không?",
    options: [
      "Không, vì `size()` phụ thuộc vào kiểu của phần tử.",
      "Có, vì `size()` không phụ thuộc vào tham số kiểu.",
      "Chỉ nếu list là `ArrayList`.",
      "Chỉ nếu `Object` triển khai `List`.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcard hữu ích khi code sử dụng các phương thức không phụ thuộc vào tham số kiểu, ví dụ: `List.size()` [22].",
  },
  {
    id: 1834,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về tham số kiểu `E` trong interface `List<E>`?",
    options: [
      "Nó phải là kiểu Class.",
      "Nó chỉ là một ký hiệu giữ chỗ cho kiểu dữ liệu thực tế.",
      "Nó luôn là kiểu `Object`.",
      "Nó đại diện cho giới hạn dưới.",
    ],
    answer: 1,
    explanation:
      "E đại diện cho kiểu được sử dụng để tạo một thể hiện của List [61].",
  },
  {
    id: 1835,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một lớp Generic được khởi tạo là `ArrayList<String>`, thì `E` trong định nghĩa `public boolean add(E o)` sẽ được thay thế bằng kiểu nào?",
    options: ["Object", "ArrayList", "String", "Character"],
    answer: 2,
    explanation:
      "Nếu `ArrayList` được khởi tạo với `String`, thì `E` trong phương thức sẽ trở thành `String` [61].",
  },
  {
    id: 1836,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, từ khóa `super` trong Lower Bounded Wildcard giới hạn kiểu không xác định là gì?",
    options: [
      "Phải là chính kiểu đó hoặc một kiểu con.",
      "Phải là chính kiểu đó hoặc một kiểu cha.",
      "Phải là kiểu nguyên thủy.",
      "Phải là kiểu Wrapper.",
    ],
    answer: 1,
    explanation:
      "Lower-bounded wildcard giới hạn kiểu không xác định là kiểu cha (supertype) của một kiểu cụ thể [26].",
  },
  {
    id: 1837,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Bounded Types, nếu không có Class nào được chỉ định, Generics sẽ ngầm hiểu Class nào là giới hạn trên cơ sở?",
    options: ["String", "Number", "Object", "Interface"],
    answer: 2,
    explanation:
      "Nếu không có giới hạn, kiểu mặc định giới hạn là `Object` [49].",
  },
  {
    id: 1838,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Upper Bounded Wildcard, bạn có thể gọi phương thức nào trên các đối tượng được truy xuất?",
    options: [
      "Chỉ các phương thức của lớp con.",
      "Các phương thức được định nghĩa trong giới hạn trên (Upper Bound).",
      "Bất kỳ phương thức nào.",
      "Chỉ các phương thức tĩnh.",
    ],
    answer: 1,
    explanation:
      "Bạn có thể gọi các phương thức trên một đối tượng chỉ khi các phương thức đó có trong class (hoặc interface) được sử dụng làm kiểu tham chiếu [39].",
  },
  {
    id: 1839,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo chấp nhận `List<? extends Animal>`, list nào sau đây sẽ hợp lệ?",
    options: ["List<Dog>", "List<Object>", "List<String>", "List<Integer>"],
    answer: 0,
    explanation:
      "Upper Bounded Wildcard (`? extends Animal`) chấp nhận `Animal` và các lớp con của nó (ví dụ: `Dog`) [24, 57].",
  },
  {
    id: 1840,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về Wildcard không giới hạn (`<?>`)?",
    options: [
      "Nó được sử dụng để giới hạn kiểu chỉ là lớp con của Object.",
      "Nó được sử dụng để chỉ kiểu không xác định.",
      "Nó cho phép thêm bất kỳ đối tượng nào.",
      "Nó yêu cầu ép kiểu khi trích xuất phần tử.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcard được chỉ định bằng ký tự wildcard `?` [22, 23].",
  },
  {
    id: 1841,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Generics, việc so sánh hai đối tượng (ví dụ: `p1.getKey().equals(p2.getKey())`) được thực hiện nhờ vào phương thức nào?",
    options: ["`==`", "`compare()`", "`equals()`", "`compareTo()`"],
    answer: 2,
    explanation: "Các đối tượng được so sánh bằng phương thức `equals()` [14].",
  },
  {
    id: 1842,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics giúp giảm rủi ro về ClassCastException bằng cách chuyển các lỗi liên quan đến kiểu dữ liệu từ runtime sang đâu?",
    options: ["Link time", "Deployment time", "Compile time", "Load time"],
    answer: 2,
    explanation: "Generics giúp phát hiện lỗi kiểu ở compile-time [2-4].",
  },
  {
    id: 1843,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi định nghĩa một Generic Method, cú pháp `<T>` trước kiểu trả về là bắt buộc nếu T là gì?",
    options: [
      "Đã được định nghĩa ở cấp Class.",
      "Chưa được định nghĩa ở cấp Class và chỉ dùng trong Method.",
      "Là một Wildcard.",
      "Là một Primitive Type.",
    ],
    answer: 1,
    explanation:
      "Nếu class không có tham số kiểu, bạn vẫn có thể chỉ định một tham số kiểu cho method bằng cách khai báo nó trước kiểu trả về [15]. Nếu T đã được định nghĩa ở cấp class, bạn chỉ cần sử dụng nó [62].",
  },
  {
    id: 1844,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là KHÔNG đúng về việc sử dụng Bounded Type Parameters?",
    options: [
      "Sử dụng `extends` cho cả Class và Interface.",
      "Có thể giới hạn bởi nhiều Interface.",
      "Có thể sử dụng Primitive Type làm BoundingType.",
      "Giúp truy cập các phương thức cụ thể của Class/Interface giới hạn.",
    ],
    answer: 2,
    explanation:
      "Primitive Type không thể là tham số kiểu Generics [11] hay BoundingType.",
  },
  {
    id: 1845,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một hàm có thể chấp nhận `List<Number>` và bạn muốn thêm `Integer` vào đó, bạn nên sử dụng giới hạn nào?",
    options: [
      "`List<? extends Number>`",
      "`List<Number>`",
      "`List<? super Integer>`",
      "`List<?>`",
    ],
    answer: 2,
    explanation:
      "Bạn cần Lower Bounded Wildcard (`? super Integer`) để cho phép chèn `Integer` vào list `Number` hoặc các kiểu cha của nó [26].",
  },
  {
    id: 1846,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của việc sử dụng Wildcard (`?`) là gì?",
    options: [
      "Buộc một lớp phải kế thừa `Object`.",
      "Giới thiệu tham số kiểu cho một phương thức.",
      "Nới lỏng các ràng buộc về kiểu trên một biến.",
      "Ngăn chặn việc sử dụng Autoboxing.",
    ],
    answer: 2,
    explanation:
      "Wildcards được sử dụng để nới lỏng các ràng buộc đối với một biến [24].",
  },
  {
    id: 1847,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt giữa `List<? extends Animal>` và `List<Animal>` là gì?",
    options: [
      "Cả hai đều chấp nhận `List<Dog>`.",
      "`List<? extends Animal>` chấp nhận `List<Dog>`, còn `List<Animal>` thì không.",
      "Chỉ `List<Animal>` chấp nhận `List<Dog>`.",
      "Cả hai đều bị cấm sử dụng Unbounded Wildcard.",
    ],
    answer: 1,
    explanation:
      "`List<Animal>` chỉ chấp nhận `List<Animal>`. `List<? extends Animal>` chấp nhận `List<Animal>` và các lớp con như `List<Dog>` [44].",
  },
  {
    id: 1848,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Bounded Types, nếu bạn chỉ muốn ràng buộc kiểu `T` với một Interface (ví dụ: `Runnable`), bạn sử dụng từ khóa nào?",
    options: ["`implements`", "`super`", "`extends`", "`Class`"],
    answer: 2,
    explanation:
      "Trong Generics, `extends` có nghĩa là 'extends or implements', và được sử dụng để ràng buộc với Interface [28].",
  },
  {
    id: 1849,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn sử dụng Generics, bạn có thể thay thế khai báo `List list = new ArrayList()` bằng gì để có được tính an toàn kiểu?",
    options: ["`List<String>`", "`List<T>`", "`List<Object>`", "`List<?>`"],
    answer: 2,
    explanation:
      "Nếu không có Generics, Collection hoạt động giống như `List<Object>` [3, 63].",
  },
  {
    id: 1850,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Generic Method, bạn có thể gọi phương thức đó mà không cần chỉ định rõ ràng tham số kiểu (ví dụ: `Util.compare(p1, p2)`) là nhờ tính năng nào của trình biên dịch?",
    options: [
      "Upcasting.",
      "Type Erasure.",
      "Type Inference (Suy luận kiểu).",
      "Autoboxing.",
    ],
    answer: 2,
    explanation:
      "Trình biên dịch có thể suy luận kiểu cần thiết nếu bạn bỏ qua việc chỉ định rõ ràng tham số kiểu [14].",
  },
  {
    id: 1851,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu bạn có `<T extends Number & Comparable<T>>`, bạn có thể thêm giới hạn `Serializable` vào bằng cách nào?",
    options: [
      "`<T extends Number & Comparable<T> | Serializable>`",
      "`<T extends Number, Comparable<T>, Serializable>`",
      "`<T extends Number & Comparable<T> & Serializable>`",
      "Không thể thêm nữa.",
    ],
    answer: 2,
    explanation:
      "Sử dụng toán tử `&` để thêm các giới hạn interface khác [29, 30].",
  },
  {
    id: 1852,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard (`? extends T`) thường được sử dụng trong các tình huống nào liên quan đến Collection?",
    options: [
      "Đọc dữ liệu từ Collection (Consumers).",
      "Ghi dữ liệu vào Collection (Producers).",
      "Khi Collection chỉ chứa kiểu `Object`.",
      "Khi Collection chỉ chứa kiểu `String`.",
    ],
    answer: 0,
    explanation:
      "Upper Bounded Wildcard được sử dụng cho các hoạt động đọc (read operations) [24, 44].",
  },
  {
    id: 1853,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard (`? super T`) thường được sử dụng trong các tình huống nào liên quan đến Collection?",
    options: [
      "Khi Collection là nguồn dữ liệu (Source).",
      "Khi Collection là đích đến (Destination/Sink) cho việc ghi dữ liệu.",
      "Chỉ để so sánh các phần tử.",
      "Chỉ để tính kích thước.",
    ],
    answer: 1,
    explanation:
      "Lower Bounded Wildcard được sử dụng cho các hoạt động ghi/chèn (insert/write) [26].",
  },
  {
    id: 1854,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về Generics Type Parameters so với các kiểu mảng truyền thống?",
    options: [
      "Generics cho phép sử dụng Primitive Types.",
      "Generics không hỗ trợ đa hình giữa các kiểu tham số hóa có quan hệ kế thừa.",
      "Generics yêu cầu sử dụng toán tử `>` để so sánh.",
      "Generics chỉ dùng cho các phương thức tĩnh.",
    ],
    answer: 1,
    explanation:
      "Generics không có mối quan hệ kế thừa giữa các kiểu Generics khác nhau [18, 20].",
  },
  {
    id: 1855,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của việc sử dụng ký hiệu kim cương `<>` trong Java là để giảm bớt sự lặp lại của gì?",
    options: [
      "Từ khóa `class`.",
      "Tên Class (tham số hóa) ở phía bên phải (khởi tạo).",
      "Tên phương thức `main()`.",
      "Từ khóa `public`.",
    ],
    answer: 1,
    explanation:
      "Ký hiệu kim cương cho phép trình biên dịch suy luận kiểu, giúp tránh lặp lại tên kiểu ở phía bên phải [10].",
  },
  {
    id: 1856,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn khai báo `List<? extends T>`, bạn có thể thêm đối tượng nào vào list (ngoại trừ null)?",
    options: [
      "Kiểu T.",
      "Bất kỳ kiểu nào.",
      "Không đối tượng nào.",
      "Chỉ các kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Upper Bounded Wildcard ngăn chặn các hoạt động ghi/chèn để đảm bảo Type Safety [24, 44].",
  },
  {
    id: 1857,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào cho phép truy cập (read) các phần tử như kiểu `Object` và không cho phép chèn (write) các phần tử (trừ null)?",
    options: [
      "Lower-bounded wildcard.",
      "Upper-bounded wildcard.",
      "Unbounded wildcard.",
      "Không có Wildcard nào.",
    ],
    answer: 2,
    explanation:
      "Unbounded wildcard (`List<?>`) giới hạn hoạt động chỉ ở mức `Object` (chủ yếu là đọc) và ngăn chặn việc chèn [22, 44].",
  },
  {
    id: 1858,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Type `<T extends Comparable<T>>`, nếu bạn cố gắng sử dụng toán tử `>` (ví dụ: `smallest > a[i]`), điều gì sẽ xảy ra?",
    options: [
      "Lỗi biên dịch, vì `>` không áp dụng cho các đối tượng.",
      "Lỗi runtime.",
      "Nó được chuyển đổi thành `compareTo()`.",
      "Nó được chuyển đổi thành `equals()`.",
    ],
    answer: 0,
    explanation:
      "Toán tử `>` chỉ áp dụng cho Primitive Types, không thể sử dụng để so sánh đối tượng Generics. Cần sử dụng `compareTo()` [31].",
  },
  {
    id: 1859,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích chính của việc sử dụng Generics là để tránh lỗi nào sau đây?",
    options: [
      "Lỗi logic.",
      "Lỗi liên quan đến sự an toàn kiểu ở thời điểm chạy.",
      "Lỗi vòng lặp vô hạn.",
      "Lỗi cú pháp.",
    ],
    answer: 1,
    explanation:
      "Generics được thiết kế để giải quyết vấn đề ClassCastException và lỗi kiểu ở thời điểm chạy (runtime error) [3, 4, 35].",
  },
  {
    id: 1860,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu `T` là tham số kiểu không có giới hạn, kiểu ngầm định mà nó kế thừa là gì?",
    options: ["String", "Wrapper Class", "Comparable", "Object"],
    answer: 3,
    explanation:
      "Mọi class trong Java đều là lớp con của `Object` [49]. Nếu không có giới hạn, kiểu mặc định là `Object`.",
  },
  {
    id: 1861,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard, nếu bạn gọi `list.clear()`, hoạt động này có phụ thuộc vào kiểu phần tử không?",
    options: [
      "Có, vì nó xóa các đối tượng.",
      "Không, vì `clear()` là một phương thức độc lập với kiểu phần tử.",
      "Chỉ nếu list là `LinkedList`.",
      "Chỉ nếu list là `HashMap`.",
    ],
    answer: 1,
    explanation:
      "Unbounded wildcard hữu ích khi code sử dụng các phương thức không phụ thuộc vào tham số kiểu, ví dụ: `List.clear()` [22].",
  },
  {
    id: 1862,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì KHÔNG thể được sử dụng làm ràng buộc trong Bounded Type?",
    options: [
      "Một Class cụ thể.",
      "Một Interface cụ thể.",
      "Một Primitive Type cụ thể.",
      "Một Wrapper Class.",
    ],
    answer: 2,
    explanation:
      "Primitive Type không thể là tham số kiểu Generics hay BoundingType [11].",
  },
  {
    id: 1863,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics là cơ chế cho phép tái sử dụng cùng một đoạn mã bằng cách chấp nhận gì làm đầu vào?",
    options: ["Các giá trị.", "Các biến.", "Các kiểu.", "Các con trỏ."],
    answer: 2,
    explanation:
      "Tham số kiểu chấp nhận các kiểu (classes, interface...) làm đầu vào [1].",
  },
  {
    id: 1864,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard được sử dụng để làm việc với các kiểu con của một kiểu được chỉ định. Đây được gọi là mối quan hệ nào?",
    options: ["Contravariance.", "Invariance.", "Covariance.", "Polymorphism."],
    answer: 2,
    explanation:
      "Upper Bounded Wildcard cho phép sử dụng kiểu con, thể hiện Covariance trong hệ thống Generics.",
  },
  {
    id: 1865,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard được sử dụng để làm việc với các kiểu cha của một kiểu được chỉ định. Đây được gọi là mối quan hệ nào?",
    options: ["Contravariance.", "Invariance.", "Covariance.", "Monovariance."],
    answer: 0,
    explanation:
      "Lower Bounded Wildcard cho phép sử dụng kiểu cha, thể hiện Contravariance trong hệ thống Generics.",
  },
  {
    id: 1866,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi bạn khai báo `List<Number> list = new ArrayList<Integer>();`, điều gì xảy ra?",
    options: [
      "Lỗi biên dịch do không có mối quan hệ kế thừa giữa các kiểu Generics.",
      "Hợp lệ do Autoboxing.",
      "Lỗi runtime.",
      "Hợp lệ do Upcasting.",
    ],
    answer: 0,
    explanation:
      "Mối quan hệ kế thừa không tồn tại giữa các kiểu Generics khác nhau [18, 20].",
  },
  {
    id: 1867,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là SAI về Generic Methods?",
    options: [
      "Có thể có tham số kiểu riêng (ví dụ: `<T>`).",
      "Tham số kiểu của nó phải đứng sau kiểu trả về.",
      "Phạm vi tham số kiểu bị giới hạn trong phương thức.",
      "Có thể sử dụng tham số kiểu của Class nếu nó là một Generic Class.",
    ],
    answer: 1,
    explanation:
      "Tham số kiểu của Generic Method phải đứng trước kiểu trả về [13, 15].",
  },
  {
    id: 1868,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Bounded Type `<T extends BoundingType>`, nếu `BoundingType` là một Class, điều gì sẽ xảy ra nếu `T` cố gắng là một lớp không kế thừa từ `BoundingType`?",
    options: [
      "Lỗi runtime.",
      "Lỗi biên dịch.",
      "Nó được tự động ép kiểu.",
      "Nó được phép nếu `BoundingType` là `final`.",
    ],
    answer: 1,
    explanation:
      "`T` phải là kiểu con của `BoundingType`. Nếu không, sẽ gây ra lỗi biên dịch [29].",
  },
  {
    id: 1869,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi sử dụng Unbounded Wildcard `List<?>`, mục đích chính là gì?",
    options: [
      "Để loại bỏ khả năng tương thích kiểu.",
      "Để tăng tính Type Safety.",
      "Để cho phép phương thức hoạt động trên bất kỳ kiểu list nào (chủ yếu là đọc/in).",
      "Để buộc sử dụng Lower Bounded Wildcard.",
    ],
    answer: 2,
    explanation:
      "Unbounded wildcard được sử dụng khi bạn muốn phương thức làm việc với list của bất kỳ kiểu nào (ví dụ: `printList` method) [22, 36].",
  },
  {
    id: 1870,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong trường hợp nào, bạn có thể truyền một tham chiếu `List<String>` cho một tham số `List` (không có Generics)?",
    options: [
      "Không bao giờ.",
      "Chỉ khi sử dụng Wildcard.",
      "Luôn luôn, vì Type Safety chỉ kiểm tra ở compile time.",
      "Chỉ khi `List` là `ArrayList`.",
    ],
    answer: 2,
    explanation:
      "Trước khi có Generics, mọi thứ đều là `Object`, nên có thể gán mà không cần ràng buộc [3]. (Sau JDK 5, việc sử dụng không có Generics là để duy trì tương thích ngược, và cho phép gán).",
  },
  {
    id: 1871,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để khai báo một biến `ArrayList` và cho phép trình biên dịch suy luận kiểu, bạn sử dụng ký hiệu nào ở phía bên phải (khởi tạo)?",
    options: [
      "`new ArrayList<T>()`",
      "`new ArrayList<>()`",
      "`new ArrayList<Object>()`",
      "`new ArrayList<?>()`",
    ],
    answer: 1,
    explanation:
      "Sử dụng ký hiệu kim cương `<>` để kích hoạt suy luận kiểu [10].",
  },
  {
    id: 1872,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về tham số kiểu Generics khi so sánh với tham số giá trị của phương thức?",
    options: [
      "Cả hai đều chấp nhận kiểu.",
      "Cả hai đều chấp nhận giá trị.",
      "Tham số kiểu Generics chấp nhận kiểu (types).",
      "Tham số kiểu Generics chấp nhận giá trị (values).",
    ],
    answer: 2,
    explanation:
      "Tham số kiểu Generics chấp nhận kiểu (classes, interface...) [1].",
  },
  {
    id: 1873,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một hàm chỉ chấp nhận `List<Number>`, bạn nên sử dụng cú pháp nào?",
    options: [
      "`List<? extends Number>`",
      "`List<? super Number>`",
      "`List<Number>`",
      "`List<?>`",
    ],
    answer: 2,
    explanation:
      "Chỉ định rõ `List<Number>` đảm bảo rằng list phải là chính kiểu đó (không phải kiểu con hay kiểu cha) [44].",
  },
  {
    id: 1874,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Upper Bounded Wildcard, nếu giới hạn trên là một Interface, `extends` có ý nghĩa là gì?",
    options: [
      "Class must extend Interface.",
      "Class must implement Interface.",
      "Interface must extend Interface.",
      "Interface must implement Interface.",
    ],
    answer: 1,
    explanation:
      "`extends` trong Generics có nghĩa là 'extends or implements' [28].",
  },
  {
    id: 1875,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cú pháp nào sau đây giới hạn kiểu T phải là kiểu `Number` và triển khai `Comparable<T>`?",
    options: [
      "`<T super Number, Comparable<T>>`",
      "`<T extends Comparable<T> extends Number>`",
      "`<T extends Number & Comparable<T>>`",
      "`<T extends Comparable<T> | Number>`",
    ],
    answer: 2,
    explanation:
      "Sử dụng `&` cho nhiều giới hạn, và class (`Number`) phải đứng trước [29, 30].",
  },
  {
    id: 1876,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard thường được sử dụng cho các lớp con. Điều này tương tự với mối quan hệ nào trong Array?",
    options: [
      "`Animal[] animals = new Dog[19];`",
      "`Dog[] dogs = new Animal[19];`",
      "Không có mối quan hệ nào.",
      "Sử dụng `Object[]`.",
    ],
    answer: 0,
    explanation:
      "Upper Bounded Wildcard mô phỏng tính đa hình giới hạn, tương tự như việc bạn có thể gán một mảng lớp con cho tham chiếu mảng lớp cha [16].",
  },
  {
    id: 1877,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một phương thức chấp nhận `List<? super String>`, bạn có thể thêm đối tượng nào vào list đó?",
    options: ["Integer", "Object", "Number", "Dog"],
    answer: 1,
    explanation:
      "`? super String` chấp nhận `String` và các kiểu cha của `String`. `Object` là kiểu cha của `String` [49].",
  },
  {
    id: 1878,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào được sử dụng để nới lỏng các ràng buộc sao cho có thể sử dụng cùng một phương thức để in `List<Integer>` hoặc `List<String>`?",
    options: [
      "Lower-bounded wildcard.",
      "Upper-bounded wildcard.",
      "Unbounded wildcard.",
      "Bounded Type Parameter.",
    ],
    answer: 2,
    explanation:
      "Unbounded wildcard (`List<?>`) cho phép phương thức làm việc với list của bất kỳ kiểu nào (miễn là hoạt động chỉ sử dụng chức năng của Object, như in) [22, 36].",
  },
  {
    id: 1879,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi bạn khai báo `List<String> list = new ArrayList<String>();`, việc sử dụng Generics này giúp loại bỏ nhu cầu ép kiểu nào?",
    options: [
      "Ép kiểu lên (Upcasting).",
      "Ép kiểu xuống (Downcasting).",
      "Ép kiểu chéo (Cross-casting).",
      "Ép kiểu ẩn (Implicit casting).",
    ],
    answer: 1,
    explanation:
      "Khi không có Generics, bạn phải ép kiểu từ `Object` xuống `String` (Downcasting). Generics loại bỏ nhu cầu này [7, 64].",
  },
  {
    id: 1880,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là mục tiêu của việc sử dụng Generics, đặc biệt trong bối cảnh các thuật toán như sắp xếp hoặc tìm kiếm?",
    options: [
      "Giới hạn sử dụng các kiểu dữ liệu.",
      "Đảm bảo mã có thể được tái sử dụng cho các kiểu dữ liệu khác nhau.",
      "Bắt buộc sử dụng đa hình của mảng.",
      "Chỉ sử dụng các lớp có private constructor.",
    ],
    answer: 1,
    explanation:
      "Mục tiêu là làm thế nào cùng một đoạn code có thể được tái sử dụng cho các kiểu dữ liệu khác nhau [1, 45].",
  },
  {
    id: 1881,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lớp nào sau đây là lớp Wrapper, có thể được sử dụng làm tham số kiểu Generics?",
    options: ["int", "double", "Integer", "primitive"],
    answer: 2,
    explanation:
      "Wrapper classes (như Integer) được sử dụng làm tham số kiểu vì Generics không chấp nhận primitive types [11, 12].",
  },
  {
    id: 1882,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi định nghĩa một Generic Method, tham số kiểu được khai báo bằng ký hiệu `<T>` ở vị trí nào?",
    options: [
      "Sau tên phương thức và trước dấu `(`.",
      "Trước kiểu trả về.",
      "Chỉ trong thân phương thức.",
      "Trong danh sách tham số của phương thức.",
    ],
    answer: 1,
    explanation:
      "Tham số kiểu xuất hiện trước kiểu trả về của phương thức [13, 15].",
  },
  {
    id: 1883,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard được sử dụng để đọc từ Collection. Nếu bạn muốn viết vào Collection (insert), bạn nên sử dụng Wildcard nào?",
    options: ["`<?>`", "`? extends T`", "`? super T`", "`<T>`"],
    answer: 2,
    explanation:
      "Lower Bounded Wildcard (`? super T`) được sử dụng cho các hoạt động ghi (write operations) [26].",
  },
  {
    id: 1884,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi khai báo Generics, lý do chính khiến các Primitive Types không được phép là gì?",
    options: [
      "Chúng không thể được sử dụng trong Array.",
      "Chúng không phải là đối tượng (Object).",
      "Chúng không thể được ép kiểu.",
      "Chúng không hỗ trợ Autoboxing.",
    ],
    answer: 1,
    explanation:
      "Generics yêu cầu tham số kiểu phải là class hoặc interface [11]. Primitive types không phải là Object [23].",
  },
  {
    id: 1885,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Bounded Types, nếu giới hạn là `Comparable` (một Interface), từ khóa `extends` chỉ ra điều gì?",
    options: [
      "Tính kế thừa.",
      "Tính đa hình.",
      "Tính triển khai.",
      "Tính tĩnh.",
    ],
    answer: 2,
    explanation:
      "`extends` có nghĩa là 'extends or implements' [28]. Vì `Comparable` là interface, nó chỉ ra tính triển khai.",
  },
  {
    id: 1886,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một phương thức chấp nhận tham số `List<? extends Animal> list`, list nào sau đây là hợp lệ để truyền vào?",
    options: ["List<Object>", "List<Integer>", "List<Dog>", "List<String>"],
    answer: 2,
    explanation:
      "Upper Bounded Wildcard chấp nhận `Animal` và các lớp con của nó, ví dụ: `Dog` [24, 57].",
  },
  {
    id: 1887,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là ĐÚNG về Unbounded Wildcard (`List<?>`)?",
    options: [
      "Chỉ cho phép thêm Object.",
      "Chỉ cho phép xóa (remove) phần tử.",
      "Cho phép đọc phần tử như kiểu `Object`.",
      "Cho phép thêm String.",
    ],
    answer: 2,
    explanation:
      "Unbounded wildcard giới hạn thao tác ở cấp độ Object, chủ yếu cho phép đọc [22].",
  },
  {
    id: 1888,
    topic: "Generics & Collections",
    type: "radio",
    question: "Lợi ích nào sau đây được gọi là Type Safety trong Generics?",
    options: [
      "Tăng hiệu suất truy cập bộ nhớ Heap.",
      "Ngăn chặn việc đưa nhầm kiểu dữ liệu vào Collection ở thời điểm biên dịch.",
      "Giảm thiểu việc sử dụng `static`.",
      "Tự động sắp xếp các phần tử.",
    ],
    answer: 1,
    explanation:
      "Type Safety là việc ngăn chặn lỗi kiểu dữ liệu ở compile-time [2, 3].",
  },
  {
    id: 1889,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Type, nếu bạn muốn so sánh đối tượng, bạn nên sử dụng phương thức nào trên kiểu `T extends Comparable<T>`?",
    options: ["`equals()`", "`compare()`", "`compareTo()`", "`get()`"],
    answer: 2,
    explanation:
      "Khi T triển khai `Comparable`, bạn sử dụng `compareTo()` để so sánh [29, 31, 58].",
  },
  {
    id: 1890,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Generic Method, lý do nào cho phép bạn bỏ qua việc chỉ định tham số kiểu khi gọi phương thức?",
    options: [
      "Luật Polymorphism.",
      "Suy luận kiểu của trình biên dịch.",
      "Tính năng Autoboxing.",
      "Sử dụng Wildcard.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch có thể suy luận kiểu cần thiết khi gọi Generic Method [14].",
  },
  {
    id: 1891,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo chấp nhận `List<? super Number>`, list nào sau đây là KHÔNG hợp lệ?",
    options: [
      "List<Number>",
      "List<Object>",
      "List<Integer>",
      "List<Serializable>",
    ],
    answer: 2,
    explanation:
      "`? super Number` chấp nhận `Number` và các kiểu cha. `Integer` là lớp con, không phải lớp cha [26].",
  },
  {
    id: 1892,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về việc gán giữa các kiểu Generic có quan hệ kế thừa (ví dụ: `List<A>` và `List<B>`)?",
    options: [
      "Gán là luôn luôn hợp lệ.",
      "Gán là luôn luôn bị cấm nếu không có Wildcard.",
      "Gán chỉ hợp lệ nếu A là interface.",
      "Gán chỉ hợp lệ nếu B là interface.",
    ],
    answer: 1,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau [18, 20].",
  },
  {
    id: 1893,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Ký hiệu `<T>` được sử dụng trong khai báo Generics là viết tắt của gì?",
    options: ["Table", "Template", "Type", "Token"],
    answer: 2,
    explanation: "T là quy ước cho Type (kiểu chung) [33].",
  },
  {
    id: 1894,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, từ khóa `extends` trong Bounded Types được sử dụng để thể hiện mối quan hệ 'is-a' nào?",
    options: [
      "Chỉ Class extends Class.",
      "Chỉ Interface extends Interface.",
      "Class extends Class HOẶC Class implements Interface.",
      "Chỉ Class implements Interface.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `extends` trong Generics có nghĩa là 'extends or implements' (is-a) [27, 28].",
  },
  {
    id: 1895,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Unbounded Wildcard, nếu bạn cố gắng gọi một phương thức tùy chỉnh của đối tượng, điều gì xảy ra?",
    options: [
      "Lỗi runtime ClassCastException.",
      "Lỗi biên dịch.",
      "Phương thức đó được thực thi bình thường.",
      "Nó được tự động chuyển sang phương thức `equals()`.",
    ],
    answer: 1,
    explanation:
      "Unbounded Wildcard chỉ cho phép bạn truy cập các phương thức trong `Object` class. Gọi phương thức khác sẽ gây ra lỗi biên dịch [22, 39].",
  },
  {
    id: 1896,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard được sử dụng để giới hạn kiểu không xác định là kiểu cha (supertype) của một kiểu cụ thể. Điều này mang lại sự linh hoạt tối đa cho hoạt động nào?",
    options: [
      "Đọc các thuộc tính riêng tư.",
      "Sắp xếp Collection.",
      "Chèn/Ghi dữ liệu (Write operations).",
      "Truy xuất dữ liệu (Read operations).",
    ],
    answer: 2,
    explanation:
      "Lower-bounded wildcard được sử dụng cho các hoạt động ghi/chèn [26].",
  },
  {
    id: 1897,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Bounded Type `<T extends BoundingType>`, nếu BoundingType là một Class, và bạn muốn thêm một Interface, bạn sử dụng ký hiệu nào?",
    options: ["`|`", "`&`", "`,`", "`extends`"],
    answer: 1,
    explanation:
      "Sử dụng `&` để thêm các giới hạn, bao gồm Interface [29, 30].",
  },
  {
    id: 1898,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Generics, nếu bạn bỏ qua tham số kiểu ở phía bên phải (`new ArrayList()`), bạn đang sử dụng cú pháp Generics nào?",
    options: [
      "Diamond operator.",
      "Raw type (Kiểu thô).",
      "Unbounded wildcard.",
      "Bounded type.",
    ],
    answer: 1,
    explanation:
      "Sử dụng Generics ở phía bên trái và bỏ qua ở phía bên phải (trước JDK 7) hoặc bỏ qua hoàn toàn cả hai bên được gọi là sử dụng raw type.",
  },
  {
    id: 1899,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mối quan hệ nào sau đây thể hiện sự thiếu kế thừa giữa các kiểu Generics khác nhau?",
    options: [
      "`List<A>` không thể gán cho `List<B>` khi A, B khác nhau.",
      "`List<A>` kế thừa từ `Object`.",
      "`List<A>` và `List<A>` là cùng kiểu.",
      "`List<A>` có thể gán cho `List<?>`.",
    ],
    answer: 0,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau [18, 20, 21].",
  },
  {
    id: 1900,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lợi ích của Generics là cho phép tái sử dụng code với các kiểu dữ liệu khác nhau. Điều này tương tự với khái niệm nào trong lập trình hàm?",
    options: [
      "Tính đa hình (Polymorphism).",
      "Tính đóng gói (Encapsulation).",
      "Tính trừu tượng (Abstraction).",
      "Tính kế thừa (Inheritance).",
    ],
    answer: 0,
    explanation:
      "Generics cho phép sử dụng code với nhiều kiểu dữ liệu, tương tự như đa hình cho phép sử dụng cùng một tham chiếu cho nhiều kiểu đối tượng khác nhau [1, 65].",
  },
  {
    id: 1901,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu bạn sử dụng kiểu `List<Integer>`, list này có thể chứa kiểu dữ liệu nào?",
    options: [
      "Integer và Object.",
      "Integer và String.",
      "Chỉ Integer.",
      "Integer, int và Object.",
    ],
    answer: 2,
    explanation:
      "Generics đảm bảo rằng chỉ có các đối tượng kiểu Integer mới được thêm vào (mặc dù `int` được tự động chuyển thành `Integer` nhờ Autoboxing) [11, 32].",
  },
  {
    id: 1902,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard được sử dụng để làm việc với các kiểu con. Khi bạn muốn làm việc với các kiểu cha, bạn nên sử dụng giới hạn nào?",
    options: ["`extends`", "`implements`", "`super`", "`<T>`"],
    answer: 2,
    explanation:
      "Lower Bounded Wildcard sử dụng từ khóa `super` để giới hạn ở phía các kiểu cha [26].",
  },
  {
    id: 1903,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cú pháp nào sau đây là KHÔNG hợp lệ cho Bounded Type?",
    options: [
      "`<T extends Comparable<T>>`",
      "`<T extends Number & Serializable>`",
      "`<T extends String & Integer>` (cả hai đều là Class)",
      "`<T extends Object>`",
    ],
    answer: 2,
    explanation:
      "Chỉ một class có thể được bao gồm trong nhiều giới hạn. `String` và `Integer` đều là class, vì vậy điều này là không hợp lệ [30].",
  },
  {
    id: 1904,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn viết một phương thức Generic để so sánh, nhưng bạn không muốn người dùng phải chỉ định kiểu khi gọi phương thức (`Util.compare(p1, p2)`), bạn sử dụng kỹ thuật nào?",
    options: [
      "Unbounded Wildcard.",
      "Lower Bounded Wildcard.",
      "Sử dụng kiểu `Object`.",
      "Dựa vào suy luận kiểu của trình biên dịch.",
    ],
    answer: 3,
    explanation:
      "Trình biên dịch sẽ tự động suy luận kiểu cần thiết khi gọi Generic Method [14].",
  },
  {
    id: 1905,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào sau đây được sử dụng khi code chỉ cần truy cập các phương thức của `Object` class?",
    options: ["`? extends T`", "`? super T`", "`<?>`", "`<T>`"],
    answer: 2,
    explanation:
      "Unbounded wildcard hữu ích khi code sử dụng các chức năng của `Object` class [22].",
  },
  {
    id: 1906,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng Bounded Type, nếu bạn muốn giới hạn kiểu `T` phải triển khai hai Interface, bạn nối chúng bằng toán tử nào?",
    options: ["`+`", "`|`", "`&`", "`:`"],
    answer: 2,
    explanation:
      "Sử dụng `&` để nối nhiều giới hạn Interface (ví dụ: `Comparable & Serializable`) [30].",
  },
  {
    id: 1907,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Upper Bounded Wildcard (`? extends T`) bị hạn chế gì liên quan đến việc thêm phần tử?",
    options: [
      "Chỉ cho phép thêm null.",
      "Chỉ cho phép thêm kiểu T.",
      "Chỉ cho phép thêm kiểu Object.",
      "Cho phép thêm bất kỳ kiểu nào.",
    ],
    answer: 0,
    explanation:
      "Upper Bounded Wildcard ngăn chặn các hoạt động ghi/chèn phần tử, chỉ cho phép thêm `null` (vì `null` là hợp lệ với mọi kiểu) [24, 44].",
  },
  {
    id: 1908,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lower Bounded Wildcard (`? super T`) được sử dụng cho mục đích nào?",
    options: [
      "Đảm bảo Collection chỉ có thể được đọc.",
      "Hạn chế Collection chỉ chứa kiểu `Object`.",
      "Chỉ cho phép Collection chứa kiểu `T` và các lớp con.",
      "Cho phép Collection chứa kiểu `T` và các lớp cha.",
    ],
    answer: 3,
    explanation:
      "Lower Bounded Wildcard giới hạn kiểu không xác định là kiểu cha (supertype) của T [26].",
  },
  {
    id: 1909,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Java Collections Framework, giao diện gốc (root interface) định nghĩa các hoạt động cơ bản mà tất cả các kiểu collection nên thực hiện là gì?",
    options: ["Map", "List", "Collection", "Set"],
    answer: 2,
    explanation:
      "Collection là một giao diện gốc (root interface) trong Java collection framework. Nó định nghĩa các hoạt động cơ bản mà tất cả các kiểu collection (như lists, sets, queues) nên triển khai [1].",
  },
  {
    id: 1910,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lợi ích chính của việc sử dụng Generics (Kiểu chung) trong Java Collections là gì?",
    options: [
      "Đảm bảo mã chạy nhanh hơn.",
      "Giới hạn Collection chỉ được lưu trữ kiểu dữ liệu nguyên thủy (primitive types).",
      "Loại bỏ nhu cầu ép kiểu (casting) liên tục và cung cấp kiểm tra lỗi kiểu ở thời điểm biên dịch (type-safety).",
      "Cho phép đa kế thừa (multiple inheritance).",
    ],
    answer: 2,
    explanation:
      "Generics giúp loại bỏ nhu cầu ép kiểu (casting) và cho phép bạn viết các collection an toàn về kiểu (type-safe), ngăn chặn việc đặt Dog vào một list of Ducks [2, 3].",
  },
  {
    id: 1911,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt cơ bản về kiến trúc giữa ArrayList và mảng (array) thông thường là gì?",
    options: [
      "ArrayList chỉ có thể lưu trữ kiểu nguyên thủy.",
      "Mảng có thể tự động thay đổi kích thước, ArrayList thì không.",
      "Mảng phải biết kích thước chính xác tại thời điểm tạo, còn ArrayList có thể tự động mở rộng và thu hẹp (grows and shrinks dynamically).",
      "ArrayList không phải là một đối tượng.",
    ],
    answer: 2,
    explanation:
      "Một mảng thông thường phải biết kích thước tại thời điểm tạo. ArrayList không cần biết kích thước, vì nó tự động phát triển và thu hẹp khi các đối tượng được thêm hoặc xóa [4].",
  },
  {
    id: 1912,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cấu trúc dữ liệu Stack, nguyên tắc nào mô tả cách các phần tử được thêm và xóa?",
    options: [
      "FIFO (First-In, First-Out)",
      "LIFO (Last-In, First-Out)",
      "Random Access",
      "Key-Value Pair",
    ],
    answer: 1,
    explanation:
      "Collection Stack đại diện cho một stack đối tượng kiểu Last-in, first-out (LIFO) [5, 6].",
  },
  {
    id: 1913,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào trong giao diện Queue chịu trách nhiệm truy xuất và loại bỏ phần tử ở đầu (head) của Queue?",
    options: ["push()", "get(0)", "poll()", "peek()"],
    answer: 2,
    explanation:
      "Phương thức poll(): truy xuất và loại bỏ phần tử ở đầu (head) của queue [7].",
  },
  {
    id: 1914,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Tại sao HashMap lại nhanh hơn ArrayList trong quá trình tìm kiếm?",
    options: [
      "HashMap lưu trữ dữ liệu trên Stack thay vì Heap.",
      "HashMap không cho phép lưu trữ đối tượng.",
      "HashMap sử dụng khóa (key) để tìm kiếm mục ngay lập tức mà không cần lặp qua tất cả các mục.",
      "ArrayList chỉ sử dụng mảng tĩnh.",
    ],
    answer: 2,
    explanation:
      "HashMap được giới thiệu để tăng tốc quá trình tìm kiếm so với ArrayList. Mục tiêu là tìm một mục trong collection một cách nhanh chóng bằng khóa mà không cần lặp qua tất cả các mục [8, 9].",
  },
  {
    id: 1915,
    topic: "Generics & Collections",
    type: "radio",
    question: "Tính năng xác định của các triển khai Set (như HashSet) là gì?",
    options: [
      "Duy trì thứ tự chèn (insertion order).",
      "Cho phép truy cập ngẫu nhiên bằng chỉ số nguyên.",
      "Đảm bảo các phần tử là duy nhất (không có bản sao).",
      "Lưu trữ dữ liệu dưới dạng cặp khóa-giá trị.",
    ],
    answer: 2,
    explanation:
      "Set là các collection không cho phép các bản sao (duplicates) [10-12].",
  },
  {
    id: 1916,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Đâu là nhược điểm chính của ArrayList so với LinkedList khi thực hiện thao tác chèn (insertion) hoặc xóa (deletion) ở giữa danh sách?",
    options: [
      "ArrayList phải dịch chuyển (shift) các phần tử còn lại để tổ chức lại chỉ số.",
      "ArrayList cần ép kiểu liên tục.",
      "ArrayList tiêu tốn ít bộ nhớ hơn.",
      "ArrayList không hỗ trợ Generics.",
    ],
    answer: 0,
    explanation:
      "Khi bạn xóa các mục khỏi một mảng (hoặc ArrayList), nó tạo ra khoảng trống kỳ lạ và bạn phải tự di chuyển các mục để lấp đầy những khoảng trống đó để tổ chức lại chỉ số [1, 13].",
  },
  {
    id: 1917,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để truy xuất một phần tử tại vị trí cụ thể trong ArrayList, phương thức nào được sử dụng?",
    options: ["get(int index)", "peek()", "indexOf(Object o)", "next()"],
    answer: 0,
    explanation:
      "Phương thức get(int index): trả về phần tử tại vị trí được chỉ định trong danh sách này [14]. List cho phép truy cập các mục bằng chỉ số nguyên của chúng [15].",
  },
  {
    id: 1918,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Queue (FIFO), phần tử nào là phần tử đầu tiên được truy cập hoặc loại bỏ?",
    options: [
      "Phần tử được thêm vào cuối cùng (Last element added).",
      "Phần tử được thêm vào đầu tiên (First element added).",
      "Phần tử có giá trị nhỏ nhất.",
      "Phần tử ở giữa.",
    ],
    answer: 1,
    explanation:
      "Queue là cấu trúc dữ liệu First-In, First-Out. Phần tử đầu tiên được thêm vào queue là phần tử đầu tiên được truy cập hoặc loại bỏ [16, 17].",
  },
  {
    id: 1919,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong HashMap, phần tử nào phải là duy nhất (unique) cho toàn bộ collection?",
    options: [
      "Giá trị (Value)",
      "Khóa (Key)",
      "Chỉ mục (Index)",
      "Tất cả các phần tử",
    ],
    answer: 1,
    explanation:
      "Trong HashMap, khóa (key) phải là duy nhất cho toàn bộ collection, giống như chỉ mục trong mảng thông thường [8, 18].",
  },
  {
    id: 1920,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn lưu trữ một danh sách các đối tượng và muốn chúng tự động được sắp xếp và không có bản sao, bạn nên sử dụng Collection nào?",
    options: ["ArrayList", "HashSet", "HashMap", "TreeSet"],
    answer: 3,
    explanation:
      "TreeSet giữ các phần tử được sắp xếp và ngăn chặn các bản sao [19-21].",
  },
  {
    id: 1921,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt về mối quan hệ kế thừa giữa các kiểu Generic là gì? Ví dụ: List<String> và List<Object>.",
    options: [
      "List<String> là lớp con của List<Object>.",
      "List<Object> là lớp con của List<String>.",
      "Không có mối quan hệ kế thừa nào giữa hai kiểu generic khác nhau.",
      "Chúng có thể được gán cho nhau nếu sử dụng Wildcard.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: Pair<Animal> không có mối quan hệ với Pair<Cat>) [22, 23]. List<Object> list_2 = list_1; (List of Strings) sẽ báo lỗi biên dịch [24].",
  },
  {
    id: 1922,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức `pollFirst()` và `pollLast()` được cung cấp bởi interface nào?",
    options: ["List", "Stack", "Queue", "Deque"],
    answer: 3,
    explanation:
      "Deque (Double-Ended Queue) cung cấp các phương thức như pollFirst() và pollLast() để truy xuất và xóa phần tử ở cả hai đầu [25].",
  },
  {
    id: 1923,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong trường hợp nào, LinkedList được ưa chuộng hơn ArrayList?",
    options: [
      "Cần truy cập ngẫu nhiên thường xuyên bằng chỉ mục.",
      "Cần các thao tác chèn và xóa ở giữa danh sách thường xuyên hơn.",
      "Cần một cấu trúc Key-Value.",
      "Cần đảm bảo dữ liệu là duy nhất.",
    ],
    answer: 1,
    explanation:
      "LinkedList có thể nhanh hơn khi bạn chèn hoặc xóa thứ gì đó khỏi giữa danh sách, mặc dù sự khác biệt thường không đáng kể trừ khi làm việc với số lượng lớn [26].",
  },
  {
    id: 1924,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cấu trúc dữ liệu nào thường được mô tả là một 'wrapper around an array' (một lớp bọc quanh mảng) để cho phép thay đổi kích thước linh hoạt?",
    options: ["LinkedList", "HashMap", "ArrayList", "TreeSet"],
    answer: 2,
    explanation:
      "ArrayList chỉ đơn giản là một lớp bọc (wrapper) quanh một mảng cho phép bạn khởi tạo biến collection mà không cần chỉ định số lượng mục [13, 15, 27].",
  },
  {
    id: 1925,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để tìm chỉ mục của lần xuất hiện đầu tiên của một phần tử trong ArrayList, bạn sử dụng phương thức nào?",
    options: [
      "search(Object o)",
      "indexOf(Object o)",
      "get(Object o)",
      "contains(Object o)",
    ],
    answer: 1,
    explanation:
      "Phương thức indexOf(Object o) trả về chỉ mục của lần xuất hiện đầu tiên của phần tử được chỉ định trong danh sách, hoặc -1 nếu không tìm thấy [28].",
  },
  {
    id: 1926,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "LIFO (Last-In, First-Out) là cơ chế cơ bản cho loại ứng dụng nào sau đây?",
    options: [
      "Hệ thống xếp hàng xử lý yêu cầu (Job scheduling).",
      "Hệ thống email (đọc email mới nhất trước).",
      "Truy cập bản ghi cơ sở dữ liệu bằng ID.",
      "Danh sách sinh viên theo thứ tự tên.",
    ],
    answer: 1,
    explanation:
      "Ví dụ về khi Stack hữu ích là khi phát triển hệ thống email, nơi email mới nhất được thêm vào đỉnh của stack để người dùng đọc email đó trước [29].",
  },
  {
    id: 1927,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt chính giữa phương thức `pop()` và `peek()` trong Stack là gì?",
    options: [
      "pop() không trả về giá trị, peek() thì có.",
      "peek() luôn gây ra ngoại lệ, pop() thì không.",
      "pop() loại bỏ đối tượng ở đỉnh, peek() trả về đối tượng ở đỉnh mà không loại bỏ nó.",
      "peek() chỉ hoạt động với String.",
    ],
    answer: 2,
    explanation:
      "pop(): loại bỏ đối tượng ở đỉnh của stack và trả về đối tượng đó. peek(): trả về đối tượng ở đỉnh mà không loại bỏ nó khỏi stack [5].",
  },
  {
    id: 1928,
    topic: "Generics & Collections",
    type: "radio",
    question: "Deque là viết tắt của thuật ngữ nào?",
    options: [
      "Double Entry Queue",
      "Dynamic Element Queue",
      "Double-Ended Queue",
      "Data Extractor Queue",
    ],
    answer: 2,
    explanation:
      "Deque là một loại Queue đặc biệt, đặc biệt là một double-ended queue (queue hai đầu) [16, 17].",
  },
  {
    id: 1929,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, nếu bạn muốn tìm một cuốn sách theo mã ISBN, ISBN sẽ đóng vai trò gì?",
    options: [
      "Giá trị (Value)",
      "Chỉ mục mảng (Array Index)",
      "Khóa (Key)",
      "Iterator",
    ],
    answer: 2,
    explanation:
      "Trong ví dụ về thư viện, ISBN được sử dụng làm String key để tìm kiếm sách trong HashMap một cách nhanh chóng [30, 31].",
  },
  {
    id: 1930,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để thêm một cặp Key-Value vào HashMap?",
    options: [
      "add(key, value)",
      "insert(key, value)",
      "push(key, value)",
      "put(key, value)",
    ],
    answer: 3,
    explanation: "Để thêm các mục vào HashMap, sử dụng phương thức put() [30].",
  },
  {
    id: 1931,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để một HashSet hoạt động chính xác trong việc ngăn chặn các bản sao, điều gì cần được đảm bảo đối với các đối tượng được lưu trữ?",
    options: [
      "Chúng phải là kiểu nguyên thủy.",
      "Chúng phải triển khai giao diện Serializable.",
      "Các phương thức hashCode() và equals() phải được ghi đè (override) chính xác.",
      "Chúng phải được khai báo là final.",
    ],
    answer: 2,
    explanation:
      "Khi bạn đặt một đối tượng vào HashSet, nó sử dụng giá trị hashcode của đối tượng và so sánh với hashcode của các đối tượng khác để kiểm tra trùng lặp. Việc ghi đè hashCode() và equals() là cần thiết để HashSet kiểm tra bản sao [32, 33].",
  },
  {
    id: 1932,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Kiểu wildcard nào sau đây được sử dụng để chỉ định một tham số kiểu có thể là bất kỳ kiểu nào (unbounded wildcard)?",
    options: ["<T>", "<?>", "<? extends Object>", "<? super T>"],
    answer: 1,
    explanation:
      "Kiểu wildcard không giới hạn được chỉ định bằng ký tự wildcard '?' (ví dụ: List<?>) [34, 35].",
  },
  {
    id: 1933,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi nào thì nên sử dụng LinkedList thay vì ArrayList cho các Collection lớn?",
    options: [
      "Khi cần tìm kiếm một phần tử ngẫu nhiên nhanh chóng.",
      "Khi cần lưu trữ một số lượng cố định các phần tử.",
      "Khi cần thường xuyên thêm và xóa các phần tử khỏi hai đầu.",
      "Khi cần sắp xếp dữ liệu hiệu quả.",
    ],
    answer: 2,
    explanation:
      "LinkedList thường được triển khai để hỗ trợ Queue và Deque, nơi các thao tác thêm và xóa thường xuyên xảy ra ở hai đầu. LinkedList cũng nhanh hơn khi chèn/xóa ở giữa [25, 26].",
  },
  {
    id: 1934,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong trường hợp nào, việc sử dụng ArrayList sẽ hiệu quả hơn LinkedList?",
    options: [
      "Đọc dữ liệu tuần tự.",
      "Chèn dữ liệu vào đầu danh sách.",
      "Thường xuyên sử dụng phương thức get(index).",
      "Xóa các mục khỏi giữa danh sách.",
    ],
    answer: 2,
    explanation:
      "ArrayList sử dụng mảng nội bộ, cho phép truy cập ngẫu nhiên nhanh chóng bằng chỉ mục (get(index)) [15, 36].",
  },
  {
    id: 1935,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của việc sử dụng `List` là gì trong API Collections?",
    options: [
      "Chỉ để lưu trữ các phần tử duy nhất.",
      "Khi thứ tự (sequence) quan trọng và cho phép các bản sao.",
      "Lưu trữ cặp khóa-giá trị.",
      "Chỉ dùng cho các phần tử không có thứ tự.",
    ],
    answer: 1,
    explanation:
      "List là một collection có thứ tự (ordered collection) [11, 15]. List cho phép các bản sao (Duplicates OK) [12].",
  },
  {
    id: 1936,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn thêm một phần tử vào Stack, bạn sẽ sử dụng phương thức nào?",
    options: ["add()", "poll()", "push()", "enqueue()"],
    answer: 2,
    explanation: "push(e Item): thêm một mục vào đỉnh của stack [5, 6].",
  },
  {
    id: 1937,
    topic: "Generics & Collections",
    type: "radio",
    question: "Interface Queue được thiết kế chủ yếu cho cấu trúc dữ liệu nào?",
    options: [
      "FIFO (First-In, First-Out)",
      "LIFO (Last-In, First-Out)",
      "Random access list",
      "Sorted set",
    ],
    answer: 0,
    explanation:
      "Queue là cấu trúc dữ liệu First-In, First-Out (FIFO) [16, 17].",
  },
  {
    id: 1938,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong HashMap, sự khác biệt của key so với index trong Array là gì?",
    options: [
      "Key không bao giờ là String.",
      "Key phải là số nguyên dương.",
      "Key có thể là bất kỳ đối tượng nào (Object) thuộc một kiểu đã xác định.",
      "Key không thể được sử dụng để truy cập phần tử.",
    ],
    answer: 2,
    explanation:
      "Khóa (key) phải là duy nhất, nhưng không giống như chỉ mục mảng, khóa có thể là bất kỳ đối tượng nào thuộc một kiểu dữ liệu [8].",
  },
  {
    id: 1939,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng thêm một bản sao (duplicate) vào HashSet?",
    options: [
      "Bản sao được thêm vào, nhưng ở vị trí cuối cùng.",
      "Nó gây ra lỗi runtime.",
      "HashSet sẽ không thêm bản sao, duy trì tính duy nhất.",
      "HashSet sẽ tự động sắp xếp lại tất cả các phần tử.",
    ],
    answer: 2,
    explanation:
      "Set là collection không cho phép các bản sao (duplicates) [11].",
  },
  {
    id: 1940,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cú pháp Generic nào được sử dụng để chỉ định tham số kiểu T phải là kiểu con của một kiểu khác (ví dụ: Animal)?",
    options: [
      "<T implements Animal>",
      "<T extends Animal>",
      "<T super Animal>",
      "<T instanceOf Animal>",
    ],
    answer: 1,
    explanation:
      "Cú pháp cho tham số kiểu bị giới hạn (Bounded type parameters) là <T extends BoundingType> [35].",
  },
  {
    id: 1941,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList triển khai giao diện nào trong Java Collections Framework?",
    options: ["Queue", "Set", "Map", "List"],
    answer: 3,
    explanation:
      "ArrayList là class phổ biến nhất triển khai giao diện List [15, 37].",
  },
  {
    id: 1942,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong ArrayList, nếu bạn muốn chèn một phần tử tại một chỉ mục cụ thể (không phải ở cuối), bạn sử dụng phương thức nào?",
    options: [
      "add(E element)",
      "add(int index, E element)",
      "insert(int index, E element)",
      "set(int index, E element)",
    ],
    answer: 1,
    explanation:
      "add(int index, E element): chèn phần tử được chỉ định vào chỉ mục được chỉ định của danh sách này [14].",
  },
  {
    id: 1943,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lợi ích của việc sử dụng phương thức `size()` trong ArrayList thay vì thuộc tính `length` trong mảng thông thường là gì?",
    options: [
      "size() trả về dung lượng tối đa.",
      "size() là một phương thức, cho phép ArrayList ẩn chi tiết triển khai nội bộ.",
      "length là static, size() là non-static.",
      "size() chỉ dùng cho String.",
    ],
    answer: 1,
    explanation:
      "Trong khi mảng thông thường có thuộc tính length, ArrayList sử dụng phương thức size() [14, 38], cho phép nó hoạt động như một đối tượng 'first-class' với hành vi được đóng gói [27].",
  },
  {
    id: 1944,
    topic: "Generics & Collections",
    type: "radio",
    question: "LinkedList là sự triển khai phổ biến của những giao diện nào?",
    options: [
      "Map và Set",
      "List, Queue, và Deque",
      "Comparable và Cloneable",
      "Iterable và Collection",
    ],
    answer: 1,
    explanation:
      "Java cung cấp một số class triển khai các giao diện Queue và Deque, phổ biến nhất trong số này là ArrayDeque hoặc LinkedList [25].",
  },
  {
    id: 1945,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nguyên tắc FIFO (First-In, First-Out) thường được sử dụng để mô phỏng điều gì?",
    options: [
      "Lịch sử duyệt web.",
      "Hoàn tác (Undo) các thao tác.",
      "Xếp hàng trong ngân hàng hoặc hệ thống xử lý tác vụ.",
      "Bộ nhớ Cache CPU.",
    ],
    answer: 2,
    explanation:
      "FIFO mô tả các cấu trúc hàng đợi, tương tự như xếp hàng trong thế giới thực [16].",
  },
  {
    id: 1946,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để kiểm tra xem Stack có trống (empty) hay không, bạn sử dụng phương thức nào?",
    options: ["size() == 0", "isEmpty()", "empty()", "isNull()"],
    answer: 2,
    explanation:
      "Phương thức empty(): kiểm tra xem stack này có trống hay không [5].",
  },
  {
    id: 1947,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong HashMap, nếu bạn sử dụng phương thức `get(key)` nhưng key không tồn tại, nó sẽ trả về giá trị gì?",
    options: [
      "Exception",
      "0 (nếu Value là Integer)",
      "null",
      "Ngoại lệ `KeyNotFoundException`",
    ],
    answer: 2,
    explanation:
      "Nếu key không tìm thấy, phương thức get() sẽ trả về null (Đây là kiến thức chung về HashMap/Map trong Java, tương tự như ví dụ tìm sách trả về null nếu không tìm thấy [31, 39]).",
  },
  {
    id: 1948,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, bạn có thể có hai khóa (keys) trỏ đến cùng một giá trị (value) không?",
    options: [
      "Có, điều này được cho phép.",
      "Không, cả khóa và giá trị đều phải là duy nhất.",
      "Chỉ khi khóa đó là String.",
      "Chỉ khi sử dụng TreeMap.",
    ],
    answer: 0,
    explanation:
      "Bạn có thể có hai khóa trỏ đến cùng một giá trị, nhưng bạn không thể có các khóa trùng lặp [12].",
  },
  {
    id: 1949,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi nào thì Set được ưu tiên sử dụng hơn List?",
    options: [
      "Khi cần duy trì một thứ tự chính xác của các phần tử.",
      "Khi cần lưu trữ các bản sao (duplicate copies) của cùng một đối tượng.",
      "Khi cần đảm bảo tính duy nhất (uniqueness) của các phần tử và thứ tự không quan trọng.",
      "Khi cần truy cập các phần tử theo chỉ mục.",
    ],
    answer: 2,
    explanation:
      "Set được sử dụng khi tính duy nhất (uniqueness) quan trọng. Set là collection không cho phép bản sao [11, 12].",
  },
  {
    id: 1950,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của việc sử dụng cú pháp `ArrayList<String>` là gì?",
    options: [
      "Bắt buộc tất cả các đối tượng bên trong phải là Object.",
      "Chỉ cho phép thêm các đối tượng String vào danh sách và loại bỏ nhu cầu ép kiểu khi truy xuất.",
      "Định nghĩa kích thước ban đầu của ArrayList.",
      "Định nghĩa rằng ArrayList chỉ có thể được sử dụng trong các phương thức static.",
    ],
    answer: 1,
    explanation:
      "Generics cho phép bạn chỉ định kiểu dữ liệu của các phần tử bạn định thêm vào ArrayList, loại bỏ nhu cầu ép kiểu (casting) [2].",
  },
  {
    id: 1951,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cấu trúc dữ liệu nào thường được gọi là 'Ordered Collection' (Collection có thứ tự)?",
    options: ["Set", "Map", "List", "Iterator"],
    answer: 2,
    explanation:
      "List trong Java là một giao diện hoạt động tương tự như một mảng, đó là một collection có thứ tự (ordered collection), còn được gọi là sequence [1, 15].",
  },
  {
    id: 1952,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào của ArrayList cho phép bạn kiểm tra xem một đối tượng có tồn tại trong danh sách hay không, thay vì sử dụng vòng lặp?",
    options: [
      "isEmpty()",
      "remove(Object o)",
      "contains(Object o)",
      "get(int index)",
    ],
    answer: 2,
    explanation:
      "contains(Object o): trả về true nếu danh sách này chứa phần tử được chỉ định [14]. Thay vì dùng vòng lặp, bạn có thể kiểm tra xem một đối tượng có trong danh sách hay không bằng cách dùng indexOf(Object o) [5, 28].",
  },
  {
    id: 1953,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi nào việc sử dụng ArrayList trở nên kém hiệu quả hơn so với LinkedList?",
    options: [
      "Khi cần truy cập phần tử ở đầu hoặc cuối danh sách.",
      "Khi dữ liệu chủ yếu là đọc (read-only).",
      "Khi cần thường xuyên chèn hoặc xóa các phần tử ở giữa danh sách (middle insertions/deletions).",
      "Khi kích thước của danh sách là cố định.",
    ],
    answer: 2,
    explanation:
      "LinkedList có thể nhanh hơn khi bạn chèn hoặc xóa thứ gì đó khỏi giữa danh sách [26].",
  },
  {
    id: 1954,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để tìm kiếm một đối tượng trong Stack và trả về vị trí của nó (dựa trên 1 là vị trí gần đỉnh nhất), bạn sử dụng phương thức nào?",
    options: [
      "indexOf(Object o)",
      "search(Object o)",
      "contains(Object o)",
      "find(Object o)",
    ],
    answer: 1,
    explanation:
      "search(Object o): tìm kiếm một đối tượng trong stack và trả về vị trí của nó [29].",
  },
  {
    id: 1955,
    topic: "Generics & Collections",
    type: "radio",
    question: "Phương thức nào được sử dụng để thêm một phần tử vào Queue?",
    options: ["push()", "add(E element)", "pop()", "remove(E element)"],
    answer: 1,
    explanation: "add(E element): chèn phần tử được chỉ định vào queue [7].",
  },
  {
    id: 1956,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Map nào sau đây duy trì thứ tự mà các cặp Key-Value được chèn vào?",
    options: ["HashMap", "TreeMap", "LinkedHashMap", "Hashtable"],
    answer: 2,
    explanation:
      "LinkedHashMap giống như HashMap thông thường, ngoại trừ nó có thể ghi nhớ thứ tự mà các phần tử (cặp tên/giá trị) được chèn vào [21, 40].",
  },
  {
    id: 1957,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Tại sao việc tìm kiếm trong HashMap lại nhanh hơn so với việc tìm kiếm tuần tự trong ArrayList?",
    options: [
      "HashMap chỉ lưu trữ các String.",
      "HashMap sử dụng Object class cho tất cả các hoạt động.",
      "HashMap tránh phải lặp qua tất cả các mục (saving valuable runtime).",
      "HashMap chỉ làm việc với mảng tĩnh.",
    ],
    answer: 2,
    explanation:
      "Mục tiêu của HashMap là tìm một mục trong collection một cách nhanh chóng mà không cần lặp qua tất cả các mục, giúp tiết kiệm thời gian chạy quý giá [8].",
  },
  {
    id: 1958,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu hai đối tượng được coi là bằng nhau (`a.equals(b)` trả về true), thì theo Java Object Law, điều gì phải đúng về `hashCode()` của chúng?",
    options: [
      "Chúng phải có hashcode khác nhau.",
      "Chúng không bắt buộc phải có hashcode giống nhau.",
      "Chúng PHẢI có hashcode giống nhau (`a.hashCode() == b.hashCode()`).",
      "Chỉ khi chúng là String.",
    ],
    answer: 2,
    explanation:
      "Quy tắc của Java Object Law: Nếu hai đối tượng bằng nhau, chúng PHẢI có hashcodes khớp nhau [33, 41].",
  },
  {
    id: 1959,
    topic: "Generics & Collections",
    type: "radio",
    question: "Kiểu wildcard `List<? extends Animal>` cho phép điều gì?",
    options: [
      "Chỉ chấp nhận List<Object>.",
      "Chỉ chấp nhận List<Animal>.",
      "Chấp nhận List<Animal> hoặc bất kỳ List nào có kiểu là lớp con của Animal (ví dụ: List<Dog>).",
      "Chỉ chấp nhận List<Dog>.",
    ],
    answer: 2,
    explanation:
      "Wildcard Pair<? extends Animal> được sử dụng để tạo một kiểu Pair có thể hoạt động với một kiểu con (subtype) của Animal [22, 42]. Wildcard `? extends T` chỉ định giới hạn trên (upper bound) [22, 42].",
  },
  {
    id: 1960,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì sẽ xảy ra nếu bạn không sử dụng Generics khi làm việc với Collections (ví dụ: List list = new ArrayList();)?",
    options: [
      "Bạn sẽ bị cấm sử dụng bất kỳ đối tượng nào.",
      "Các đối tượng được truy xuất sẽ mặc định là kiểu Object, yêu cầu phải ép kiểu thủ công.",
      "Nó gây ra lỗi runtime nghiêm trọng.",
      "Bạn chỉ có thể thêm kiểu dữ liệu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Khi không có generics, các đối tượng được thêm vào List sẽ được coi là Object, và bạn cần ép kiểu thủ công khi lấy chúng ra: String s = (String) list.get(0) [2, 43].",
  },
  {
    id: 1961,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList được đặt tên là một 'enhanced datatype' (kiểu dữ liệu nâng cao) vì lý do nào sau đây?",
    options: [
      "Nó là một kiểu nguyên thủy.",
      "Nó kết hợp các biến với nhau để làm cho mã có ý nghĩa.",
      "Nó cung cấp các phương thức mạnh mẽ làm cho việc làm việc với mảng đơn giản hơn nhiều.",
      "Nó chỉ có thể được tạo trong phương thức main().",
    ],
    answer: 2,
    explanation:
      "ArrayList cung cấp các phương thức thực sự mạnh mẽ giúp cho việc làm việc với mảng trở nên đơn giản hơn nhiều [14].",
  },
  {
    id: 1962,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong ArrayList, phương thức `clear()` có chức năng gì?",
    options: [
      "Đặt tất cả các phần tử thành null.",
      "Xóa một phần tử cụ thể.",
      "Xóa toàn bộ danh sách.",
      "Trả về kích thước của danh sách.",
    ],
    answer: 2,
    explanation: "clear(): xóa toàn bộ danh sách [28].",
  },
  {
    id: 1963,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Java, LinkedList được xây dựng dựa trên cấu trúc dữ liệu cơ bản nào?",
    options: [
      "Heap",
      "Mảng tĩnh (Static array)",
      "Danh sách liên kết (Linked list)",
      "Hash table",
    ],
    answer: 2,
    explanation:
      "Mặc dù nguồn không mô tả chi tiết việc triển khai nội bộ, tên 'LinkedList' ngụ ý nó được xây dựng dựa trên danh sách liên kết, cho phép thao tác chèn/xóa ở giữa nhanh hơn so với ArrayList (dựa trên mảng) [26].",
  },
  {
    id: 1964,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "FIFO (First-In, First-Out) là nguyên tắc cơ bản cho cấu trúc dữ liệu nào?",
    options: ["Stack", "Map", "Queue", "Set"],
    answer: 2,
    explanation: "Queue là cấu trúc dữ liệu First-In, First-Out [16, 17].",
  },
  {
    id: 1965,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào trong Queue (hoặc Deque) được sử dụng để chèn một phần tử vào đầu (front) của queue?",
    options: [
      "addLast(E element)",
      "push(E element)",
      "addFirst(E element)",
      "poll()",
    ],
    answer: 2,
    explanation:
      "addFirst(E element): chèn phần tử được chỉ định vào đầu (front) của queue [16].",
  },
  {
    id: 1966,
    topic: "Generics & Collections",
    type: "radio",
    question: "Một ứng dụng của HashMap trong thực tế là gì?",
    options: [
      "Sắp xếp danh sách tên học sinh.",
      "Quản lý lịch sử hoàn tác các hành động (Undo stack).",
      "Lưu trữ dữ liệu hồ sơ nhân viên và truy cập bằng ID nhân viên (Employee ID).",
      "Đảm bảo duy nhất các phần tử.",
    ],
    answer: 2,
    explanation:
      "HashMap lý tưởng cho việc truy cập dữ liệu nhanh chóng bằng một key duy nhất, ví dụ: tìm kiếm sách bằng ISBN [31, 39] hoặc tìm kiếm hồ sơ bằng ID.",
  },
  {
    id: 1967,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, nếu bạn thêm một key đã tồn tại với một value mới, điều gì xảy ra?",
    options: [
      "Nó tạo ra một cặp Key-Value trùng lặp.",
      "Nó gây ra lỗi runtime.",
      "Giá trị cũ bị ghi đè (overwritten) bởi giá trị mới.",
      "Nó tự động chuyển thành Set.",
    ],
    answer: 2,
    explanation:
      "Map không cho phép khóa trùng lặp. Việc gọi put() với một khóa đã tồn tại sẽ cập nhật (ghi đè) giá trị liên quan đến khóa đó (Đây là kiến thức Map chuẩn, được hỗ trợ bởi quy tắc không cho phép khóa trùng lặp [12]).",
  },
  {
    id: 1968,
    topic: "Generics & Collections",
    type: "radio",
    question: "Nếu hai đối tượng có cùng hashcode, điều gì phải đúng?",
    options: [
      "Chúng PHẢI bằng nhau (`equals` trả về true).",
      "Chúng KHÔNG bắt buộc phải bằng nhau.",
      "Chúng phải là các String literal.",
      "Chúng không thể được lưu trữ trong HashSet.",
    ],
    answer: 1,
    explanation:
      "Nếu hai đối tượng có cùng hashcode, chúng KHÔNG bắt buộc phải bằng nhau. Nhưng nếu chúng bằng nhau, chúng PHẢI có cùng hashcode [33, 41].",
  },
  {
    id: 1969,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sử dụng cú pháp `List<?>` (unbounded wildcard) hữu ích trong trường hợp nào?",
    options: [
      "Khi bạn cần thêm một phần tử cụ thể vào danh sách.",
      "Khi bạn đang viết một phương thức chỉ có thể được thực hiện bằng cách sử dụng chức năng được cung cấp bởi lớp Object.",
      "Khi bạn cần thay đổi kiểu dữ liệu của List tại runtime.",
      "Khi bạn muốn List chỉ chấp nhận kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Một trường hợp mà wildcard không giới hạn hữu ích là khi bạn đang viết một phương thức có thể được triển khai bằng cách sử dụng chức năng được cung cấp bởi lớp Object [34].",
  },
  {
    id: 1970,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi khai báo một biến `List` (giao diện) và gán nó cho một thể hiện `ArrayList` (lớp), đây là một ví dụ về tính chất nào của OOP?",
    options: [
      "Đóng gói (Encapsulation)",
      "Trừu tượng (Abstraction)",
      "Đa hình (Polymorphism)",
      "Kế thừa (Inheritance)",
    ],
    answer: 2,
    explanation:
      "ArrayList triển khai giao diện List, vì vậy bạn có thể truyền một ArrayList cho một phương thức được khai báo để chấp nhận List (nhờ tính đa hình) [44]. Đây là việc sử dụng tham chiếu kiểu siêu lớp (supertype reference) cho đối tượng kiểu lớp con (subclass object) [45].",
  },
  {
    id: 1971,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList cho phép truy cập ngẫu nhiên (random access) thông qua chỉ mục. Cơ chế nào làm cho việc truy cập này trở nên nhanh chóng?",
    options: [
      "Sử dụng các con trỏ nội bộ.",
      "Sử dụng mảng (array) nội bộ.",
      "Sử dụng cấu trúc cây (tree structure).",
      "Sử dụng thuật toán LIFO.",
    ],
    answer: 1,
    explanation:
      "ArrayList sử dụng một mảng nội bộ (array internally) [4, 15]. Mảng cung cấp truy cập ngẫu nhiên nhanh chóng bằng cách cho phép bạn sử dụng một vị trí chỉ mục để đến bất kỳ phần tử nào trong mảng [36].",
  },
  {
    id: 1972,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Thao tác nào sau đây trong ArrayList có thể gây tốn kém chi phí (expensive) nhất về mặt hiệu suất?",
    options: [
      "Gọi size().",
      "Gọi get(int index) cho phần tử ở giữa.",
      "Gọi add(E element) vào cuối danh sách.",
      "Gọi remove(0) (xóa phần tử đầu tiên).",
    ],
    answer: 3,
    explanation:
      "Xóa phần tử ở đầu (index 0) buộc tất cả các phần tử còn lại phải dịch chuyển để tổ chức lại chỉ số, đây là một thao tác tốn kém [1, 13].",
  },
  {
    id: 1973,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "LinkedList là một triển khai phổ biến cho giao diện nào trong Java Collections Framework?",
    options: ["Map", "Set", "List", "Queue"],
    answer: 3,
    explanation:
      "LinkedList là một trong những class phổ biến nhất triển khai giao diện Queue và Deque [25, 46].",
  },
  {
    id: 1974,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong bối cảnh hệ thống xếp hàng (Queue), phương thức nào được sử dụng để truy xuất phần tử ở đầu hàng (head) nhưng KHÔNG loại bỏ nó khỏi hàng đợi?",
    options: ["getHead()", "peek()", "poll()", "pop()"],
    answer: 1,
    explanation:
      "peek(): trả về đối tượng ở đỉnh mà không loại bỏ nó khỏi stack [5]. (Trong Queue/Deque, `peek()` cũng dùng để xem phần tử ở đầu mà không loại bỏ, tương tự như trong Stack).",
  },
  {
    id: 1975,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mối quan hệ giữa HashMap và Hashtable là gì?",
    options: [
      "Hashtable là phiên bản mới của HashMap.",
      "Cả hai đều triển khai giao diện Map.",
      "HashMap là Set, Hashtable là Map.",
      "Không có mối quan hệ nào.",
    ],
    answer: 1,
    explanation:
      "HashMap và Hashtable đều là các lớp trong Collection API và cả hai đều triển khai giao diện Map [21, 47].",
  },
  {
    id: 1976,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là quan trọng nhất khi sử dụng một đối tượng làm Key trong HashMap?",
    options: [
      "Đối tượng Key phải là String hoặc Integer.",
      "Đối tượng Key phải có thể so sánh được (implement Comparable).",
      "Đối tượng Key phải có triển khai hashCode() và equals() phù hợp.",
      "Đối tượng Key phải là duy nhất, nhưng không có yêu cầu đặc biệt nào về phương thức.",
    ],
    answer: 2,
    explanation:
      "Cũng giống như HashSet, Map sử dụng hashCode() và equals() để xác định vị trí của key và kiểm tra tính duy nhất. Triển khai phù hợp là rất quan trọng để tránh lỗi khi sử dụng Map [32, 33].",
  },
  {
    id: 1977,
    topic: "Generics & Collections",
    type: "radio",
    question: "Sự khác biệt chính giữa `Set` và `List` là gì?",
    options: [
      "Set cho phép truy cập ngẫu nhiên, List thì không.",
      "Set là không có thứ tự, List là có thứ tự.",
      "List không cho phép bản sao, Set thì có.",
      "Set là giao diện, List là class.",
    ],
    answer: 1,
    explanation:
      "List là collection có thứ tự (sequence) [11, 15]. Set là collection không có thứ tự (mặc dù các triển khai như TreeSet có thứ tự sắp xếp) và không cho phép bản sao [11, 47].",
  },
  {
    id: 1978,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics sử dụng cú pháp nào để chỉ định kiểu dữ liệu của các phần tử trong Collection?",
    options: ["[]", "{}", "()", "<> (Angle brackets)"],
    answer: 3,
    explanation:
      "Bạn có thể xác định kiểu dữ liệu bằng cách chỉ định nó giữa các dấu ngoặc nhọn <> khi khai báo biến ArrayList [2, 23].",
  },
  {
    id: 1979,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, nếu bạn có `ArrayList<Animal>` và `ArrayList<Dog>`, mối quan hệ kế thừa nào tồn tại giữa chúng?",
    options: [
      "Kế thừa trực tiếp.",
      "Quan hệ `instanceof`.",
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau.",
      "ArrayList<Dog> là kiểu con của ArrayList<Animal>.",
    ],
    answer: 2,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (ví dụ: Pair<Animal> và Pair<Cat>) [22, 23].",
  },
  {
    id: 1980,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của giao diện `Iterator` là gì?",
    options: [
      "Thêm các phần tử vào collection một cách nhanh chóng.",
      "Cho phép chương trình duyệt qua một collection và loại bỏ các phần tử trong quá trình lặp.",
      "Đảm bảo collection được sắp xếp.",
      "Thực hiện thuật toán băm (hashing).",
    ],
    answer: 1,
    explanation:
      "Một iterator cho phép một chương trình duyệt qua một collection và loại bỏ các phần tử khỏi nó trong quá trình lặp [31].",
  },
  {
    id: 1981,
    topic: "Generics & Collections",
    type: "radio",
    question: "ArrayList thường được mô tả là hiệu quả cho việc gì?",
    options: [
      "Đảm bảo phần tử không trùng lặp.",
      "Chèn và xóa ở giữa danh sách.",
      "Các hoạt động đọc (read operations) và truy cập ngẫu nhiên.",
      "Lưu trữ các đối tượng có thể sửa đổi.",
    ],
    answer: 2,
    explanation:
      "ArrayList sử dụng mảng nội bộ, cung cấp truy cập ngẫu nhiên nhanh chóng (fast random access) [15, 36].",
  },
  {
    id: 1982,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Thao tác nào sau đây là O(1) (thời gian hằng số) trong ArrayList lý tưởng nhất?",
    options: [
      "remove(0)",
      "add(E element) vào cuối danh sách.",
      "add(0, E element)",
      "Tìm kiếm một phần tử không có chỉ mục.",
    ],
    answer: 1,
    explanation:
      "Phương thức add(E element) thêm phần tử được chỉ định vào cuối danh sách [14]. Việc thêm vào cuối danh sách (nếu không cần thay đổi kích thước mảng nội bộ) thường là hoạt động O(1).",
  },
  {
    id: 1983,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "LinkedList được sử dụng để triển khai cấu trúc dữ liệu nào khi cần các thao tác thêm và xóa hiệu quả ở cả hai đầu?",
    options: ["Map", "Set", "Deque", "Array"],
    answer: 2,
    explanation:
      "LinkedList là một triển khai phổ biến của giao diện Deque [25], cho phép thêm hoặc xóa các phần tử từ cả hai đầu (front or back) [16].",
  },
  {
    id: 1984,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cấu trúc dữ liệu nào có thể được mô phỏng bằng cách sử dụng các phương thức `push()` và `pop()`?",
    options: ["Queue", "Stack", "List", "Map"],
    answer: 1,
    explanation:
      "Stack là collection đại diện cho một stack đối tượng LIFO, sử dụng các phương thức push() và pop() [5, 6].",
  },
  {
    id: 1985,
    topic: "Generics & Collections",
    type: "radio",
    question: "Phương thức `poll()` trong Queue có chức năng gì?",
    options: [
      "Chèn phần tử vào Queue.",
      "Truy xuất phần tử đầu mà không xóa.",
      "Truy xuất và xóa phần tử đầu (head) của Queue.",
      "Kiểm tra xem Queue có trống không.",
    ],
    answer: 2,
    explanation:
      "poll(): truy xuất và loại bỏ phần tử đầu (head) của Queue [7].",
  },
  {
    id: 1986,
    topic: "Generics & Collections",
    type: "radio",
    question: "Ưu điểm nổi bật của TreeMap so với HashMap là gì?",
    options: [
      "TreeMap cho phép khóa trùng lặp.",
      "TreeMap tiêu tốn ít bộ nhớ hơn.",
      "TreeMap tự động sắp xếp các khóa (key) theo thứ tự tự nhiên (hoặc Comparator).",
      "TreeMap cho phép giá trị null.",
    ],
    answer: 2,
    explanation:
      "TreeMap là một triển khai của SortedMap [47]. TreeMap giữ các mục được sắp xếp theo key (Tương tự như TreeSet, TreeMap đảm bảo sắp xếp theo thứ tự [19]).",
  },
  {
    id: 1987,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để tìm kiếm hiệu quả trong một tập hợp dữ liệu lớn, nơi bạn cần liên kết một định danh duy nhất (unique identifier) với một đối tượng phức tạp, bạn nên chọn cấu trúc nào?",
    options: ["ArrayList", "LinkedList", "Stack", "HashMap"],
    answer: 3,
    explanation:
      "HashMap được sử dụng để tăng tốc quá trình tìm kiếm thông qua việc sử dụng key duy nhất, đặc biệt hữu ích trong các tập dữ liệu lớn (ví dụ: mô phỏng thư viện) [8, 9, 39].",
  },
  {
    id: 1988,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn thêm tất cả các phần tử từ một List vào một HashSet, bạn có thể sử dụng phương thức nào của HashSet?",
    options: ["mergeAll()", "addAll()", "putAll()", "loadList()"],
    answer: 1,
    explanation:
      "HashSet có phương thức addAll() đơn giản có thể lấy một collection khác và sử dụng nó để điền vào HashSet [48].",
  },
  {
    id: 1989,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn khai báo `ArrayList<?>`, khi cố gắng thêm một phần tử (ví dụ: `list.add(\"'hello'\")`), điều gì sẽ xảy ra?",
    options: [
      "Nó hoạt động bình thường vì String là Object.",
      "Nó gây ra lỗi biên dịch vì bạn không thể thêm phần tử vào List với wildcard không giới hạn (trừ null).",
      "Nó gây ra lỗi runtime.",
      "Phần tử được thêm vào dưới dạng String.",
    ],
    answer: 1,
    explanation:
      "Wildcard không giới hạn (List<?>) không cho phép hoạt động thêm (add) ngoài `null` (Kiến thức mở rộng dựa trên nguyên tắc type-safety của Generics [2, 3]).",
  },
  {
    id: 1990,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của Generics là gì trong bối cảnh các thuật toán như sắp xếp (sorting) hoặc tìm kiếm (searching)?",
    options: [
      "Làm cho thuật toán phụ thuộc vào kiểu dữ liệu.",
      "Cho phép sử dụng cùng một đoạn mã cho các kiểu dữ liệu khác nhau (khả năng tái sử dụng).",
      "Buộc thuật toán phải làm việc với Object.",
      "Giảm số lượng phương thức trong API.",
    ],
    answer: 1,
    explanation:
      "Generics cho phép bạn tái sử dụng cùng một đoạn mã với các loại đầu vào khác nhau, vì hầu hết các thuật toán đều độc lập với kiểu dữ liệu của các mục (ví dụ: sắp xếp, tìm kiếm, v.v.) [49, 50].",
  },
  {
    id: 1991,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là quan trọng nhất đối với người dùng giao diện List?",
    options: [
      "Tốc độ băm (hashing speed).",
      "Kiểm soát chính xác nơi mỗi mục được chèn vào trong danh sách.",
      "Đảm bảo loại bỏ tất cả các bản sao.",
      "Khả năng truy cập dữ liệu bằng Key.",
    ],
    answer: 1,
    explanation:
      "Người dùng giao diện List có quyền kiểm soát chính xác nơi mỗi mục được chèn vào trong danh sách [15].",
  },
  {
    id: 1992,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một mảng tĩnh được coi là mảng cố định (fixed-size array), thì ArrayList được coi là gì?",
    options: [
      "Mảng không có phần tử.",
      "Mảng có thể thay đổi kích thước linh hoạt.",
      "Một chuỗi không thể sửa đổi.",
      "Một tập hợp không có thứ tự.",
    ],
    answer: 1,
    explanation:
      "ArrayList là một lớp bọc quanh mảng cho phép nó phát triển và thu hẹp khi các đối tượng được thêm vào hoặc loại bỏ [4, 27].",
  },
  {
    id: 1993,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt về chi phí hiệu suất giữa ArrayList và LinkedList trở nên rõ rệt nhất khi nào?",
    options: [
      "Chỉ mục là 0.",
      "Khi làm việc với một số lượng lớn các phần tử.",
      "Khi kích thước Collection nhỏ hơn 10.",
      "Khi Collection được sắp xếp.",
    ],
    answer: 1,
    explanation:
      "Sự khác biệt giữa chèn giữa vào LinkedList và ArrayList thường không đủ để quan tâm trừ khi bạn đang làm việc với một số lượng lớn các phần tử [26].",
  },
  {
    id: 1994,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong kịch bản nào, cơ chế LIFO của Stack được áp dụng?",
    options: [
      "In tài liệu (phải in tài liệu được gửi đến đầu tiên).",
      "Quản lý bộ nhớ đệm (Cache Management).",
      "Hoàn tác (Undo) các hành động trong ứng dụng.",
      "Hệ thống định tuyến gói dữ liệu mạng.",
    ],
    answer: 2,
    explanation:
      "Stack (LIFO) thường được sử dụng trong các hệ thống cần theo dõi lịch sử hoạt động, nơi hành động cuối cùng được thêm vào là hành động đầu tiên được hoàn tác.",
  },
  {
    id: 1995,
    topic: "Generics & Collections",
    type: "radio",
    question: "Giao diện `Queue` có thể được triển khai bằng class nào?",
    options: ["Stack", "HashMap", "LinkedList", "ArrayList"],
    answer: 2,
    explanation:
      "Java cung cấp các class triển khai Queue, phổ biến nhất là ArrayDeque hoặc LinkedList [25].",
  },
  {
    id: 1996,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Lý do chính khiến Map không triển khai giao diện Collection là gì?",
    options: [
      "Map chỉ hoạt động với String.",
      "Map là một tập hợp các cặp Key-Value, không phải là một tập hợp các đối tượng đơn lẻ.",
      "Map không thể chứa các bản sao.",
      "Map không hỗ trợ Generics.",
    ],
    answer: 1,
    explanation:
      "Map là một tập hợp Key-Value (chứa HAI đối tượng—một khóa và một giá trị), trong khi Collection là một tập hợp các đối tượng đơn lẻ [12, 51, 52].",
  },
  {
    id: 1997,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để lấy giá trị (Value) từ HashMap dựa trên khóa (Key)?",
    options: ["getValue(key)", "retrieve(key)", "get(key)", "search(key)"],
    answer: 2,
    explanation:
      "Phương thức get(key) được sử dụng để tìm một cuốn sách (value) bằng khóa (ISBN) [31, 53].",
  },
  {
    id: 1998,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng TreeMap, các phần tử phải tuân thủ quy tắc nào để được sắp xếp?",
    options: [
      "Implement Serializable.",
      "Implement RandomAccess.",
      "Implement Comparable hoặc được sắp xếp bằng Comparator.",
      "Có thể chấp nhận các bản sao.",
    ],
    answer: 2,
    explanation:
      "TreeSet (triển khai Set có sắp xếp, tương tự TreeMap là Map có sắp xếp) cần các phần tử phải có khả năng so sánh được (comparable), tức là chúng phải triển khai Comparable hoặc sử dụng Comparator [54-56].",
  },
  {
    id: 1999,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng gán `ArrayList<Dog>` cho `List<Animal>` (Giả sử Dog là lớp con của Animal)?",
    options: [
      "Biên dịch thành công (do đa hình).",
      "Lỗi biên dịch do không có mối quan hệ kế thừa giữa các kiểu generic khác nhau.",
      "Lỗi runtime.",
      "Chỉ thành công nếu sử dụng wildcard.",
    ],
    answer: 1,
    explanation:
      "Không có mối quan hệ kế thừa giữa các kiểu generic khác nhau (Pair<Animal> không phải là siêu kiểu của Pair<Cat>) [22, 23]. Cần sử dụng wildcard nếu muốn chấp nhận kiểu con [42].",
  },
  {
    id: 2000,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức `remove()` trong giao diện Iterator được sử dụng để làm gì?",
    options: [
      "Xóa tất cả các phần tử.",
      "Xóa phần tử cuối cùng đã được trả về bởi `next()` khỏi collection.",
      "Xóa phần tử đầu tiên trong collection.",
      "Chỉ hoạt động với LinkedList.",
    ],
    answer: 1,
    explanation:
      "Iterator có phương thức remove() cho phép chương trình duyệt qua collection và loại bỏ các phần tử khỏi nó trong quá trình lặp [31, 57].",
  },
  {
    id: 2001,
    topic: "Generics & Collections",
    type: "radio",
    question: "ArrayList có thể lưu trữ kiểu dữ liệu nào?",
    options: [
      "Chỉ kiểu dữ liệu nguyên thủy (primitive types).",
      "Chỉ các đối tượng (objects), không thể lưu trữ kiểu nguyên thủy trực tiếp.",
      "Cả kiểu nguyên thủy và đối tượng.",
      "Chỉ các đối tượng Integer.",
    ],
    answer: 1,
    explanation:
      "ArrayList chỉ có các phương thức add() chấp nhận tham chiếu đối tượng, không phải kiểu nguyên thủy [27, 58]. (Tuy nhiên, Java hiện đại sử dụng Autoboxing để tự động chuyển đổi giữa primitive và Wrapper Class).",
  },
  {
    id: 2002,
    topic: "Generics & Collections",
    type: "radio",
    question: "Ưu điểm nổi bật nhất của ArrayList so với mảng (array) là gì?",
    options: [
      "ArrayList cho phép sử dụng cú pháp [] để truy cập phần tử.",
      "ArrayList cung cấp các phương thức tiện ích (utility methods) và khả năng thay đổi kích thước linh hoạt.",
      "Mảng là đối tượng, ArrayList thì không.",
      "ArrayList có thể lưu trữ kiểu nguyên thủy mà không cần Wrapper.",
    ],
    answer: 1,
    explanation:
      "ArrayList là một lớp bọc quanh mảng, cung cấp các phương thức mạnh mẽ làm cho việc làm việc với mảng đơn giản hơn [14], và nó tự động điều chỉnh kích thước [4].",
  },
  {
    id: 2003,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi nào việc sử dụng LinkedList cho List operations được coi là chấp nhận được, mặc dù nó chậm hơn ArrayList cho việc truy cập ngẫu nhiên?",
    options: [
      "Khi dung lượng bộ nhớ là mối quan tâm chính.",
      "Khi các hoạt động truy cập ngẫu nhiên chiếm ưu thế.",
      "Khi số lượng phần tử là nhỏ, khiến sự khác biệt hiệu suất là không đáng kể.",
      "Khi cần đảm bảo Collection được sắp xếp.",
    ],
    answer: 2,
    explanation:
      "Đối với hầu hết các ứng dụng, sự khác biệt giữa các thao tác chèn/xóa ở giữa LinkedList và ArrayList thường không đủ để quan tâm trừ khi bạn đang làm việc với số lượng lớn các phần tử [26].",
  },
  {
    id: 2004,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào trong Stack được sử dụng để tìm vị trí của một đối tượng, với quy ước 1 là vị trí gần đỉnh nhất?",
    options: [
      "search(Object o)",
      "indexOf(Object o)",
      "get(0)",
      "contains(Object o)",
    ],
    answer: 0,
    explanation:
      "search(Object o): tìm kiếm một đối tượng trong stack và trả về vị trí của nó [29].",
  },
  {
    id: 2005,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn đảm bảo rằng việc chèn phần tử mới vào Queue không bị lỗi khi queue đầy, bạn nên sử dụng phương thức nào thay vì `add()`?",
    options: [
      "offer() (Kiến thức chung: trả về boolean)",
      "push()",
      "put()",
      "insert()",
    ],
    answer: 0,
    explanation:
      "Mặc dù nguồn chỉ đề cập đến add() và poll() [7], trong các triển khai Queue thực tế, offer() được sử dụng để chèn mà không ném ra Exception khi Queue đầy.",
  },
  {
    id: 2006,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, bạn chỉ có thể có một ánh xạ (mapping) từ một khóa cụ thể đến một giá trị. Điều này đảm bảo tính chất nào?",
    options: [
      "Tính đa hình.",
      "Tính duy nhất của Khóa (Key uniqueness).",
      "Tính duy nhất của Giá trị (Value uniqueness).",
      "Tính thứ tự.",
    ],
    answer: 1,
    explanation:
      "Map không cho phép khóa trùng lặp (NO duplicate keys) [12]. Key phải là duy nhất cho toàn bộ collection [8].",
  },
  {
    id: 2007,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "HashMap lưu trữ dữ liệu dưới dạng các đối tượng trên khu vực bộ nhớ nào?",
    options: [
      "Stack memory",
      "Static memory",
      "Heap (Vùng bộ nhớ garbage-collectible)",
      "Cache memory",
    ],
    answer: 2,
    explanation:
      "Trong Java, tất cả các đối tượng được phân bổ động trên Heap [7], bao gồm cả HashMap và các đối tượng mà nó lưu trữ [57].",
  },
  {
    id: 2008,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích chính của việc triển khai `Comparable` trên một lớp là gì?",
    options: [
      "Cho phép đối tượng được lưu vào HashMap.",
      "Đảm bảo đối tượng được tuần tự hóa (serialized).",
      "Cho phép đối tượng mô tả cách so sánh nó với các đối tượng cùng loại (natural ordering).",
      "Ngăn chặn việc ghi đè phương thức.",
    ],
    answer: 2,
    explanation:
      "Comparable là một giao diện phổ biến bao gồm phương thức CompareTo(), được sử dụng để cho phép bất kỳ lớp nào mô tả cách so sánh hai đối tượng của lớp đó với nhau [59, 60]. Điều này hữu ích khi sắp xếp [56].",
  },
  {
    id: 2009,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Làm thế nào để cho phép một phương thức Generic chấp nhận một danh sách của bất kỳ kiểu nào và in các phần tử của nó?",
    options: [
      "Sử dụng List<Object>.",
      "Sử dụng List<?> (Unbounded wildcard).",
      "Sử dụng List<T>.",
      "Sử dụng List<String>.",
    ],
    answer: 1,
    explanation:
      "Wildcard không giới hạn `List<?>` được sử dụng để chấp nhận một danh sách của bất kỳ kiểu nào và in các phần tử của nó [34, 61].",
  },
  {
    id: 2010,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Các tham số kiểu (type parameters) trong Generics chấp nhận những gì làm đầu vào?",
    options: [
      "Giá trị (values).",
      "Các kiểu (classes, interfaces, ...).",
      "Các kiểu dữ liệu nguyên thủy (primitive types).",
      "Các phương thức.",
    ],
    answer: 1,
    explanation:
      "Sự khác biệt chính là các tham số phương thức chấp nhận giá trị làm đầu vào, trong khi các tham số kiểu chấp nhận các kiểu (lớp, giao diện...) làm đầu vào [50].",
  },
  {
    id: 2011,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để truy xuất một đối tượng từ ArrayList mà không cần ép kiểu thủ công, bạn phải làm gì?",
    options: [
      "Đảm bảo đối tượng đã triển khai Serializable.",
      "Sử dụng phương thức `get(Object)`.",
      "Khai báo ArrayList bằng Generics để chỉ định kiểu dữ liệu mong muốn.",
      "Đặt ArrayList trong gói (package) `java.util`.",
    ],
    answer: 2,
    explanation:
      "Generics loại bỏ nhu cầu ép kiểu [2]. Khi sử dụng Generics, đối tượng đi ra sẽ là kiểu được chỉ định (ví dụ: Fish), không phải là Object [62].",
  },
  {
    id: 2012,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList cho phép tìm kiếm các mục bằng chỉ mục. Điều này có nghĩa là nó thuộc loại collection nào?",
    options: [
      "Unordered Collection",
      "Sequence (Collection có thứ tự)",
      "Key-Value Collection",
      "Unique Collection",
    ],
    answer: 1,
    explanation:
      "List là một collection có thứ tự (ordered collection), còn được gọi là sequence [15].",
  },
  {
    id: 2013,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt về cấu trúc nội bộ khiến LinkedList vượt trội hơn ArrayList khi thay đổi kích thước List trong môi trường nào?",
    options: [
      "Truy cập đầu cuối.",
      "Giữa danh sách.",
      "Truy cập ngẫu nhiên.",
      "Chỉ mục là 1.",
    ],
    answer: 1,
    explanation:
      "LinkedList có thể nhanh hơn khi bạn chèn hoặc xóa thứ gì đó khỏi giữa danh sách [26].",
  },
  {
    id: 2014,
    topic: "Generics & Collections",
    type: "radio",
    question: "Phương thức `pollLast()` trong Deque làm gì?",
    options: [
      "Truy xuất phần tử đầu tiên mà không xóa.",
      "Truy xuất và xóa phần tử cuối cùng của Deque.",
      "Thêm một phần tử vào cuối Deque.",
      "Chỉ xóa phần tử cuối nếu nó là null.",
    ],
    answer: 1,
    explanation:
      "pollLast(): truy xuất và loại bỏ phần tử cuối cùng của Deque [25].",
  },
  {
    id: 2015,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Tại sao Queue được xem là cấu trúc dữ liệu quan trọng trong các hệ thống xử lý tác vụ?",
    options: [
      "Nó ngăn chặn việc thêm tác vụ mới.",
      "Nó đảm bảo các tác vụ được xử lý theo thứ tự chúng đến (FIFO).",
      "Nó sử dụng khóa để truy cập tác vụ.",
      "Nó chỉ chấp nhận tác vụ có độ ưu tiên cao.",
    ],
    answer: 1,
    explanation:
      "Queue là cấu trúc FIFO, đảm bảo rằng phần tử đầu tiên được thêm vào là phần tử đầu tiên được truy cập hoặc loại bỏ [16, 17].",
  },
  {
    id: 2016,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi nào nên sử dụng HashMap thay vì TreeMap?",
    options: [
      "Khi cần các Key được sắp xếp.",
      "Khi cần tốc độ truy xuất nhanh nhất và thứ tự không quan trọng.",
      "Khi cần duyệt qua tất cả các phần tử theo thứ tự chèn.",
      "Khi cần Map có kích thước cố định.",
    ],
    answer: 1,
    explanation:
      "HashMap được giới thiệu để tăng tốc quá trình tìm kiếm [8]. TreeMap duy trì sắp xếp, có thể chậm hơn HashMap [47].",
  },
  {
    id: 2017,
    topic: "Generics & Collections",
    type: "radio",
    question: "Mục đích của việc sử dụng Key trong Map là gì?",
    options: [
      "Chỉ để phân loại các Value.",
      "Để truy cập Value một cách nhanh chóng và hiệu quả.",
      "Nó không có chức năng thực tế ngoài việc là một tham số.",
      "Để đảm bảo rằng các Value không bị trùng lặp.",
    ],
    answer: 1,
    explanation:
      "Key được sử dụng để tìm kiếm nhanh một mục trong collection mà không cần lặp qua tất cả các mục [8].",
  },
  {
    id: 2018,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn lưu trữ các đối tượng duy nhất, nhưng muốn chúng được duy trì theo một thứ tự sắp xếp cụ thể (tự nhiên), bạn nên sử dụng class nào?",
    options: ["ArrayList", "HashSet", "TreeSet", "LinkedHashMap"],
    answer: 2,
    explanation:
      "TreeSet giữ các phần tử được sắp xếp và ngăn chặn các bản sao [19, 20, 63].",
  },
  {
    id: 2019,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Generics, sự khác biệt giữa tham số phương thức và tham số kiểu là gì?",
    options: [
      "Tham số phương thức chấp nhận kiểu dữ liệu, tham số kiểu chấp nhận giá trị.",
      "Tham số phương thức chấp nhận giá trị, tham số kiểu chấp nhận kiểu (classes, interfaces...).",
      "Cả hai đều chấp nhận giá trị.",
      "Tham số kiểu chỉ áp dụng cho Stack.",
    ],
    answer: 1,
    explanation:
      "Tham số phương thức chấp nhận giá trị làm đầu vào, trong khi tham số kiểu chấp nhận các kiểu (lớp, giao diện...) làm đầu vào [50].",
  },
  {
    id: 2020,
    topic: "Generics & Collections",
    type: "radio",
    question: "Giao diện `Comparable` định nghĩa phương thức nào?",
    options: [
      "equals(Object o)",
      "compare(T o1, T o2)",
      "compareTo(T o)",
      "hash(Object o)",
    ],
    answer: 2,
    explanation:
      "Giao diện Comparable bao gồm một phương thức duy nhất gọi là CompareTo(), được sử dụng để so sánh đối tượng này ('this') với đối tượng được truyền vào [59, 64].",
  },
  {
    id: 2021,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều nào sau đây KHÔNG phải là một hoạt động cơ bản mà Java Collection Framework hỗ trợ?",
    options: [
      "Sorting (Sắp xếp)",
      "Hardware programming (Lập trình phần cứng)",
      "Searching (Tìm kiếm)",
      "Deletion (Xóa)",
    ],
    answer: 1,
    explanation:
      "Java collections có thể thực hiện tất cả các hoạt động mà bạn thực hiện trên dữ liệu như tìm kiếm, sắp xếp, chèn, thao tác và xóa [46]. Lập trình phần cứng không phải là mục tiêu của Collection Framework.",
  },
  {
    id: 2022,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn cần một danh sách mà có thể được truy cập bằng chỉ mục nhưng KHÔNG cần khả năng thay đổi kích thước linh hoạt, bạn nên chọn gì?",
    options: ["ArrayList", "LinkedList", "Mảng (Array)", "HashSet"],
    answer: 2,
    explanation:
      "Mảng (Array) là cấu trúc cơ bản cho phép truy cập nhanh bằng chỉ mục [36]. Nếu không cần thay đổi kích thước linh hoạt, mảng tĩnh là một lựa chọn hiệu quả [4, 65].",
  },
  {
    id: 2023,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList có thể truy cập bất kỳ phần tử nào dựa trên chỉ mục của nó (ví dụ: `list.get(5)`). Đây là đặc điểm của loại truy cập nào?",
    options: [
      "Sequential access",
      "LIFO access",
      "Random access",
      "Key-based access",
    ],
    answer: 2,
    explanation:
      "Mảng (và do đó ArrayList) cung cấp truy cập ngẫu nhiên nhanh chóng bằng cách cho phép bạn sử dụng một vị trí chỉ mục [36].",
  },
  {
    id: 2024,
    topic: "Generics & Collections",
    type: "radio",
    question: "Lớp nào sau đây triển khai List và sử dụng mảng nội bộ?",
    options: ["LinkedList", "Stack", "ArrayList", "HashMap"],
    answer: 2,
    explanation:
      "ArrayList là class phổ biến nhất triển khai giao diện List, sử dụng một mảng nội bộ (array internally) [15, 37].",
  },
  {
    id: 2025,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong bối cảnh hệ thống máy in (Printer Queue), nguyên tắc nào mô tả cách các tác vụ in được xử lý?",
    options: [
      "LIFO (Stack)",
      "FIFO (Queue)",
      "Key-Value (Map)",
      "Unique (Set)",
    ],
    answer: 1,
    explanation:
      "Hàng đợi tác vụ in là một ví dụ điển hình của cấu trúc FIFO (Queue), nơi tác vụ được gửi đến đầu tiên sẽ được xử lý đầu tiên [16, 17].",
  },
  {
    id: 2026,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào trong Stack được sử dụng để thêm phần tử vào đỉnh (top) của stack?",
    options: ["add()", "push()", "insert()", "enqueue()"],
    answer: 1,
    explanation: "push(e Item): thêm một mục vào đỉnh của stack [5, 6].",
  },
  {
    id: 2027,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sử dụng HashMap thay vì ArrayList để tìm kiếm một đối tượng bằng ID sẽ mang lại lợi ích gì?",
    options: [
      "Tiêu thụ ít bộ nhớ hơn.",
      "Mã nguồn đơn giản hơn.",
      "Tăng tốc độ tìm kiếm đáng kể (faster lookup).",
      "Tự động sắp xếp kết quả.",
    ],
    answer: 2,
    explanation:
      "HashMap là một loại collection được giới thiệu trong Java để tăng tốc quá trình tìm kiếm so với ArrayList [8, 9].",
  },
  {
    id: 2028,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong Map, Key có thể là null không (trong HashMap)?",
    options: [
      "Không bao giờ.",
      "Có, nhưng chỉ một Key null được cho phép.",
      "Có, bất kỳ số lượng Key null nào đều được cho phép.",
      "Chỉ khi Value cũng là null.",
    ],
    answer: 1,
    explanation:
      "Mặc dù nguồn không nêu rõ quy tắc null của HashMap, nhưng theo chuẩn Java, HashMap cho phép một khóa (key) null duy nhất (Key uniqueness) [12].",
  },
  {
    id: 2029,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu một lớp triển khai giao diện `Set`, điều nào sau đây phải được đảm bảo?",
    options: [
      "Các phần tử được sắp xếp.",
      "Không có phần tử nào là null.",
      "Không có bản sao (duplicates).",
      "Được truy cập bằng chỉ mục.",
    ],
    answer: 2,
    explanation: "Set là các collection không cho phép các bản sao [11, 12].",
  },
  {
    id: 2030,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Mục đích của Generic Type Parameter 'E' trong `ArrayList<E>` là gì?",
    options: [
      "Viết tắt cho Exception.",
      "Viết tắt cho Element (Phần tử).",
      "Viết tắt cho Execution.",
      "Viết tắt cho Encapsulation.",
    ],
    answer: 1,
    explanation:
      "Trong tài liệu ArrayList, 'E' là một stand-in cho 'the type of element' (kiểu phần tử) bạn muốn collection này giữ và trả về (E là viết tắt của Element) [66].",
  },
  {
    id: 2031,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList cung cấp tính năng gì để vượt qua hạn chế về kích thước cố định của mảng?",
    options: [
      "Sử dụng mảng đa chiều.",
      "Sử dụng chỉ mục âm.",
      "Đóng gói mảng và quản lý việc tự động thay đổi kích thước nội bộ.",
      "Ép kiểu thủ công.",
    ],
    answer: 2,
    explanation:
      "ArrayList là một lớp bọc quanh mảng cho phép nó phát triển và thu hẹp (dynamically resizing), vượt qua hạn chế của mảng thông thường [4, 27].",
  },
  {
    id: 2032,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào trong ArrayList cho phép xóa một phần tử dựa trên chính đối tượng đó (thay vì chỉ mục)?",
    options: [
      "remove(int index)",
      "remove(Object o)",
      "delete(Object o)",
      "clear(Object o)",
    ],
    answer: 1,
    explanation:
      "remove(Object elem): Loại bỏ một thể hiện của đối tượng được chỉ định trong tham số. Trả về 'true' nếu phần tử có trong danh sách [67].",
  },
  {
    id: 2033,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong LinkedList, việc chèn phần tử ở giữa danh sách được thực hiện nhanh hơn so với ArrayList vì sao?",
    options: [
      "LinkedList không cần lưu trữ đối tượng.",
      "LinkedList chỉ cần thay đổi các tham chiếu (references) của các nút lân cận.",
      "LinkedList không có chỉ mục.",
      "LinkedList sử dụng cấu trúc cây.",
    ],
    answer: 1,
    explanation:
      "LinkedList có thể nhanh hơn trong việc chèn/xóa ở giữa [26] vì nó chỉ cần thay đổi các con trỏ/tham chiếu, không cần dịch chuyển các phần tử như ArrayList [68].",
  },
  {
    id: 2034,
    topic: "Generics & Collections",
    type: "radio",
    question: "Cơ chế LIFO (Last-In, First-Out) đảm bảo điều gì?",
    options: [
      "Phần tử ở giữa luôn là mục tiếp theo.",
      "Phần tử được thêm vào cuối cùng sẽ là phần tử tiếp theo được xử lý.",
      "Phần tử được thêm vào đầu tiên sẽ được xử lý cuối cùng.",
      "Các phần tử được xử lý theo thứ tự ngẫu nhiên.",
    ],
    answer: 1,
    explanation:
      "Stack (LIFO) là cấu trúc mà đối tượng cuối cùng được thêm vào sẽ là đối tượng đầu tiên được pop ra [5, 6].",
  },
  {
    id: 2035,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để lấy ra phần tử đầu tiên khỏi Queue VÀ loại bỏ nó khỏi Queue, bạn sử dụng phương thức nào?",
    options: ["peek()", "removeFirst()", "poll()", "pop()"],
    answer: 2,
    explanation:
      "poll(): truy xuất và loại bỏ phần tử đầu (head) của Queue [7, 25].",
  },
  {
    id: 2036,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Map nào sau đây duy trì thứ tự chèn (insertion order) của các cặp Key-Value?",
    options: ["LinkedHashMap", "HashMap", "TreeMap", "Hashtable"],
    answer: 0,
    explanation:
      "LinkedHashMap có thể ghi nhớ thứ tự mà các phần tử được chèn vào [21, 40].",
  },
  {
    id: 2037,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi nào thì việc tìm kiếm tuần tự (linear search) trong ArrayList được ưa chuộng hơn HashMap?",
    options: [
      "Dữ liệu có kích thước rất lớn.",
      "Không bao giờ.",
      "Khi thứ tự của các phần tử là tuyệt đối quan trọng.",
      "Khi cần tìm kiếm một đối tượng dựa trên một trong các thuộc tính của nó (không phải Key).",
    ],
    answer: 3,
    explanation:
      "Nếu bạn muốn tìm kiếm một đối tượng dựa trên một thuộc tính nào đó (ví dụ: tìm kiếm sách theo tên tác giả trong ArrayList), bạn phải lặp qua danh sách [39]. Tuy nhiên, HashMap vẫn hiệu quả hơn nếu thuộc tính tìm kiếm được chọn làm Key [30, 31].",
  },
  {
    id: 2038,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn có một List chứa các bản sao (duplicates), bạn có thể dễ dàng chuyển đổi nó thành một Set để loại bỏ các bản sao bằng phương thức nào?",
    options: [
      "convertToList()",
      "removeAllDuplicates()",
      "addAll() của Set (từ List)",
      "filterDuplicates()",
    ],
    answer: 2,
    explanation:
      "HashSet có phương thức addAll() cho phép lấy một collection khác để điền vào HashSet. Vì Set không chấp nhận bản sao, các bản sao sẽ tự động bị loại bỏ [48].",
  },
  {
    id: 2039,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào được sử dụng để hạn chế kiểu tham số là siêu kiểu (supertype) của một kiểu cụ thể (lower bounded wildcard)?",
    options: ["<? extends T>", "<? super T>", "<?>", "<T>"],
    answer: 1,
    explanation:
      "Lower-bounded wildcard hạn chế kiểu không xác định là một siêu kiểu của một kiểu cụ thể, sử dụng ký tự '?' theo sau là từ khóa `super` [69, 70].",
  },
  {
    id: 2040,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu không sử dụng Generics, Collection sẽ mặc định làm việc với kiểu nào cho các phần tử của nó?",
    options: [
      "String",
      "int",
      "Tùy thuộc vào phần tử đầu tiên được thêm vào.",
      "Object",
    ],
    answer: 3,
    explanation:
      "Trước Generics, không có cách nào để khai báo kiểu của ArrayList, vì vậy phương thức add() của nó lấy kiểu Object [62, 71, 72].",
  },
  {
    id: 2041,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để tìm kiếm một đối tượng trong ArrayList một cách tuần tự, người ta thường sử dụng cấu trúc nào?",
    options: [
      "Sử dụng HashMap.",
      "Lặp (loop) và sử dụng chỉ mục hoặc vòng lặp for-each.",
      "Sử dụng `search()`.",
      "Sử dụng `pop()`.",
    ],
    answer: 1,
    explanation:
      "Cách thông thường để truy cập từng phần tử trong ArrayList là tạo một vòng lặp và sử dụng bộ đếm vòng lặp làm chỉ mục [28]. Tìm kiếm tuần tự trong ArrayList yêu cầu tạo một vòng lặp [39].",
  },
  {
    id: 2042,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Tại sao việc chèn vào đầu (index 0) của ArrayList lại kém hiệu quả hơn chèn vào cuối?",
    options: [
      "Vì ArrayList phải gọi constructor mỗi lần chèn.",
      "Vì tất cả các phần tử sau đó phải được sao chép (shifted) một vị trí.",
      "Vì nó phá vỡ quy tắc LIFO.",
      "Vì chỉ mục 0 là chỉ mục tĩnh.",
    ],
    answer: 1,
    explanation:
      "Khi bạn chèn một phần tử tại một chỉ mục (ví dụ: 0), ArrayList phải dịch chuyển tất cả các phần tử tiếp theo [13, 14].",
  },
  {
    id: 2043,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu `List` đại diện cho một 'ordered collection' (collection có thứ tự), thì `Set` đại diện cho gì?",
    options: [
      "Key-Value mapping",
      "Unique Collection",
      "LIFO stack",
      "Random access",
    ],
    answer: 1,
    explanation:
      "Set là collection không cho phép các bản sao [11, 12]. Set đại diện cho một Unique Collection (tập hợp duy nhất).",
  },
  {
    id: 2044,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Interface nào trong Java được sử dụng để thao tác thêm/xóa ở cả hai đầu của hàng đợi?",
    options: ["Queue", "Stack", "Deque", "List"],
    answer: 2,
    explanation:
      "Deque là một loại Queue đặc biệt (double-ended queue), cho phép bạn thêm hoặc xóa các phần tử từ cả hai đầu [16, 17].",
  },
  {
    id: 2045,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, nếu bạn sử dụng kiểu nguyên thủy (primitive type) cho Key hoặc Value, điều gì sẽ xảy ra nội bộ?",
    options: [
      "Map sẽ tự động chuyển đổi chúng thành kiểu String.",
      "Map không cho phép kiểu nguyên thủy.",
      "Java sẽ sử dụng Autoboxing để chuyển chúng thành các lớp Wrapper tương ứng (ví dụ: Integer).",
      "Nó gây ra lỗi biên dịch.",
    ],
    answer: 2,
    explanation:
      "Map có thể sử dụng kiểu nguyên thủy thông qua Autoboxing [51], tức là tự động chuyển đổi thành Wrapper Class [73].",
  },
  {
    id: 2046,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng HashMap, cách tối ưu nhất để truy vấn dữ liệu là gì?",
    options: [
      "Duyệt qua tất cả các cặp Key-Value.",
      "Sử dụng Iterator.",
      "Truy vấn trực tiếp bằng Key (ví dụ: `get(key)`).",
      "Chuyển HashMap thành ArrayList và sau đó tìm kiếm.",
    ],
    answer: 2,
    explanation:
      "HashMap được thiết kế để tìm kiếm nhanh bằng key, tránh phải lặp qua collection [8, 31].",
  },
  {
    id: 2047,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi nào nên sử dụng `Set` thay vì `List`?",
    options: [
      "Khi cần duy trì thứ tự chèn.",
      "Khi cần kiểm tra nhanh chóng xem một phần tử đã tồn tại hay chưa.",
      "Khi cần truy cập các phần tử theo chỉ mục.",
      "Khi cần sắp xếp theo thứ tự ngẫu nhiên.",
    ],
    answer: 1,
    explanation:
      "Set biết liệu có cái gì đó đã có trong collection hay không [11]. Nó hữu ích khi cần tránh các bản sao.",
  },
  {
    id: 2048,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn sắp xếp một `ArrayList<Song>` bằng `Collections.sort(songList)`, class Song PHẢI làm gì?",
    options: [
      "Có phương thức `getArtist()`.",
      "Triển khai giao diện `Comparator`.",
      "Triển khai giao diện `Comparable`.",
      "Là một `final class`.",
    ],
    answer: 2,
    explanation:
      "Collections.sort() yêu cầu các đối tượng được lưu trữ trong ArrayList phải triển khai giao diện Comparable để sắp xếp theo thứ tự tự nhiên [56, 64, 74, 75].",
  },
  {
    id: 2049,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là mục tiêu chính của Generics?",
    options: [
      "Tăng cường tính đa hình giữa các đối tượng khác nhau.",
      "Cho phép các lớp chấp nhận tham số kiểu khi định nghĩa chúng.",
      "Giới hạn sử dụng các lớp trong các gói cụ thể.",
      "Hợp nhất List, Set, và Map thành một giao diện duy nhất.",
    ],
    answer: 1,
    explanation:
      "Các lớp Generic cho phép các lớp chấp nhận tham số kiểu khi định nghĩa chúng, tương tự như cách sử dụng tham số phương thức [50].",
  },
  {
    id: 2050,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào trong Iterator cho phép bạn di chuyển đến phần tử tiếp theo trong Collection?",
    options: ["hasNext()", "next()", "move()", "forward()"],
    answer: 1,
    explanation:
      "Giao diện Iterator bao gồm các phương thức: hasNext(), next(), remove() [31, 57].",
  },
  {
    id: 2051,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Java Collection Framework, List, Queue, và Set đều là các loại gì?",
    options: ["Classes", "Abstract Classes", "Interfaces", "Enums"],
    answer: 2,
    explanation:
      "Java collection framework cung cấp nhiều interfaces như List, Queue... [46].",
  },
  {
    id: 2052,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList cung cấp tính năng gì để đơn giản hóa việc quản lý nhiều mục cùng loại?",
    options: [
      "Mã hóa dữ liệu nội bộ.",
      "Sử dụng các lớp và giao diện do Java cung cấp.",
      "Sử dụng thuật toán băm phức tạp.",
      "Loại bỏ nhu cầu sử dụng đối tượng.",
    ],
    answer: 1,
    explanation:
      "Collections là một tập hợp các lớp và giao diện được Java cung cấp để đơn giản hóa việc quản lý nhiều mục cùng loại [1].",
  },
  {
    id: 2053,
    topic: "Generics & Collections",
    type: "radio",
    question: "Đối với List, điều nào sau đây là đúng?",
    options: [
      "Nó không có thứ tự.",
      "Nó cho phép truy cập bằng chỉ mục.",
      "Nó không cho phép các phần tử trùng lặp.",
      "Nó chỉ có thể được triển khai bởi LinkedList.",
    ],
    answer: 1,
    explanation:
      "Các mục có thể được truy cập bằng chỉ mục số nguyên của chúng trong List [15].",
  },
  {
    id: 2054,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt về truy cập dữ liệu giữa ArrayList và LinkedList là gì?",
    options: [
      "ArrayList chỉ có truy cập tuần tự, LinkedList có truy cập ngẫu nhiên.",
      "ArrayList ưu tiên truy cập ngẫu nhiên, LinkedList ưu tiên truy cập tuần tự (để thay đổi tham chiếu).",
      "Cả hai đều chỉ có truy cập tuần tự.",
      "Chỉ LinkedList mới cho phép sử dụng vòng lặp.",
    ],
    answer: 1,
    explanation:
      "ArrayList cung cấp truy cập ngẫu nhiên nhanh chóng [36]. LinkedList tốt hơn cho các thao tác chèn/xóa ở giữa [26], đòi hỏi phải duyệt tuần tự để tìm điểm chèn/xóa.",
  },
  {
    id: 2055,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong ứng dụng Stack (LIFO), nếu bạn muốn xem phần tử ở đỉnh mà không loại bỏ nó, bạn gọi phương thức nào?",
    options: ["pop()", "get()", "peek()", "top()"],
    answer: 2,
    explanation:
      "peek(): trả về đối tượng ở đỉnh mà không loại bỏ nó khỏi stack [5].",
  },
  {
    id: 2056,
    topic: "Generics & Collections",
    type: "radio",
    question: "Phương thức `add(E element)` trong Queue làm gì?",
    options: [
      "Chèn phần tử vào giữa Queue.",
      "Chèn phần tử vào Queue (thông thường là cuối).",
      "Thêm phần tử vào đầu Queue (head).",
      "Thay thế phần tử đầu Queue.",
    ],
    answer: 1,
    explanation: "add(E element): chèn phần tử được chỉ định vào queue [7].",
  },
  {
    id: 2057,
    topic: "Generics & Collections",
    type: "radio",
    question: "Sự tối ưu hóa hiệu suất chính mà HashMap mang lại là gì?",
    options: [
      "Giảm lỗi cú pháp.",
      "Giảm thiểu nhu cầu ghi đè equals() và hashCode().",
      "Tốc độ tìm kiếm nhanh hơn thông qua Key.",
      "Tổ chức dữ liệu theo thứ tự chèn.",
    ],
    answer: 2,
    explanation:
      "HashMap là một loại collection được giới thiệu để tăng tốc quá trình tìm kiếm so với ArrayList [8, 9].",
  },
  {
    id: 2058,
    topic: "Generics & Collections",
    type: "radio",
    question: "Map nào sau đây là triển khai của `SortedMap`?",
    options: ["HashMap", "Hashtable", "LinkedHashMap", "TreeMap"],
    answer: 3,
    explanation: "TreeMap triển khai SortedMap [21, 47].",
  },
  {
    id: 2059,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu hai đối tượng có hashcode giống nhau, nhưng `equals()` trả về false, chúng có được coi là bản sao trong HashSet không?",
    options: [
      "Có, chúng là bản sao.",
      "Không, HashSet chỉ coi chúng là bản sao nếu cả hashcode và equals đều khớp.",
      "Tùy thuộc vào việc triển khai `Comparable`.",
      "Chỉ khi đó là String.",
    ],
    answer: 1,
    explanation:
      "HashSet coi chúng là bản sao nếu cả hai đều có hashcode khớp và equals() trả về true [32, 33].",
  },
  {
    id: 2060,
    topic: "Generics & Collections",
    type: "radio",
    question: "Điều gì là hệ quả của việc Generics loại bỏ nhu cầu ép kiểu?",
    options: [
      "Tăng cường lỗi Runtime.",
      "Không có cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch.",
      "Tăng cường type-safety.",
      "Tăng độ phức tạp của mã.",
    ],
    answer: 2,
    explanation:
      "Generics loại bỏ nhu cầu ép kiểu và tăng cường an toàn kiểu (type-safety) [2, 3, 76].",
  },
  {
    id: 2061,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự tiện lợi lớn nhất của ArrayList so với mảng thông thường là gì?",
    options: [
      "Tự động sắp xếp.",
      "Có thể thay đổi kích thước mà không cần lo lắng về chỉ mục hoặc triển khai mảng nội bộ.",
      "Chỉ lưu trữ các số nguyên.",
      "Không hỗ trợ lặp.",
    ],
    answer: 1,
    explanation:
      "ArrayList là một lớp bọc quanh mảng cho phép bạn khởi tạo biến collection mà không cần chỉ định số lượng mục [13]. Bạn sử dụng phương thức add() mà không cần lo lắng về chỉ mục hoặc việc triển khai mảng ở hậu trường [13].",
  },
  {
    id: 2062,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong trường hợp nào, việc sử dụng vòng lặp để truy cập từng phần tử trong ArrayList là cần thiết?",
    options: [
      "Để xóa toàn bộ danh sách.",
      "Để tìm chỉ mục của phần tử (sử dụng indexOf()).",
      "Để in tất cả các phần tử (nếu không sử dụng phương thức in trực tiếp hoặc iterator).",
      "Để lấy kích thước của danh sách.",
    ],
    answer: 2,
    explanation:
      "Giống như với mảng, cách tốt nhất để truy cập từng phần tử trong ArrayList là tạo một vòng lặp và sử dụng bộ đếm vòng lặp làm chỉ mục [28].",
  },
  {
    id: 2063,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt chính giữa List và Set là gì về mặt cho phép trùng lặp?",
    options: [
      "List không cho phép, Set cho phép.",
      "Set không cho phép, List cho phép.",
      "Cả hai đều cho phép.",
      "Cả hai đều không cho phép.",
    ],
    answer: 1,
    explanation:
      "List cho phép trùng lặp (Duplicates OK). Set không cho phép trùng lặp (NO duplicates) [11, 12].",
  },
  {
    id: 2064,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để loại bỏ một phần tử khỏi đỉnh (top) của Stack và trả về nó?",
    options: ["push()", "pop()", "peek()", "poll()"],
    answer: 1,
    explanation:
      "pop(): loại bỏ đối tượng ở đỉnh của stack và trả về đối tượng đó [5].",
  },
  {
    id: 2065,
    topic: "Generics & Collections",
    type: "radio",
    question: "Queue là cấu trúc dữ liệu nào?",
    options: ["LIFO", "FIFO", "Key-Value", "Unique"],
    answer: 1,
    explanation:
      "Queue là cấu trúc dữ liệu First-In, First-Out (FIFO) [16, 17].",
  },
  {
    id: 2066,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn truy cập tất cả các khóa (Keys) trong HashMap, bạn có thể truy xuất nó dưới dạng một tập hợp nào?",
    options: ["List", "Queue", "Set", "Array"],
    answer: 2,
    explanation:
      "HashMap cung cấp phương thức `keySet()` trả về một Set chứa tất cả các khóa (Key uniqueness) [12].",
  },
  {
    id: 2067,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "HashMap được thiết kế để thay thế hình thức tìm kiếm nào trong ArrayList?",
    options: [
      "Tìm kiếm Binary (Binary Search).",
      "Tìm kiếm tuần tự (Linear Search) bằng cách lặp.",
      "Tìm kiếm ngẫu nhiên.",
      "Không thay thế gì.",
    ],
    answer: 1,
    explanation:
      "HashMap được thiết kế để tăng tốc quá trình tìm kiếm so với ArrayList, nơi bạn phải tạo một vòng lặp để so sánh từng mục (linear search) [8, 39].",
  },
  {
    id: 2068,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn sắp xếp các phần tử trong List theo một tiêu chí TÙY CHỈNH (custom criteria), bạn nên sử dụng class/interface nào với `Collections.sort()`?",
    options: ["Serializable", "Comparable", "Comparator", "Cloneable"],
    answer: 2,
    explanation:
      "Nếu bạn muốn có hai cách xem danh sách khác nhau (ví dụ: sắp xếp theo tiêu đề hoặc theo nghệ sĩ), bạn cần sử dụng Comparator [77, 78].",
  },
  {
    id: 2069,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong cú pháp Generic, ý nghĩa của việc thêm một tham số kiểu K và V trong Pair<K, V> là gì?",
    options: [
      "Giới hạn Pair chỉ chấp nhận String và Integer.",
      "Cho phép Pair lưu trữ hai kiểu dữ liệu khác nhau cho Key và Value.",
      "Tạo ra một HashMap.",
      "Chỉ cho phép sử dụng kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Bạn có thể định nghĩa các kiểu generic của riêng mình với nhiều tham số (ví dụ: Pair<K,V>) cho phép hai kiểu dữ liệu khác nhau [79, 80].",
  },
  {
    id: 2070,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để kiểm tra xem Iterator có còn phần tử nào để duyệt tiếp không, bạn sử dụng phương thức nào?",
    options: ["get(int index)", "hasNext()", "size()", "move()"],
    answer: 1,
    explanation: "Giao diện Iterator có phương thức hasNext() [31, 57].",
  },
  {
    id: 2071,
    topic: "Generics & Collections",
    type: "radio",
    question: "ArrayList được sử dụng cho List vì nó hỗ trợ điều gì?",
    options: [
      "Kiểm soát chính xác việc chèn từng mục.",
      "Truy cập ngẫu nhiên thông qua chỉ mục.",
      "List là một collection có thứ tự.",
      "Tất cả các điều trên.",
    ],
    answer: 3,
    explanation:
      "List là collection có thứ tự [15], cho phép kiểm soát việc chèn và truy cập các mục bằng chỉ mục [15].",
  },
  {
    id: 2072,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn biết chính xác số lượng mục bạn sẽ sử dụng, bạn có thể chọn gì thay vì ArrayList?",
    options: ["LinkedList", "Mảng (Array)", "Stack", "Set"],
    answer: 1,
    explanation:
      "Hạn chế của mảng là bạn cần biết chính xác số lượng mục bạn sẽ sử dụng [81, 82]. Nếu biết, mảng có thể là lựa chọn thay thế ArrayList [4].",
  },
  {
    id: 2073,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt chính về hành vi của `remove(int index)` trong ArrayList so với mảng thông thường là gì?",
    options: [
      "Mảng không có phương thức `remove()`.",
      "ArrayList không cho phép xóa bằng chỉ mục.",
      "ArrayList tự động dịch chuyển các phần tử còn lại để lấp đầy khoảng trống (reorganize indices).",
      "Mảng phải xóa các phần tử từ cuối.",
    ],
    answer: 2,
    explanation:
      "Bạn có thể sử dụng phương thức remove() để xóa một mục và dịch chuyển các phần tử còn lại để tổ chức lại chỉ mục trong ArrayList [13].",
  },
  {
    id: 2074,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu `order` là một Queue và các thao tác sau được thực hiện: `orders.add('A'); orders.add('B'); System.out.print(orders.poll());`, đầu ra sẽ là gì?",
    options: ["B", "A", "Lỗi", "Null"],
    answer: 1,
    explanation:
      "Queue là FIFO. 'A' được thêm vào đầu tiên, nên 'A' được poll() ra đầu tiên [16, 25].",
  },
  {
    id: 2075,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Deque cho phép bạn thực hiện những thao tác nào ở cả hai đầu của hàng đợi?",
    options: [
      "push() và pop()",
      "get() và set()",
      "addFirst(), addLast(), pollFirst(), pollLast()",
      "removeFirst(), removeLast(), peekFirst(), peekLast()",
    ],
    answer: 2,
    explanation:
      "Deque cung cấp các phương thức như addFirst(), addLast(), pollFirst(), pollLast() [16, 25].",
  },
  {
    id: 2076,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, việc sử dụng Key có thể là bất kỳ Object nào ngoại trừ?",
    options: [
      "Kiểu nguyên thủy (thông qua Autoboxing).",
      "String.",
      "Một đối tượng có triển khai hashCode() và equals() kém.",
      "Integer.",
    ],
    answer: 2,
    explanation:
      "Mặc dù Map chấp nhận Key là bất kỳ Object nào [8], việc sử dụng một đối tượng có triển khai hashCode()/equals() kém sẽ dẫn đến lỗi logic hoặc hiệu suất kém trong quá trình tìm kiếm/lưu trữ [32, 33].",
  },
  {
    id: 2077,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là mục đích của việc sử dụng `List<String> list = new ArrayList<>()`?",
    options: [
      "Tăng tính linh hoạt nếu sau này bạn muốn thay đổi triển khai thành LinkedList.",
      "Buộc Collection chỉ lưu trữ String literal.",
      "Giới hạn List chỉ được truy cập bằng Iterator.",
      "Đảm bảo List là bất biến.",
    ],
    answer: 0,
    explanation:
      "Khai báo bằng giao diện (`List`) thay vì lớp cụ thể (`ArrayList`) là thực hành tốt để cho phép tính đa hình và dễ dàng chuyển đổi sang các triển khai khác (ví dụ: `LinkedList`) trong tương lai mà không ảnh hưởng đến phần còn lại của mã [44].",
  },
  {
    id: 2078,
    topic: "Generics & Collections",
    type: "radio",
    question: "HashSet cung cấp những gì về thứ tự phần tử?",
    options: [
      "Đảm bảo thứ tự Alphabet.",
      "Đảm bảo thứ tự chèn.",
      "Không đảm bảo thứ tự cụ thể (unordered).",
      "Sắp xếp theo hashCode.",
    ],
    answer: 2,
    explanation:
      "HashSet là một triển khai của Set không có thứ tự cụ thể (unordered set), trái ngược với LinkedHashSet (duy trì thứ tự chèn) hoặc TreeSet (duy trì sắp xếp) [47].",
  },
  {
    id: 2079,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sử dụng Generics cho phép bạn chỉ định kiểu dữ liệu của các phần tử giữa dấu `< >`. Điều này được gọi là gì?",
    options: [
      "Primitive type notation",
      "Method overloading",
      "Type Parameter (Tham số kiểu)",
      "Object casting",
    ],
    answer: 2,
    explanation:
      "Generics cho phép các lớp chấp nhận tham số kiểu khi định nghĩa chúng [50]. Bạn có thể xác định kiểu dữ liệu bằng cách chỉ định nó giữa các dấu ngoặc nhọn `<>` [2].",
  },
  {
    id: 2080,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều kiện nào sau đây KHÔNG phải là trường hợp sử dụng thích hợp cho unbounded wildcard `<?>`?",
    options: [
      "Gọi phương thức `size()` trên danh sách.",
      "Gọi phương thức `clear()` trên danh sách.",
      "Khi thêm một phần tử cụ thể vào danh sách (ví dụ: String).",
      "Khi viết một phương thức để in các phần tử của bất kỳ loại List nào.",
    ],
    answer: 2,
    explanation:
      "Wildcard không giới hạn hữu ích khi mã đang sử dụng các phương thức trong lớp generic không phụ thuộc vào tham số kiểu (ví dụ: `List.size()`, `List.clear()`) [34]. Nó không cho phép thêm các phần tử cụ thể.",
  },
  {
    id: 2081,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList được xem là 'List' trong Java Collections Framework. List là một giao diện (Interface). Điều gì phải đúng về một interface?",
    options: [
      "Nó phải có constructor.",
      "Không thể tạo đối tượng (object) từ một interface.",
      "Nó phải là một final class.",
      "Nó chỉ có thể có các phương thức static.",
    ],
    answer: 1,
    explanation:
      "Bạn không thể tạo một thể hiện (object) từ một interface [59].",
  },
  {
    id: 2082,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong ArrayList, việc truy cập các phần tử được gọi là 'random access' vì lý do gì?",
    options: [
      "Phần tử được chọn ngẫu nhiên.",
      "Có thể truy cập trực tiếp bất kỳ phần tử nào bằng chỉ mục của nó.",
      "Chỉ mục là các số ngẫu nhiên.",
      "Cần các tham số ngẫu nhiên.",
    ],
    answer: 1,
    explanation:
      "Mảng (và do đó ArrayList) cung cấp truy cập ngẫu nhiên nhanh chóng bằng cách cho phép bạn sử dụng một vị trí chỉ mục để đến bất kỳ phần tử nào trong mảng [36].",
  },
  {
    id: 2083,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Thao tác nào là không hiệu quả trong ArrayList, nhưng hiệu quả trong LinkedList?",
    options: [
      "get(int index)",
      "remove(int index) ở giữa danh sách.",
      "size()",
      "indexOf(Object o)",
    ],
    answer: 1,
    explanation:
      "LinkedList có thể nhanh hơn khi bạn chèn hoặc xóa thứ gì đó khỏi giữa danh sách [26].",
  },
  {
    id: 2084,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Stack được mô tả là Last-In, First-Out. Nếu bạn `push(1)`, `push(2)`, `push(3)`, thứ tự `pop()` sẽ là gì?",
    options: ["1, 2, 3", "3, 2, 1", "2, 3, 1", "1, 3, 2"],
    answer: 1,
    explanation:
      "Stack (LIFO). 3 được thêm vào cuối cùng (top), nên được pop ra đầu tiên [5, 83].",
  },
  {
    id: 2085,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Để chèn một phần tử vào cuối Deque, bạn sử dụng phương thức nào?",
    options: ["addFirst()", "addLast()", "pollLast()", "push()"],
    answer: 1,
    explanation:
      "addLast(E element): chèn phần tử được chỉ định vào cuối của deque [16].",
  },
  {
    id: 2086,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Map, nếu bạn cần tốc độ truy xuất nhanh và thứ tự không quan trọng, bạn chọn class nào?",
    options: ["LinkedHashMap", "TreeMap", "HashMap", "TreeSet"],
    answer: 2,
    explanation:
      "HashMap được giới thiệu để tăng tốc quá trình tìm kiếm [8, 9]. LinkedHashMap và TreeMap có thêm chi phí để duy trì thứ tự.",
  },
  {
    id: 2087,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sử dụng HashMap để tìm kiếm một đối tượng bằng Key hiệu quả hơn vì nó tránh được thao tác tốn kém nào trong ArrayList?",
    options: [
      "Cần ép kiểu.",
      "Lặp qua toàn bộ collection (loop through all the items).",
      "Lưu trữ đối tượng.",
      "Gọi phương thức `get(index)`.",
    ],
    answer: 1,
    explanation:
      "Mục tiêu là nhanh chóng tìm thấy một mục trong collection mà không cần phải lặp qua tất cả các mục [8].",
  },
  {
    id: 2088,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn loại bỏ các bản sao (duplicates) khỏi một List hiện có, bạn nên chuyển List đó sang class nào?",
    options: ["HashMap", "Stack", "HashSet", "LinkedList"],
    answer: 2,
    explanation:
      "HashSet không cho phép bản sao. Chuyển List sang HashSet bằng `addAll()` sẽ loại bỏ các bản sao [11, 48].",
  },
  {
    id: 2089,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Cú pháp `ArrayList<E>` trong Generics nhằm mục đích gì cho Collection?",
    options: [
      "Định nghĩa kích thước cố định.",
      "Định nghĩa tham số kiểu (type parameter) cho phép Collection làm việc với kiểu E.",
      "Bắt buộc tất cả các đối tượng là null.",
      "Chỉ cho phép E là kiểu String.",
    ],
    answer: 1,
    explanation:
      "E là một stand-in cho kiểu phần tử [66]. Nó cho phép bạn tái sử dụng code với các kiểu khác nhau [50].",
  },
  {
    id: 2090,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều gì là quan trọng đối với các lớp được sử dụng làm phần tử trong TreeSet?",
    options: [
      "Cần phải triển khai `Comparable`.",
      "Cần phải là kiểu nguyên thủy.",
      "Cần phải có thuộc tính `length`.",
      "Cần phải là `static`.",
    ],
    answer: 0,
    explanation:
      "TreeSet giữ các phần tử được sắp xếp, do đó các phần tử TreeSet PHẢI có khả năng so sánh được (comparable) [54, 63].",
  },
  {
    id: 2091,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Khi sử dụng ArrayList, bạn có quyền kiểm soát chính xác đối với điều gì?",
    options: [
      "Vị trí chèn mỗi mục vào List.",
      "Bộ nhớ Heap được phân bổ.",
      "Cơ chế GC (Garbage Collection).",
      "Cách Map băm các phần tử.",
    ],
    answer: 0,
    explanation:
      "Người dùng giao diện List có quyền kiểm soát chính xác nơi mỗi mục được chèn vào trong danh sách [15].",
  },
  {
    id: 2092,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "ArrayList hoạt động giống như một lớp bọc quanh mảng, bổ sung thêm các tính năng nào?",
    options: [
      "Mã hóa AES.",
      "Các phương thức tiện ích và quản lý kích thước động.",
      "Khả năng lưu trữ kiểu nguyên thủy mà không cần Wrapper.",
      "Chỉ mục bắt đầu từ 1.",
    ],
    answer: 1,
    explanation:
      "ArrayList là một lớp bọc quanh một mảng, thêm các phương thức bổ sung như thay đổi kích thước và các tiện ích khác [13, 14, 27].",
  },
  {
    id: 2093,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Sự khác biệt về chi phí hiệu suất giữa ArrayList và LinkedList khi truy cập ngẫu nhiên là gì?",
    options: [
      "ArrayList (O(1)) nhanh hơn LinkedList (O(n)).",
      "LinkedList (O(1)) nhanh hơn ArrayList (O(n)).",
      "Cả hai đều là O(n).",
      "Cả hai đều là O(1).",
    ],
    answer: 0,
    explanation:
      "ArrayList cho phép truy cập ngẫu nhiên nhanh chóng (O(1)) [36]. LinkedList thường là O(n) cho truy cập ngẫu nhiên vì phải duyệt từ đầu.",
  },
  {
    id: 2094,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Stack, phần tử được thêm vào cuối cùng (LIFO) sẽ được gọi là gì?",
    options: ["Head", "Tail", "Top", "Index 0"],
    answer: 2,
    explanation: "Stack thêm/xóa các mục khỏi đỉnh (top) [5, 83].",
  },
  {
    id: 2095,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong Queue, phương thức nào được sử dụng để lấy ra phần tử đầu mà không xóa nó?",
    options: ["pop()", "remove()", "peek()", "poll()"],
    answer: 2,
    explanation:
      "peek(): trả về đối tượng ở đỉnh mà không loại bỏ nó khỏi stack [5]. (Trong Queue, peek() cũng thực hiện chức năng tương tự).",
  },
  {
    id: 2096,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Trong HashMap, một khóa (Key) phải là duy nhất. Khóa này có thể là kiểu dữ liệu nào?",
    options: [
      "Chỉ String và Integer.",
      "Chỉ kiểu dữ liệu nguyên thủy.",
      "Bất kỳ đối tượng nào (Object).",
      "Chỉ các đối tượng đã triển khai Comparable.",
    ],
    answer: 2,
    explanation: "Khóa có thể là bất kỳ đối tượng nào của một kiểu [8, 51].",
  },
  {
    id: 2097,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi nào thì LinkedHashMap được ưu tiên hơn HashMap?",
    options: [
      "Khi cần Map được sắp xếp theo Key.",
      "Khi cần duy trì thứ tự chèn (insertion order).",
      "Khi cần tốc độ tìm kiếm tối đa tuyệt đối.",
      "Khi không cần key là duy nhất.",
    ],
    answer: 1,
    explanation:
      "LinkedHashMap có thể ghi nhớ thứ tự mà các phần tử được chèn vào [21, 40].",
  },
  {
    id: 2098,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn duyệt qua các phần tử trong Collection và có khả năng xóa chúng trong quá trình lặp, bạn phải sử dụng gì?",
    options: [
      "For-each loop",
      "Iterator",
      "Phương thức get(index)",
      "Map's KeySet",
    ],
    answer: 1,
    explanation:
      "Iterator cho phép một chương trình duyệt qua một collection và loại bỏ các phần tử khỏi nó trong quá trình lặp [31].",
  },
  {
    id: 2099,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Generics giúp bạn tránh lỗi nào sau đây khi truy xuất dữ liệu từ Collection?",
    options: [
      "NullPointerException.",
      "ArrayIndexOutOfBoundsException.",
      "ClassCastException (lỗi ép kiểu runtime).",
      "FileNotFoundException.",
    ],
    answer: 2,
    explanation:
      "Generics loại bỏ nhu cầu ép kiểu, từ đó loại bỏ lỗi ClassCastException khi runtime nếu bạn cố gắng ép kiểu sai [2, 76].",
  },
  {
    id: 2100,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Giới hạn chính của việc sử dụng kiểu Object trước Generics là gì?",
    options: [
      "Không hỗ trợ đa hình.",
      "Yêu cầu ép kiểu liên tục và không có kiểm tra lỗi kiểu ở thời điểm biên dịch.",
      "Collection chỉ có thể lưu trữ String.",
      "Các đối tượng luôn là null.",
    ],
    answer: 1,
    explanation:
      "Hạn chế khi sử dụng Object là cần ép kiểu liên tục và không có cơ chế kiểm tra lỗi kiểu ở thời điểm biên dịch [76, 84].",
  },
  {
    id: 2101,
    topic: "Generics & Collections",
    type: "radio",
    question: "Trong List, bạn có thể tìm kiếm các mục bằng cách nào?",
    options: [
      "Sử dụng chỉ mục số nguyên.",
      "Duyệt qua các mục.",
      "Sử dụng phương thức `indexOf(Object o)`.",
      "Tất cả các điều trên.",
    ],
    answer: 3,
    explanation:
      "Các mục có thể được truy cập bằng chỉ mục [15]. Người dùng cũng có thể tìm kiếm các mục trong danh sách bằng cách lặp qua các mục [15] hoặc sử dụng `indexOf()` [28].",
  },
  {
    id: 2102,
    topic: "Generics & Collections",
    type: "radio",
    question: "ArrayList được thiết kế để thay thế hạn chế nào của mảng tĩnh?",
    options: [
      "Không cho phép lưu trữ kiểu String.",
      "Cần phải biết chính xác số lượng mục cần dùng khi khởi tạo.",
      "Không thể sắp xếp.",
      "Không cho phép sử dụng vòng lặp.",
    ],
    answer: 1,
    explanation:
      "Hạn chế của mảng là bạn cần biết chính xác số lượng mục bạn sẽ sử dụng khi khởi tạo [81, 82].",
  },
  {
    id: 2103,
    topic: "Generics & Collections",
    type: "radio",
    question: "Khi nào LinkedList có lợi thế hiệu suất so với ArrayList?",
    options: [
      "Thao tác chèn/xóa ở đầu hoặc cuối danh sách.",
      "Thao tác tìm kiếm bằng chỉ mục.",
      "Thao tác truy xuất ngẫu nhiên.",
      "Thao tác lấy kích thước.",
    ],
    answer: 0,
    explanation:
      "LinkedList thường được sử dụng cho Queue/Deque, nơi các thao tác chèn/xóa ở đầu/cuối được tối ưu hóa [25].",
  },
  {
    id: 2104,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Nếu bạn muốn thêm một mục vào đầu (front) của một Queue triển khai giao diện Deque, bạn sử dụng phương thức nào?",
    options: [
      "push(E element)",
      "addFirst(E element)",
      "pollFirst()",
      "add(E element)",
    ],
    answer: 1,
    explanation:
      "addFirst(E element): chèn phần tử được chỉ định vào đầu (front) của queue [16].",
  },
  {
    id: 2105,
    topic: "Generics & Collections",
    type: "radio",
    question: "Map là collection sử dụng cấu trúc gì?",
    options: [
      "Tuần tự (Sequence)",
      "Băm (Hashing) để truy cập nhanh chóng.",
      "LIFO",
      "FIFO",
    ],
    answer: 1,
    explanation:
      "HashMap là một Map sử dụng cơ chế băm (hashing) để tăng tốc độ tìm kiếm [8, 32].",
  },
  {
    id: 2106,
    topic: "Generics & Collections",
    type: "radio",
    question: "Để tìm kiếm một đối tượng trong Set, bạn cần cung cấp gì?",
    options: [
      "Chỉ mục (Index).",
      "Khóa (Key).",
      "Chính đối tượng (để Set kiểm tra `equals()` và `hashCode()`).",
      "Vị trí bộ nhớ.",
    ],
    answer: 2,
    explanation:
      "HashSet tìm kiếm bằng cách so sánh hashcode và equals() của đối tượng được cung cấp với các phần tử trong set [32, 41].",
  },
  {
    id: 2107,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Wildcard nào sau đây được sử dụng để giới hạn kiểu tham số là kiểu con của một kiểu cụ thể (Upper Bounded Wildcard)?",
    options: ["<? extends T>", "<? super T>", "<?>"],
    answer: 0,
    explanation:
      "Upper Bounded Wildcards được chỉ định bằng `? extends T` [22, 42].",
  },
  {
    id: 2108,
    topic: "Generics & Collections",
    type: "radio",
    question:
      "Điều kiện nào sau đây phải được đáp ứng nếu bạn muốn truyền một đối tượng cho phương thức `Collections.sort(List list, Comparator c)`?",
    options: [
      "Các đối tượng trong List phải là Serializable.",
      "Các đối tượng trong List phải là Comparable.",
      "Đối tượng Comparator phải triển khai giao diện `Comparator`.",
      "List phải là `ArrayList`.",
    ],
    answer: 2,
    explanation:
      "Nếu sử dụng phương thức `Collections.sort()` với hai đối số, đối số thứ hai (myCompare) PHẢI là một đối tượng triển khai giao diện Comparator [78, 85].",
  },
  {
    id: 2110,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Sự kiện không mong muốn hoặc bất ngờ xảy ra trong quá trình thực thi chương trình (tại thời điểm runtime) và làm gián đoạn luồng lệnh bình thường được gọi là gì?",
    options: [
      "Syntax Error",
      "Bug (Logic Error)",
      "Exception",
      "Compile-time Error",
    ],
    answer: 2,
    explanation:
      "An exception là một sự kiện không mong muốn hoặc bất ngờ xảy ra trong quá trình thực thi chương trình (runtime) và làm gián đoạn luồng lệnh bình thường [1].",
  },
  {
    id: 2111,
    topic: "Exception Handling",
    type: "radio",
    question: "Sự khác biệt cơ bản giữa Error và Exception là gì?",
    options: [
      "Error phải được khai báo bằng `throws`, Exception thì không.",
      "Error đại diện cho vấn đề nghiêm trọng mà ứng dụng KHÔNG nên cố gắng xử lý, trong khi Exception là điều kiện MÀ ứng dụng CÓ THỂ cố gắng xử lý.",
      "Exception luôn xảy ra ở thời điểm biên dịch (compile time), Error chỉ xảy ra ở runtime.",
      "Error có thể được ném ra thủ công bằng từ khóa `throw`, Exception thì không.",
    ],
    answer: 1,
    explanation:
      "An Error đại diện cho vấn đề nghiêm trọng mà một ứng dụng hợp lý KHÔNG nên cố gắng xử lý, trong khi Exception đại diện cho một điều kiện mà một ứng dụng hợp lý CÓ THỂ cố gắng xử lý [2, 3].",
  },
  {
    id: 2112,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi một phương thức gặp tình huống không hợp lệ và phát hiện rằng nó không thể tiếp tục, điều gì xảy ra tiếp theo?",
    options: [
      "Phương thức này kết thúc ngay lập tức và trả về giá trị null.",
      "Nó tạo ra một đối tượng Exception thuộc lớp thích hợp và ném (throws) nó cho phương thức gọi.",
      "Nó chỉ đơn giản ghi lại thông báo lỗi và tiếp tục thực thi.",
      "Trình biên dịch Java tự động thêm khối `finally`.",
    ],
    answer: 1,
    explanation:
      "Khi một phương thức gặp tình huống không hợp lệ và phát hiện rằng nó không thể tiếp tục, nó tạo ra một đối tượng exception thuộc lớp thích hợp và ném nó cho phương thức gọi [4, 5].",
  },
  {
    id: 2113,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối mã nào được sử dụng để chứa các câu lệnh mà bạn nghi ngờ có thể ném ra ngoại lệ (rise an exception)?",
    options: ["catch", "throw", "try", "finally"],
    answer: 2,
    explanation:
      "Các câu lệnh có thể ném ra ngoại lệ được chứa trong một khối `try` [6-8].",
  },
  {
    id: 2114,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong xử lý ngoại lệ tùy chỉnh, có bao nhiêu từ khóa được sử dụng trong Java?",
    options: [
      "3 (`try`, `catch`, `finally`)",
      "4 (`try`, `catch`, `throw`, `throws`)",
      "5 (`try`, `catch`, `throw`, `throws`, `finally`)",
      "6 (`try`, `catch`, `finally`, `throw`, `throws`, `assert`)",
    ],
    answer: 2,
    explanation:
      "Có 5 từ khóa được sử dụng trong xử lý ngoại lệ của Java: `try`, `catch`, `throw`, `throws`, `finally` [9].",
  },
  {
    id: 2115,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Thứ tự nào sau đây là đúng trong mô tả cách JVM xử lý ngoại lệ theo mặc định (Default exception handling)?",
    options: [
      "Tạo Exception Object -> JVM tìm kiếm Call Stack -> Gọi Exception Handler -> Chương trình kết thúc bình thường.",
      "Tạo Exception Object -> JVM tìm kiếm Call Stack -> Nếu không tìm thấy Handler, gọi Default Exception Handler -> Chương trình kết thúc bất thường.",
      "JVM tìm kiếm Call Stack -> Tạo Exception Object -> Gọi Exception Handler -> Chương trình kết thúc bất thường.",
      "Gọi Garbage Collector -> Tạo Exception Object -> JVM tìm kiếm Call Stack.",
    ],
    answer: 1,
    explanation:
      "Khi ngoại lệ xảy ra, phương thức tạo Exception Object và chuyển cho JVM [5]. JVM tìm Call Stack để tìm Exception handler [10]. Nếu không tìm thấy, JVM chuyển cho default exception handler, in thông tin và chấm dứt chương trình bất thường [11].",
  },
  {
    id: 2116,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Thông tin nào sau đây KHÔNG được chứa trong Exception Object khi nó được ném ra?",
    options: [
      "Tên của ngoại lệ.",
      "Mô tả về ngoại lệ.",
      "Địa chỉ IP của máy chủ.",
      "Trạng thái hiện tại của chương trình nơi ngoại lệ xảy ra.",
    ],
    answer: 2,
    explanation:
      "Exception Object chứa tên và mô tả của ngoại lệ, và trạng thái hiện tại của chương trình nơi ngoại lệ xảy ra [5, 12].",
  },
  {
    id: 2117,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Cụm từ 'throwing an Exception' (ném ngoại lệ) mô tả hành động nào?",
    options: [
      "Ghi lại lỗi vào log file.",
      "Tạo ra Exception Object và chuyển nó cho hệ thống runtime (JVM).",
      "Kết thúc chương trình bất thường.",
      "Định nghĩa khối `catch` phù hợp.",
    ],
    answer: 1,
    explanation:
      "Việc tạo Exception Object và chuyển nó cho JVM được gọi là throwing an Exception [10].",
  },
  {
    id: 2118,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong trường hợp không tìm thấy Exception Handler phù hợp trong Call Stack, điều gì xảy ra?",
    options: [
      "JVM cố gắng gọi lại phương thức gây lỗi.",
      "JVM chuyển Exception Object cho default exception handler, dẫn đến chương trình chấm dứt bất thường.",
      "Chương trình sẽ tiếp tục chạy nhưng bỏ qua phần gây lỗi.",
      "Nó ném lại ngoại lệ cho người dùng.",
    ],
    answer: 1,
    explanation:
      "Nếu JVM tìm kiếm toàn bộ Call Stack mà không tìm thấy handler phù hợp, nó chuyển Exception Object cho default exception handler (là một phần của JVM), handler này in thông tin và chấm dứt chương trình bất thường [11].",
  },
  {
    id: 2119,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Cấu trúc dữ liệu nào lưu trữ danh sách các phương thức đã được gọi để đi đến phương thức xảy ra ngoại lệ, và được JVM sử dụng để tìm kiếm Exception Handler?",
    options: ["Heap Memory", "Thread Pool", "Call Stack", "String Pool"],
    answer: 2,
    explanation:
      "Danh sách các phương thức đã được gọi được gọi là Call Stack [10]. JVM tìm kiếm Call Stack theo thứ tự ngược lại để tìm Exception Handler [10].",
  },
  {
    id: 2120,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong xử lý ngoại lệ tùy chỉnh, nếu một ngoại lệ xảy ra trong khối `try`, nó sẽ được ném (thrown). Sau đó, code sẽ chuyển đến khối nào để xử lý nếu có sẵn?",
    options: [
      "finally block",
      "catch block",
      "try block tiếp theo",
      "throw statement",
    ],
    answer: 1,
    explanation:
      "Nếu một ngoại lệ xảy ra trong khối `try`, nó sẽ được ném, và code của bạn có thể bắt và xử lý ngoại lệ này bằng cách sử dụng khối `catch` [6].",
  },
  {
    id: 2121,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Mỗi khối `catch` hoạt động như một Exception Handler và phải chỉ định một kiểu ngoại lệ (ExceptionType) nào?",
    options: [
      "Bất kỳ lớp nào.",
      "Lớp phải kế thừa từ `Object`.",
      "Lớp phải kế thừa từ `Throwable`.",
      "Lớp phải là `RuntimeException`.",
    ],
    answer: 2,
    explanation:
      "ExceptionType trong khối catch phải là tên của một class kế thừa từ `Throwable` [13, 14].",
  },
  {
    id: 2122,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Theo hệ thống phân cấp ngoại lệ của Java, `Exception` và `Error` đều là lớp con trực tiếp của lớp nào?",
    options: ["Object", "RuntimeException", "Throwable", "BaseException"],
    answer: 2,
    explanation: "Tất cả các ngoại lệ và lỗi đều kế thừa lớp `Throwable` [14].",
  },
  {
    id: 2123,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Mục đích chính của việc xử lý ngoại lệ (Exception Handling) là gì?",
    options: [
      "Ghi lại lỗi vào cơ sở dữ liệu.",
      "Cho phép chương trình quản lý các lỗi runtime và tiếp tục thực thi một cách suôn sẻ.",
      "Buộc các lập trình viên sử dụng từ khóa `throws`.",
      "Tăng tốc độ biên dịch mã nguồn.",
    ],
    answer: 1,
    explanation:
      "Xử lý ngoại lệ cho phép chương trình quản lý các lỗi runtime (như exception) và tiếp tục thực thi một cách suôn sẻ [1].",
  },
  {
    id: 2124,
    topic: "Exception Handling",
    type: "radio",
    question: "Khi nào thì một lỗi logic (Bugs/Logic errors) xảy ra?",
    options: [
      "Khi mã Java không biên dịch.",
      "Khi chương trình thực hiện một hoạt động không hợp lệ, ví dụ chia cho 0 [15].",
      "Khi chương trình chạy nhưng không thực hiện những gì bạn mong đợi.",
      "Khi JVM gặp sự cố nội bộ.",
    ],
    answer: 2,
    explanation:
      "Bugs (logic errors) xảy ra khi chương trình chạy nhưng chỉ đơn giản là không làm những gì bạn mong đợi [16]. Lỗi logic cũng là một loại lỗi [15].",
  },
  {
    id: 2125,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khái niệm Exception thường được sử dụng để mô tả loại lỗi nào trong Java?",
    options: [
      "Lỗi cú pháp (Syntax errors).",
      "Lỗi logic (Logic errors).",
      "Các lỗi thời gian chạy (Runtime errors) phổ biến.",
      "Lỗi phần cứng.",
    ],
    answer: 2,
    explanation:
      "Các lỗi thời gian chạy phổ biến nhất được phân loại là exception [1].",
  },
  {
    id: 2126,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Ngoại lệ nào xảy ra khi một chương trình cố gắng mở một tệp không tồn tại?",
    options: [
      "NullPointerException",
      "ArithmeticException",
      "FileNotFoundException",
      "NoSuchMethodException",
    ],
    answer: 2,
    explanation:
      "FileNotFoundException là một ví dụ phổ biến xảy ra khi một chương trình cố gắng mở một tệp không tồn tại [2, 17].",
  },
  {
    id: 2127,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì xảy ra nếu code không bao gồm `try-catch` khi một ngoại lệ (ví dụ: `ArrayIndexOutOfBoundsException`) xảy ra?",
    options: [
      "Trình biên dịch tự động thêm `try-catch`.",
      "JVM chấm dứt chương trình một cách bất thường, và các câu lệnh sau vị trí lỗi sẽ không bao giờ được thực thi.",
      "Ngoại lệ được bỏ qua.",
      "Lỗi bị xử lý bởi hệ điều hành.",
    ],
    answer: 1,
    explanation:
      "Nếu không có `try-catch`, JVM sẽ chấm dứt chương trình bất thường, và câu lệnh cuối cùng sẽ không bao giờ được thực thi [7].",
  },
  {
    id: 2128,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi xử lý đa ngoại lệ, bạn nên đặt nhiều câu lệnh có khả năng ném ngoại lệ trong cùng một khối `try` và cung cấp điều gì?",
    options: [
      "Một khối `catch` duy nhất cho tất cả các ngoại lệ.",
      "Các khối `catch` riêng biệt cho mỗi kiểu ngoại lệ được mong đợi.",
      "Chỉ sử dụng từ khóa `throws` trong khai báo phương thức.",
      "Chỉ sử dụng khối `finally`.",
    ],
    answer: 1,
    explanation:
      "Đặt tất cả các câu lệnh có khả năng ném ngoại lệ trong khối `try` và cung cấp các exception handler riêng biệt trong khối `catch` cho mỗi ngoại lệ [13].",
  },
  {
    id: 2129,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi một phương thức ném một ngoại lệ, nó có thể được lan truyền (propagated) giữa các phương thức cho đến khi một trong số chúng thực hiện hành động nào?",
    options: [
      "Gọi Garbage Collector.",
      "Dừng chương trình.",
      "Catch (bắt) ngoại lệ.",
      "Thực hiện đa hình (polymorphism).",
    ],
    answer: 2,
    explanation:
      "Các ngoại lệ có thể được lan truyền giữa các phương thức cho đến khi một trong số chúng bắt (catches) ngoại lệ [4].",
  },
  {
    id: 2130,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức bắt một ngoại lệ, nó có thể thực hiện những hành động nào?",
    options: [
      "Chỉ có thể ghi lại ngoại lệ.",
      "Chỉ có thể ném lại ngoại lệ.",
      "Ném lại ngoại lệ hoặc xử lý nó một cách duyên dáng (gracefully), đảm bảo chương trình tiếp tục chạy.",
      "Buộc phương thức gọi phải sử dụng `finally`.",
    ],
    answer: 2,
    explanation:
      "Phương thức bắt có thể ném lại (rethrow) ngoại lệ hoặc xử lý nó một cách duyên dáng, đảm bảo chương trình tiếp tục chạy suôn sẻ [4].",
  },
  {
    id: 2131,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Lớp `Exception` trong hệ thống phân cấp ngoại lệ được sử dụng cho những điều kiện nào?",
    options: [
      "Các lỗi liên quan đến môi trường runtime của Java (JRE).",
      "Các điều kiện ngoại lệ mà chương trình người dùng nên bắt.",
      "Các lỗi logic (bugs).",
      "Các lỗi cú pháp (syntax errors).",
    ],
    answer: 1,
    explanation:
      "Lớp `Exception` được sử dụng cho các điều kiện ngoại lệ mà chương trình người dùng nên bắt [18].",
  },
  {
    id: 2132,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Lớp `Error` trong hệ thống phân cấp ngoại lệ được sử dụng cho những điều kiện nào?",
    options: [
      "Các điều kiện ngoại lệ mà chương trình người dùng nên bắt.",
      "Các lỗi có liên quan đến hệ thống runtime của Java (JVM/JRE).",
      "Các ngoại lệ được kiểm tra ở thời điểm biên dịch.",
      "Các ngoại lệ do người dùng định nghĩa.",
    ],
    answer: 1,
    explanation:
      "Errors được hệ thống runtime của Java (JVM/JRE) sử dụng để chỉ ra các lỗi liên quan đến môi trường runtime [5, 18].",
  },
  {
    id: 2133,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Ví dụ nào sau đây đại diện cho một Error (vấn đề nghiêm trọng trong môi trường runtime)?",
    options: [
      "NullPointerException",
      "StackOverflowError",
      "NumberFormatException",
      "ArrayIndexOutofBoundException",
    ],
    answer: 1,
    explanation: "StackOverflowError là một ví dụ của Error [5].",
  },
  {
    id: 2134,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong xử lý ngoại lệ mặc định, Exception Object được bàn giao cho ai để bắt đầu quá trình xử lý?",
    options: [
      "Trình biên dịch Java (javac).",
      "Hệ thống runtime (JVM).",
      "Garbage Collector.",
      "Hệ điều hành.",
    ],
    answer: 1,
    explanation:
      "Phương thức tạo Exception Object và chuyển nó cho hệ thống runtime (JVM) [5, 10].",
  },
  {
    id: 2135,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Mục đích của việc sử dụng các khối `try-catch` là gì khi bạn có một đoạn code có thể ném ngoại lệ?",
    options: [
      "Để ngăn chặn ngoại lệ xảy ra.",
      "Để đảm bảo rằng mã vẫn biên dịch, ngay cả khi ngoại lệ không được xử lý.",
      "Để thực thi code sau đó và tiếp tục luồng chương trình bình thường, ngay cả khi ngoại lệ xảy ra.",
      "Để làm cho JVM bỏ qua ngoại lệ đó.",
    ],
    answer: 2,
    explanation:
      "Để thực thi câu lệnh cuối cùng và tiếp tục luồng chương trình bình thường, cần phải bao gồm mệnh đề `try-catch` [7, 19, 20].",
  },
  {
    id: 2136,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối nào là tùy chọn (optional) trong cấu trúc `try-catch-finally`?",
    options: [
      "try block",
      "catch block",
      "finally block",
      "Cả `catch` và `finally`",
    ],
    answer: 2,
    explanation:
      "Khối `finally` là tùy chọn [13]. Khối `catch` cũng là tùy chọn nếu có `finally` và ngoại lệ được khai báo bằng `throws` [21, 22]. Tuy nhiên, nếu không có `catch`, `try` phải có `finally` hoặc khai báo ngoại lệ [21, 22].",
  },
  {
    id: 2137,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối `catch` nào có thể bắt được ngoại lệ `NumberFormatException`?",
    options: [
      "catch(IOException e)",
      "catch(ClassNotFoundException e)",
      "catch(NumberFormatException e)",
      "catch(ArrayIndexOutofBoundException e)",
    ],
    answer: 2,
    explanation:
      "Mỗi khối catch phải có khả năng xử lý ngoại lệ của loại được chỉ định bởi đối số của nó [13]. `NumberFormatException` là một loại ngoại lệ có thể bắt [17].",
  },
  {
    id: 2138,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Phương thức nào thuộc lớp `Throwable` mà tất cả các ngoại lệ và lỗi kế thừa, được sử dụng để in ra dấu vết của ngăn xếp (stack trace)?",
    options: [
      "getMessage()",
      "printStackTrace()",
      "getStackTrace()",
      "toString()",
    ],
    answer: 1,
    explanation:
      "Phương thức `printStackTrace()` được kế thừa bởi tất cả các ngoại lệ, được sử dụng để in ra dấu vết ngăn xếp, đặc biệt nếu bạn không thể phục hồi từ ngoại lệ [14, 23].",
  },
  {
    id: 2139,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong ví dụ code ném ra `NullPointerException`, dòng lệnh `System.out.println(str.length())` thất bại. Thông tin nào sau đây KHÔNG được hiển thị trong đầu ra của JVM?",
    options: [
      "Tên của ngoại lệ (`java.lang.NullPointerException`).",
      "Mô tả chi tiết ngoại lệ.",
      "Tên của class và số dòng xảy ra lỗi.",
      "Thông báo 'Hello....I’m here to be executed!'.",
    ],
    answer: 3,
    explanation:
      "Đầu ra mặc định của JVM bao gồm tên và mô tả ngoại lệ cùng với luồng của Call Stack (class và dòng) [12]. Câu lệnh sau khi lỗi (nếu không có handler) sẽ không được thực thi [7].",
  },
  {
    id: 2140,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong xử lý đa ngoại lệ, nếu một khối `catch` được đặt là `catch(Exception ex)`, điều gì có thể xảy ra?",
    options: [
      "Nó chỉ bắt được các Checked Exceptions.",
      "Nó chỉ bắt được các Unchecked Exceptions.",
      "Nó bắt TẤT CẢ các ngoại lệ (kể cả Runtime Exceptions) và có thể làm cho các khối `catch` cụ thể hơn sau nó trở nên vô dụng.",
      "Nó phải là khối `catch` đầu tiên.",
    ],
    answer: 2,
    explanation:
      "Catch block với kiểu `Exception` là mẹ của tất cả các catch arguments; nó sẽ bắt bất kỳ ngoại lệ nào, bao gồm cả runtime (unchecked) exceptions [24, 25].",
  },
  {
    id: 2141,
    topic: "Exception Handling",
    type: "radio",
    question: "Khi ngoại lệ được ném ra, nó luôn được ném trở lại cho ai?",
    options: [
      "Lớp cha của lớp hiện tại.",
      "JVM.",
      "Phương thức gọi (caller).",
      "Lớp Exception cơ sở.",
    ],
    answer: 2,
    explanation:
      "An exception luôn được ném trở lại cho phương thức gọi (the caller) [26, 27].",
  },
  {
    id: 2142,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong hệ thống phân cấp, lớp nào được sử dụng bởi JVM để chỉ ra các vấn đề liên quan đến chính môi trường runtime (JRE) (ví dụ: `StackOverflowError`)?",
    options: [
      "java.lang.Exception",
      "java.lang.RuntimeException",
      "java.lang.Error",
      "java.lang.Throwable",
    ],
    answer: 2,
    explanation:
      "Errors được JVM sử dụng để chỉ ra các lỗi liên quan đến môi trường runtime [5, 18].",
  },
  {
    id: 2143,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Loại lỗi nào mà trình biên dịch Java không thể biên dịch mã nếu vi phạm?",
    options: [
      "Runtime errors",
      "Bugs (Logic errors)",
      "Syntax errors",
      "Exceptions",
    ],
    answer: 2,
    explanation:
      "Syntax errors là vi phạm quy tắc ngữ pháp của Java; mã Java sẽ không biên dịch [15, 16].",
  },
  {
    id: 2144,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi một phương thức bị lỗi và ném ra một ngoại lệ, danh sách có thứ tự các phương thức đã được gọi (Call Stack) giúp chúng ta điều gì?",
    options: [
      "Tăng tốc độ Garbage Collection.",
      "Xác định nơi ngoại lệ được bắt.",
      "Tái cấu trúc mã nguồn.",
      "Gửi thông báo lỗi cho người dùng cuối.",
    ],
    answer: 1,
    explanation:
      "JVM tìm kiếm Call Stack để tìm Exception handler, bắt đầu từ phương thức xảy ra lỗi và đi ngược lên [10].",
  },
  {
    id: 2145,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong xử lý ngoại lệ, nếu một phương thức bắt được một ngoại lệ, hành động 'xử lý duyên dáng' (handle it gracefully) thường có nghĩa là gì?",
    options: [
      "Chấm dứt chương trình ngay lập tức.",
      "Gửi một yêu cầu đến JVM để chạy Garbage Collector.",
      "Thực hiện một số code khôi phục để cho phép chương trình tiếp tục chạy suôn sẻ.",
      "Khai báo ngoại lệ bằng từ khóa `throws`.",
    ],
    answer: 2,
    explanation:
      "Phương thức bắt ngoại lệ có thể xử lý nó một cách duyên dáng (gracefully), đảm bảo chương trình tiếp tục chạy suôn sẻ [4].",
  },
  {
    id: 2146,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một khối `try` thực thi mà không có ngoại lệ, khối nào sau đây sẽ được thực thi ngay sau đó?",
    options: [
      "Khối `catch` đầu tiên.",
      "Khối `finally`.",
      "Phần code sau khối `finally` (hoặc sau `catch` nếu không có `finally`).",
      "Chương trình kết thúc.",
    ],
    answer: 1,
    explanation:
      "Nếu khối `try` thành công (không có ngoại lệ), luồng lệnh bỏ qua khối `catch` và chuyển đến khối `finally` [28, 29].",
  },
  {
    id: 2147,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một ngoại lệ được ném ra trong khối `try` nhưng không có khối `catch` nào khớp với kiểu ngoại lệ đó, điều gì xảy ra?",
    options: [
      "Khối `finally` được bỏ qua.",
      "Ngoại lệ được chuyển ngay lập tức cho default exception handler (JVM), và khối `finally` (nếu có) vẫn chạy trước khi kết thúc bất thường.",
      "Trình biên dịch yêu cầu thêm khối `catch`.",
      "Chương trình tiếp tục chạy bình thường.",
    ],
    answer: 1,
    explanation:
      "Nếu không có handler nào tìm thấy, JVM sẽ sử dụng default handler để kết thúc chương trình bất thường [11]. Tuy nhiên, nếu có khối `finally`, nó vẫn chạy [28].",
  },
  {
    id: 2148,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong ngữ cảnh `try-catch`, 'xử lý ngoại lệ' (handling the exception) có nghĩa là gì?",
    options: [
      "Thực thi câu lệnh `throw new Exception()`.",
      "Viết code trong khối `catch` để khôi phục hoặc phản hồi lại lỗi.",
      "Sử dụng `throws` trong khai báo phương thức.",
      "Đảm bảo rằng code không bao giờ ném ra ngoại lệ.",
    ],
    answer: 1,
    explanation:
      "Nếu bạn sẵn sàng xử lý ngoại lệ, hãy bao bọc lệnh gọi rủi ro trong `try/catch`, và đặt code xử lý/khôi phục ngoại lệ vào khối `catch` [30].",
  },
  {
    id: 2149,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi một ngoại lệ là một đối tượng (object), điều gì cho phép một khối `catch` có thể bắt được nhiều loại ngoại lệ (ví dụ: bắt `IOException` có thể bắt `FileNotFoundException`)?",
    options: [
      "Inheritance (Kế thừa).",
      "Encapsulation (Đóng gói).",
      "Pass-by-value.",
      "Method Overloading.",
    ],
    answer: 0,
    explanation:
      "Ngoại lệ là đối tượng, và chúng có thể được tham chiếu đa hình (polymorphically) [31, 32]. Ví dụ, `FileNotFoundException` là lớp con của `IOException` [33].",
  },
  {
    id: 2150,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Mục đích của việc sử dụng `printStackTrace()` trong khối `catch` là gì?",
    options: [
      "Chỉ để in thông báo lỗi.",
      "Để ném lại ngoại lệ cho phương thức gọi.",
      "Để lấy dấu vết ngăn xếp (stack trace) chi tiết giúp debug, nếu không thể khôi phục từ ngoại lệ.",
      "Để ngăn chặn ngoại lệ lan truyền.",
    ],
    answer: 2,
    explanation:
      "Nếu không thể khôi phục từ ngoại lệ, ít nhất hãy lấy dấu vết ngăn xếp bằng cách sử dụng phương thức `printStackTrace()` [23].",
  },
  {
    id: 2151,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi JVM tìm kiếm Exception handler trong Call Stack, nó bắt đầu tìm kiếm từ đâu?",
    options: [
      "Từ phương thức đầu tiên được gọi trong chương trình.",
      "Từ phương thức trong đó ngoại lệ xảy ra, và đi ngược lên Call Stack.",
      "Luôn luôn từ phương thức `main()`.",
      "Từ khối `try` gần nhất.",
    ],
    answer: 1,
    explanation:
      "JVM bắt đầu tìm kiếm từ phương thức mà ngoại lệ xảy ra, và tiếp tục thông qua Call Stack theo thứ tự ngược lại [10].",
  },
  {
    id: 2152,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Loại lỗi nào dưới đây được coi là lỗi có thể xảy ra ở thời điểm chạy (Runtime error)?",
    options: [
      "Violation of Java's grammatical rules.",
      "ArithmeticException (ví dụ: chia cho 0).",
      "Mã không làm những gì được mong đợi.",
      "Lỗi cú pháp.",
    ],
    answer: 1,
    explanation:
      "Runtime errors xảy ra khi chương trình đang chạy [16]. `ArithmeticException` là một loại Runtime Exception (unchecked exception) [34].",
  },
  {
    id: 2153,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong cú pháp `try-catch`, đối tượng được tạo ra trong khối `catch(ExceptionType exObj)` được gọi là gì?",
    options: [
      "Exception Generator.",
      "Exception Handler.",
      "Exception Argument.",
      "Exception Object.",
    ],
    answer: 3,
    explanation:
      "Trong `catch(ExceptionType exObj)`, `exObj` là biến tham chiếu đối tượng ngoại lệ được bắt. Ngoại lệ được bắt là một đối tượng [13, 31].",
  },
  {
    id: 2154,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi thiết kế các phương thức, sử dụng từ khóa `throws` trong khai báo phương thức giúp thông báo điều gì cho phương thức gọi?",
    options: [
      "Phương thức này là `final`.",
      "Phương thức này có thể ném ra một ngoại lệ nhất định, buộc người gọi phải đối phó với rủi ro đó.",
      "Phương thức này không thể bị ghi đè.",
      "Phương thức này là `static`.",
    ],
    answer: 1,
    explanation:
      "Khi một phương thức gặp tình huống không hợp lệ... nó ném một ngoại lệ để báo hiệu vấn đề. Điều này đi kèm với việc thêm từ khóa `throws` theo sau là kiểu ngoại lệ trong khai báo phương thức [4, 18].",
  },
  {
    id: 2155,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là hợp pháp khi sử dụng khối `try`?",
    options: [
      "Chỉ có `try` đứng một mình.",
      "`try` theo sau là `catch` hoặc `finally`, hoặc cả hai.",
      "`try` phải luôn theo sau là `catch` và `finally`.",
      "Code có thể được đặt giữa `try` và `catch`.",
    ],
    answer: 1,
    explanation:
      "Một khối `try` PHẢI được theo sau bởi `catch` hoặc `finally` [21]. Không thể đặt code giữa `try` và `catch` [21].",
  },
  {
    id: 2156,
    topic: "Exception Handling",
    type: "radio",
    question: "Khi nào thì xảy ra `StringIndexOutOfBoundException`?",
    options: [
      "Cố gắng chuyển đổi chuỗi thành số.",
      "Cố gắng truy cập một chỉ số không hợp lệ trong một mảng.",
      "Cố gắng truy cập một chỉ số không hợp lệ trong một chuỗi.",
      "Cố gắng sử dụng một đối tượng null.",
    ],
    answer: 2,
    explanation:
      "StringIndexOutOfBoundException xảy ra khi truy cập một phần tử ngoài giới hạn của chuỗi [35].",
  },
  {
    id: 2157,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối code nào được sử dụng để bắt và xử lý một ngoại lệ được ném ra từ khối `try`?",
    options: ["throw", "throws", "catch", "assert"],
    answer: 2,
    explanation:
      "Code của bạn có thể bắt và xử lý ngoại lệ này bằng cách sử dụng khối `catch` [6].",
  },
  {
    id: 2158,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu chương trình chạy mà không có `try-catch` và xảy ra ngoại lệ, luồng nào trong Call Stack sẽ được in ra để chỉ ra nơi ngoại lệ bắt nguồn?",
    options: [
      "Flow of Call Stack",
      "Flow of Code",
      "Flow of Compiler",
      "Flow of Memory",
    ],
    answer: 0,
    explanation:
      "Đầu ra của chương trình không có handler hiển thị 'flow of Call Stack' [12].",
  },
  {
    id: 2159,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì sẽ xảy ra với một đối tượng được tạo ra trong khối `try` nếu một ngoại lệ xảy ra trước khi khối `try` hoàn tất?",
    options: [
      "Đối tượng bị mất ngay lập tức.",
      "Đối tượng vẫn nằm trên Stack.",
      "Đối tượng có thể đủ điều kiện cho Garbage Collection (GC) nếu không còn tham chiếu nào đến nó.",
      "Đối tượng được chuyển đến khối `catch`.",
    ],
    answer: 2,
    explanation:
      "Khi một ngoại lệ xảy ra trong `try`, phần còn lại của `try` không chạy [20]. Đối tượng nằm trên Heap [1, 36]. Nếu không còn tham chiếu hợp lệ (scope kết thúc hoặc bị hủy), nó đủ điều kiện cho GC [29, 30].",
  },
  {
    id: 2160,
    topic: "Exception Handling",
    type: "radio",
    question: "Checked Exceptions là gì?",
    options: [
      "Các ngoại lệ chỉ xảy ra khi code lỗi logic.",
      "Các ngoại lệ KHÔNG được kiểm tra ở thời điểm biên dịch.",
      "Các ngoại lệ được kiểm tra ở thời điểm biên dịch, buộc phải xử lý hoặc khai báo.",
      "Các ngoại lệ luôn được JVM xử lý mặc định.",
    ],
    answer: 2,
    explanation:
      "Checked Exceptions là các ngoại lệ được kiểm tra ở thời điểm biên dịch. Nếu một phương thức ném ra checked exception, nó phải xử lý hoặc chỉ định (specify) ngoại lệ đó bằng từ khóa `throws` [37-39].",
  },
  {
    id: 2161,
    topic: "Exception Handling",
    type: "radio",
    question: "Unchecked Exceptions còn được gọi là gì?",
    options: [
      "Compile-time Exceptions",
      "User-defined Exceptions",
      "Runtime Exceptions",
      "Final Exceptions",
    ],
    answer: 2,
    explanation:
      "Unchecked Exceptions là các ngoại lệ không được kiểm tra ở thời điểm biên dịch [33], chúng được biết đến là Runtime Exceptions [39, 40].",
  },
  {
    id: 2162,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì xảy ra nếu code ném ra một Checked Exception mà không được xử lý hoặc khai báo bằng `throws`?",
    options: [
      "Chương trình chạy nhưng ném ngoại lệ ở runtime.",
      "Trình biên dịch sẽ báo lỗi (compile-time error).",
      "JVM sẽ bỏ qua ngoại lệ.",
      "Trình biên dịch tự động bọc code trong `try-catch`.",
    ],
    answer: 1,
    explanation:
      "Nếu một phương thức ném Checked Exception mà không xử lý hoặc khai báo, chương trình sẽ không biên dịch [41, 42]. Trình biên dịch buộc bạn phải xử lý nó [39].",
  },
  {
    id: 2163,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Ngoại lệ nào sau đây là một ví dụ điển hình của Unchecked Exception?",
    options: [
      "IOException",
      "FileNotFoundException",
      "NullPointerException",
      "InterruptedException",
    ],
    answer: 2,
    explanation:
      "NullPointerException là một ví dụ của Unchecked (Runtime) Exception [17, 18, 38, 39].",
  },
  {
    id: 2164,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Tại sao các Runtime Exceptions (Unchecked) không cần phải được khai báo hoặc bắt (try/catch)?",
    options: [
      "Vì chúng không nghiêm trọng.",
      "Vì trình biên dịch không bận tâm kiểm tra chúng, do chúng thường xuất phát từ lỗi logic trong code mà lẽ ra phải được khắc phục trong quá trình phát triển.",
      "Vì chúng luôn được JVM xử lý tự động.",
      "Vì chúng là các lỗi cú pháp.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch không kiểm tra RuntimeExceptions [40, 43]. Hầu hết chúng đến từ lỗi logic trong code, thay vì các điều kiện runtime không thể đoán trước hoặc ngăn chặn [44].",
  },
  {
    id: 2165,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức ném ra Checked Exception, lựa chọn nào sau đây thỏa mãn trình biên dịch, mà không cần sử dụng `try/catch`?",
    options: [
      "Định nghĩa khối `finally`.",
      "Khai báo phương thức đó bằng `throws ExceptionType` (ducking).",
      "Biến đổi ngoại lệ thành Unchecked Exception.",
      "Sử dụng `System.gc()`.",
    ],
    answer: 1,
    explanation:
      "Để thỏa mãn trình biên dịch mà không `try/catch`, bạn có thể 'duck' ngoại lệ bằng cách khai báo rằng phương thức của bạn ném ra ngoại lệ đó (`throws`) [41, 45-47].",
  },
  {
    id: 2166,
    topic: "Exception Handling",
    type: "radio",
    question: "Trường hợp nào sau đây là một ví dụ của Checked Exception?",
    options: [
      "ArithmeticException",
      "NumberFormatException",
      "ClassCastException",
      "IOException",
    ],
    answer: 3,
    explanation:
      "IOException là một ví dụ của Checked Exception [17, 39, 41]. ArithmeticException, NumberFormatException, và ClassCastException là Runtime Exceptions [17, 39].",
  },
  {
    id: 2167,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong ví dụ đọc tệp, tại sao việc chỉ định `IOException` trong mệnh đề `throws` lại hợp lệ ngay cả khi ngoại lệ thực tế là `FileNotFoundException`?",
    options: [
      "Vì `IOException` là một Unchecked Exception.",
      "Vì `FileNotFoundException` là một lớp con của `IOException`, và việc khai báo lớp cha là đủ.",
      "Vì `FileNotFoundException` không cần khai báo.",
      "Đây là lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Vì `FileNotFoundException` là một lớp con của `IOException`, nên chỉ cần chỉ định `IOException` trong danh sách `throws` để chương trình biên dịch không lỗi [33].",
  },
  {
    id: 2168,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức bị khai báo là `throws CheckedException`, thì mỗi lần phương thức đó được gọi, người gọi sẽ bị ép buộc thực hiện điều gì?",
    options: [
      "Gọi `System.gc()`.",
      "Luôn luôn ném lại ngoại lệ.",
      "Bọc lời gọi phương thức đó trong một mệnh đề `try-catch` hoặc khai báo ngoại lệ bằng `throws`.",
      "Khởi tạo một đối tượng mới.",
    ],
    answer: 2,
    explanation:
      "Khi bạn khai báo rằng một phương thức ném một ngoại lệ, Java buộc bạn phải bọc phương thức đó bằng một mệnh đề `try-catch` mỗi khi bạn cố gắng gọi nó (hoặc khai báo tiếp) [47-49].",
  },
  {
    id: 2169,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Tại sao một số lập trình viên chọn bắt (catch) Runtime Exceptions (Unchecked) mặc dù trình biên dịch không yêu cầu?",
    options: [
      "Để làm cho code trông phức tạp hơn.",
      "Vì các Runtime Exception không thể được bắt.",
      "Để thử khôi phục từ tình huống bất thường hoặc cung cấp thông báo lỗi thân thiện hơn cho người dùng.",
      "Để đảm bảo rằng mã vẫn biên dịch.",
    ],
    answer: 2,
    explanation:
      "Bạn có thể tự do bắt và khai báo RuntimeExceptions [40]. Bạn có thể muốn bắt chúng để khôi phục hoặc in ra thông báo cho người dùng và stack trace [40, 44].",
  },
  {
    id: 2170,
    topic: "Exception Handling",
    type: "radio",
    question: "Khái niệm 'Ducking' một ngoại lệ có nghĩa là gì?",
    options: [
      "Bọc code trong `try/catch`.",
      "Bỏ qua việc xử lý ngoại lệ.",
      "Xử lý ngoại lệ và ném lại.",
      "Khai báo rằng phương thức hiện tại ném ra ngoại lệ đó bằng từ khóa `throws`.",
    ],
    answer: 3,
    explanation:
      "'Ducking' là hành động khai báo ngoại lệ bằng từ khóa `throws` trong phương thức của bạn, để phương thức gọi xử lý nó [45, 46, 50]. Ducking chỉ trì hoãn điều không thể tránh khỏi [46].",
  },
  {
    id: 2171,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu phương thức `main()` duck (khai báo `throws`) một ngoại lệ, điều gì sẽ xảy ra nếu ngoại lệ đó được ném ra?",
    options: [
      "Chương trình chạy bình thường.",
      "Ngoại lệ được ném trở lại cho JVM, dẫn đến JVM đóng chương trình.",
      "Trình biên dịch yêu cầu thêm khối `catch`.",
      "Nó trở thành một Checked Exception.",
    ],
    answer: 1,
    explanation:
      "Nếu phương thức `main()` duck ngoại lệ, và ngoại lệ đó được ném ra, nó sẽ được ném trở lại cho JVM, và JVM sẽ đóng chương trình [51, 52].",
  },
  {
    id: 2172,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Theo luật 'Handle or Declare' (Xử lý hoặc Khai báo), lựa chọn nào sau đây là bắt buộc khi gọi một phương thức ném ra Checked Exception?",
    options: [
      "Phải sử dụng `try/catch`.",
      "Phải khai báo `throws`.",
      "Phải chọn một trong hai: bọc trong `try/catch` hoặc khai báo bằng `throws`.",
      "Không làm gì cả nếu đó là `IOException`.",
    ],
    answer: 2,
    explanation:
      "Khi gọi một phương thức ném ra checked exception, bạn phải tuân theo luật Handle or Declare (Xử lý hoặc Khai báo) [47, 52].",
  },
  {
    id: 2173,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Mục đích của việc kiểm tra ngoại lệ ở thời điểm biên dịch (Checked Exceptions) là gì?",
    options: [
      "Để giảm thiểu các lỗi logic.",
      "Để buộc lập trình viên phải biết về các rủi ro có thể xảy ra ở runtime và chuẩn bị code xử lý (handle/declare) cho chúng.",
      "Để tăng hiệu suất của chương trình.",
      "Để loại bỏ hoàn toàn các lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch kiểm tra các Checked Exceptions để đảm bảo rằng bạn biết về các rủi ro [39, 53].",
  },
  {
    id: 2174,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng chuyển đổi một chuỗi không phải số thành một số nguyên bằng `Integer.parseInt()`?",
    options: [
      "Chương trình chạy bình thường.",
      "Gây ra `NumberFormatException` (Unchecked).",
      "Gây ra `StringIndexOutOfBoundsException` (Unchecked).",
      "Gây ra lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Nếu bạn cố gắng parse một chuỗi không phải số, code sẽ ném ra `NumberFormatException` ở runtime [36, 54].",
  },
  {
    id: 2175,
    topic: "Exception Handling",
    type: "radio",
    question: "Ngoại lệ nào sau đây KHÔNG phải là Unchecked Exception?",
    options: [
      "ClassCastException",
      "ArrayIndexOutofBoundException",
      "NumberFormatException",
      "FileNotFoundException",
    ],
    answer: 3,
    explanation:
      "FileNotFoundException là một ví dụ của Checked Exception [2]. ClassCastException, ArrayIndexOutofBoundException, và NumberFormatException là các Runtime Exceptions (Unchecked) [17, 39].",
  },
  {
    id: 2176,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Tại sao `NullPointerException` (Unchecked) không cần được xử lý/khai báo?",
    options: [
      "Vì nó là lỗi logic mà lập trình viên nên kiểm soát (ví dụ: kiểm tra `null`).",
      "Vì nó là một lỗi hệ thống.",
      "Vì nó là một lỗi cú pháp.",
      "Vì nó được JVM tự động khôi phục.",
    ],
    answer: 0,
    explanation:
      "Hầu hết Runtime Exceptions (ví dụ: NullPointerException) đến từ vấn đề logic trong code mà bạn có thể ngăn chặn (ví dụ: kiểm tra mảng.length). Bạn KHÔNG muốn đặt try/catch cho những lỗi này [39, 44].",
  },
  {
    id: 2177,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức gọi một phương thức khác ném Checked Exception và không muốn xử lý nó, phương thức gọi có thể làm gì?",
    options: [
      "Bỏ qua nó hoàn toàn.",
      "Chỉ cần gọi nó trong khối `try`.",
      "Duck nó bằng cách thêm `throws` vào khai báo của chính nó.",
      "Chuyển đổi nó thành Runtime Exception.",
    ],
    answer: 2,
    explanation:
      "Nếu bạn không muốn xử lý ngoại lệ, bạn có thể duck nó bằng cách khai báo nó trong phương thức gọi của bạn (`throws`) [45, 46].",
  },
  {
    id: 2178,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Ngoại lệ nào là một ví dụ điển hình của việc hệ thống runtime cần báo hiệu sự cố nội bộ (thường không thể khôi phục)?",
    options: [
      "IndexOutOfBoundsException",
      "Error",
      "Checked Exception",
      "User-defined Exception",
    ],
    answer: 1,
    explanation:
      "Error được JVM sử dụng để chỉ ra các lỗi liên quan đến môi trường runtime (JRE) [5, 18].",
  },
  {
    id: 2179,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Phân loại nào sau đây là không chính xác trong Java Exception Handling?",
    options: [
      "Checked Exception: IOException",
      "Unchecked Exception: ArrayIndexOutofBoundException",
      "Checked Exception: NullPointerException",
      "Unchecked Exception: ArithmeticException",
    ],
    answer: 2,
    explanation:
      "NullPointerException là một Unchecked Exception (Runtime Exception), không phải Checked Exception [17, 18, 38].",
  },
  {
    id: 2180,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi một phương thức được khai báo là `throws ExceptionA`, điều này có nghĩa là code gọi phương thức đó phải chuẩn bị cho ngoại lệ thuộc kiểu nào?",
    options: [
      "Chỉ ExceptionA.",
      "ExceptionA và tất cả các lớp cha của nó.",
      "ExceptionA và tất cả các lớp con của nó (nếu có mối quan hệ đa hình).",
      "Chỉ các Unchecked Exceptions.",
    ],
    answer: 2,
    explanation:
      "Khai báo một ngoại lệ bằng kiểu siêu lớp (supertype) cho phép phương thức ném ra bất kỳ lớp con nào của ngoại lệ đó [55].",
  },
  {
    id: 2181,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong ngữ cảnh `try/catch`, tại sao việc bắt ngoại lệ bằng một kiểu cụ thể hơn (derived class) tốt hơn là chỉ dùng kiểu tổng quát `Exception`?",
    options: [
      "Vì kiểu tổng quát không thể bắt các Unchecked Exceptions.",
      "Vì nó cho phép code khôi phục cụ thể hơn tùy thuộc vào loại lỗi xảy ra.",
      "Vì nó bắt buộc phải có `finally`.",
      "Vì nó giúp biên dịch nhanh hơn.",
    ],
    answer: 1,
    explanation:
      "Nếu code cần xử lý các loại ngoại lệ khác nhau theo các cách khác nhau (ví dụ: khôi phục khác nhau cho `TeeShirtException` và `LingerieException`), cần viết các khối `catch` riêng biệt [56, 57].",
  },
  {
    id: 2182,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì là một ví dụ rõ ràng cho thấy một phương thức ném ra Unchecked Exception ở runtime?",
    options: [
      "Sử dụng `FileReader` mà không có `try/catch`.",
      "Thực hiện phép chia cho 0 (`int z = x/y;` với `y=0`).",
      "Gọi một phương thức được khai báo là `throws IOException`.",
      "Sử dụng một đối tượng được tuần tự hóa (serialized).",
    ],
    answer: 1,
    explanation:
      "Code chia cho 0 biên dịch ổn, nhưng ném ra `ArithmeticException` (Unchecked) khi chạy [34].",
  },
  {
    id: 2183,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Theo luật Handle or Declare, nếu phương thức A gọi phương thức B (ném Checked Exception), và A không sử dụng `try/catch`, thì A phải làm gì?",
    options: [
      "Khai báo rằng A ném cùng ngoại lệ đó (ducking).",
      "Tự động gọi default exception handler.",
      "Sử dụng `throw` để ném ngoại lệ khác.",
      "Không cần làm gì cả.",
    ],
    answer: 0,
    explanation:
      "Nếu phương thức A gọi phương thức B (ném Checked Exception) và A không xử lý (try/catch), A phải khai báo ngoại lệ đó bằng `throws` [42, 47].",
  },
  {
    id: 2184,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong ví dụ đọc/ghi tệp, nếu ta chỉ cần chỉ định `IOException` trong mệnh đề `throws` của `main()`, chương trình sẽ biên dịch. Điều này thể hiện nguyên tắc nào của Exception?",
    options: [
      "Chỉ cần bắt/khai báo lớp con.",
      "Chỉ cần bắt/khai báo lớp cha (supertype) của các ngoại lệ con là đủ.",
      "IOException là một Unchecked Exception.",
      "Không cần xử lý ngoại lệ nếu nó xảy ra trong `main()`.",
    ],
    answer: 1,
    explanation:
      "Vì `FileNotFoundException` là lớp con của `IOException`, việc chỉ định lớp cha là đủ [33]. Đây là một ví dụ về Đa hình (polymorphism) trong Exception [32].",
  },
  {
    id: 2185,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong hệ thống phân cấp, tất cả các ngoại lệ mà trình biên dịch quan tâm (Checked Exceptions) đều KHÔNG phải là lớp con của lớp nào?",
    options: ["Exception", "Throwable", "RuntimeException", "Object"],
    answer: 2,
    explanation:
      "Checked Exceptions KHÔNG phải là lớp con của `RuntimeException` [39].",
  },
  {
    id: 2186,
    topic: "Exception Handling",
    type: "radio",
    question: "Ngoại lệ `NumberFormatException` xảy ra khi nào?",
    options: [
      "Khi chia cho 0.",
      "Khi cố gắng chuyển đổi chuỗi thành định dạng số không hợp lệ.",
      "Khi truy cập chỉ số ngoài giới hạn của mảng.",
      "Khi tham chiếu một đối tượng null.",
    ],
    answer: 1,
    explanation:
      "NumberFormatException xảy ra khi không thể chuyển đổi một chuỗi thành định dạng số [17]. Ví dụ: `Integer.parseInt('abc')` [58].",
  },
  {
    id: 2187,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Phương thức `Integer.parseInt()` có thể ném ra loại ngoại lệ nào?",
    options: [
      "IOException",
      "NullPointerException",
      "NumberFormatException",
      "InterruptedException",
    ],
    answer: 2,
    explanation:
      "Phương thức `Integer.parseInt()` có thể ném ra `NumberFormatException` [36, 59].",
  },
  {
    id: 2188,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Tại sao một phương thức như `getSequencer()` trong JavaSound API cần phải khai báo `throws MidiUnavailableException`?",
    options: [
      "Vì nó là một lỗi logic.",
      "Vì `MidiUnavailableException` là một Checked Exception, và phương thức này thực hiện một hoạt động rủi ro không thể đảm bảo thành công ở runtime.",
      "Vì nó là một Unchecked Exception.",
      "Vì nó là một phương thức `static`.",
    ],
    answer: 1,
    explanation:
      "`MidiUnavailableException` là Checked Exception [60]. Phương thức rủi ro phải 'khai báo' rủi ro bằng `throws` [53].",
  },
  {
    id: 2189,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một ngoại lệ là lớp con của `RuntimeException`, nó được gọi là gì?",
    options: [
      "Compiler-checked exception.",
      "Compiler-ignored exception.",
      "Checked exception.",
      "Error.",
    ],
    answer: 1,
    explanation:
      "Các ngoại lệ là lớp con của `RuntimeException` được gọi là 'unchecked exceptions' và trình biên dịch bỏ qua chúng [39, 40].",
  },
  {
    id: 2190,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Việc sử dụng `try/catch` để bắt một Unchecked Exception là hợp lệ (legal) hay không?",
    options: [
      "Hợp lệ, nhưng không bắt buộc bởi trình biên dịch.",
      "Không hợp lệ.",
      "Bắt buộc nếu đó là `NullPointerException`.",
      "Chỉ hợp lệ trong `main()`.",
    ],
    answer: 0,
    explanation:
      "Bạn có thể tự do `throw`, `catch`, và `declare` RuntimeExceptions, nhưng trình biên dịch không kiểm tra chúng (không bắt buộc) [40, 61].",
  },
  {
    id: 2191,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức được khai báo là `public void doRisky() throws IOException`, thì code gọi nó phải làm gì để biên dịch?",
    options: [
      "Bọc trong `try/catch` hoặc khai báo `throws IOException`.",
      "Bỏ qua nó vì nó là `IOException`.",
      "Sử dụng `throw new IOException()`.",
      "Chỉ cần sử dụng `finally`.",
    ],
    answer: 0,
    explanation:
      "Phải tuân theo luật Handle or Declare [47, 52]. Cần `try/catch` hoặc `throws` [49].",
  },
  {
    id: 2192,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Tại sao việc sử dụng `try/catch` để bắt một Runtime Exception có thể là một thực hành tồi?",
    options: [
      "Vì nó gây ra lỗi biên dịch.",
      "Vì nó thêm chi phí không cần thiết để bắt một lỗi lẽ ra nên được ngăn chặn bằng logic code.",
      "Vì `catch` không thể bắt Runtime Exception.",
      "Vì nó sẽ tự động gọi Garbage Collector.",
    ],
    answer: 1,
    explanation:
      "Bạn không muốn code `try/catch`, và có chi phí đi kèm, để bắt một thứ không nên xảy ra ngay từ đầu (lỗi logic) [44].",
  },
  {
    id: 2193,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Ngoại lệ `NumberFormatException` thuộc nhóm nào trong hai nhóm chính?",
    options: [
      "Checked Exception",
      "Unchecked Exception",
      "Error",
      "Syntax Error",
    ],
    answer: 1,
    explanation:
      "NumberFormatException là một ví dụ của Runtime Exception (Unchecked) [17, 43, 59].",
  },
  {
    id: 2194,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là SAI về các Checked Exception?",
    options: [
      "Chúng là các ngoại lệ mà trình biên dịch phải kiểm tra.",
      "Chúng là các ngoại lệ mà lớp cha của chúng không phải là `RuntimeException`.",
      "Nếu ném ra, chúng phải được khai báo hoặc xử lý.",
      "Chúng thường là kết quả của các lỗi logic (bugs).",
    ],
    answer: 3,
    explanation:
      "Checked Exceptions thường là các tình huống không thể dự đoán hoặc kiểm soát (ví dụ: tệp không tồn tại, server down) [44]. Unchecked Exceptions mới thường là lỗi logic.",
  },
  {
    id: 2195,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi một phương thức khai báo `throws MyCheckedException`, code gọi nó có thể làm gì để tuân thủ luật Handle or Declare?",
    options: [
      "Wrap lời gọi trong `try/catch`.",
      "Thêm `throws MyCheckedException` vào khai báo phương thức của chính nó.",
      "Cả hai phương án trên đều hợp lệ.",
      "Không cần làm gì cả.",
    ],
    answer: 2,
    explanation:
      "Có hai cách để thỏa mãn luật Handle or Declare: sử dụng `try/catch` (Handle) hoặc khai báo `throws` (Declare/Duck) [39, 47].",
  },
  {
    id: 2196,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một chương trình sử dụng `FileReader` để đọc tệp, ngoại lệ nào (Checked) thường xảy ra nếu tệp không được tìm thấy?",
    options: [
      "IndexOutOfBoundsException",
      "ArithmeticException",
      "FileNotFoundException",
      "NullPointerException",
    ],
    answer: 2,
    explanation:
      "`FileReader` có thể ném ra `FileNotFoundException` [41], là một Checked Exception [2, 33].",
  },
  {
    id: 2197,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn cố gắng gọi một phương thức được khai báo `throws IOException` mà không xử lý hoặc khai báo trong `main()`?",
    options: [
      "Lỗi biên dịch 'unreported exception'.",
      "JVM xử lý ngoại lệ.",
      "Mã chạy và bỏ qua ngoại lệ.",
      "Chỉ cần thêm `finally`.",
    ],
    answer: 0,
    explanation:
      "Nếu `main()` không xử lý ngoại lệ được khai báo, nó sẽ không biên dịch và gây ra lỗi 'unreported exception' [42].",
  },
  {
    id: 2198,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi nào thì một ngoại lệ có thể được ném lại (rethrow) sau khi đã được bắt (caught)?",
    options: [
      "Chỉ khi nó là Unchecked Exception.",
      "Khi phương thức bắt không thể khôi phục hoàn toàn nhưng muốn thông báo cho phương thức gọi biết về lỗi đó.",
      "Chỉ khi nó là Error.",
      "Chỉ trong khối `finally`.",
    ],
    answer: 1,
    explanation: "Phương thức bắt có thể ném lại (rethrow) ngoại lệ [4].",
  },
  {
    id: 2199,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khái niệm 'Polymorphic exceptions' (Ngoại lệ đa hình) có nghĩa là gì?",
    options: [
      "Ngoại lệ phải là lớp con của `Object`.",
      "Sử dụng kiểu siêu lớp trong khai báo `throws` hoặc khối `catch` để bao quát các lớp con tương ứng.",
      "Chỉ có thể ném ra một loại ngoại lệ.",
      "Chỉ áp dụng cho Runtime Exceptions.",
    ],
    answer: 1,
    explanation:
      "Ngoại lệ có thể được tham chiếu đa hình, cho phép sử dụng kiểu siêu lớp trong khai báo `throws` hoặc khối `catch` [32, 55].",
  },
  {
    id: 2200,
    topic: "Exception Handling",
    type: "radio",
    question: "Đâu là một ví dụ của Unchecked Exception?",
    options: [
      "ClassNotFoundException",
      "NoSuchFieldException",
      "StringIndexOutOfBoundException",
      "IOException",
    ],
    answer: 2,
    explanation:
      "StringIndexOutOfBoundException là một Runtime Exception (Unchecked) [17].",
  },
  {
    id: 2201,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi xử lý ngoại lệ, 'khung bắt' (catch basket) càng lớn khi kiểu ngoại lệ càng nằm ở đâu trong cây kế thừa?",
    options: [
      "Càng sâu xuống dưới.",
      "Càng cao lên trên (gần `Throwable` hơn).",
      "Kích thước khung bắt không liên quan đến hệ thống phân cấp.",
      "Phụ thuộc vào số lượng tham số.",
    ],
    answer: 1,
    explanation:
      "Càng cao lên trong cây kế thừa, khung bắt (catch basket) càng lớn (càng tổng quát hơn, ví dụ: `Exception` là lớn nhất) [25].",
  },
  {
    id: 2202,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khái niệm 'Unreported Exception' (Ngoại lệ không được báo cáo) xuất hiện khi nào?",
    options: [
      "Khi code không biên dịch.",
      "Khi một Checked Exception bị ném ra mà không được khai báo hoặc xử lý trong code gọi.",
      "Khi một Runtime Exception bị ném ra.",
      "Khi `finally` không chạy.",
    ],
    answer: 1,
    explanation:
      "Lỗi biên dịch 'unreported exception' xảy ra khi một Checked Exception không được xử lý hoặc khai báo [42].",
  },
  {
    id: 2203,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì là đúng về việc khai báo đa ngoại lệ trong mệnh đề `throws`?",
    options: [
      "Chỉ có thể khai báo một ngoại lệ duy nhất.",
      "Nếu nhiều ngoại lệ có một lớp cha chung, chỉ cần khai báo lớp cha đó.",
      "Tất cả các ngoại lệ phải là Unchecked Exceptions.",
      "Không được phép sử dụng `throws` và `try/catch` cùng nhau.",
    ],
    answer: 1,
    explanation:
      "Một phương thức có thể ném ra nhiều ngoại lệ, và nếu chúng có lớp cha chung, phương thức có thể chỉ cần khai báo lớp cha đó [55, 62].",
  },
  {
    id: 2204,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức chỉ ném ra Unchecked Exception, điều gì là đúng về khai báo `throws` cho phương thức đó?",
    options: [
      "Bắt buộc phải khai báo `throws`.",
      "Việc khai báo `throws` là tùy chọn, nhưng hợp lệ.",
      "Không được phép khai báo `throws`.",
      "Phải sử dụng `try/catch` thay thế.",
    ],
    answer: 1,
    explanation:
      "Trình biên dịch không kiểm tra RuntimeExceptions, vì vậy việc khai báo `throws` cho chúng là tùy chọn [40, 61].",
  },
  {
    id: 2205,
    topic: "Exception Handling",
    type: "radio",
    question: "Ngoại lệ nào KHÔNG phải là Unchecked Exception?",
    options: [
      "ArrayIndexOutofBoundException",
      "InterruptedException",
      "ClassCastException",
      "ArithmeticException",
    ],
    answer: 1,
    explanation:
      "InterruptedException là một ví dụ của Checked Exception [14, 39].",
  },
  {
    id: 2206,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong trường hợp nào, việc khai báo `throws` cho một phương thức là **bắt buộc**?",
    options: [
      "Khi phương thức đó ném ra một `ArithmeticException`.",
      "Khi phương thức đó ném ra một `NullPointerException`.",
      "Khi phương thức đó ném ra một Checked Exception (ví dụ: `IOException`) và không được xử lý bằng `try/catch`.",
      "Khi phương thức đó là `static`.",
    ],
    answer: 2,
    explanation:
      "Nếu bạn ném ra Checked Exception trong code, bạn phải khai báo nó bằng từ khóa `throws` trong khai báo phương thức [39, 49].",
  },
  {
    id: 2207,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn chỉ sử dụng `try` theo sau là `finally` (không có `catch`), và code trong `try` ném ra một Checked Exception?",
    options: [
      "Lỗi biên dịch, vì thiếu `catch`.",
      "Hợp lệ, nếu phương thức được khai báo `throws` ngoại lệ đó.",
      "Khối `finally` bị bỏ qua.",
      "Chỉ hợp lệ với Unchecked Exception.",
    ],
    answer: 1,
    explanation:
      "Một `try` chỉ với `finally` (không `catch`) vẫn phải khai báo ngoại lệ trong phương thức để biên dịch, vì nó không xử lý ngoại lệ [22].",
  },
  {
    id: 2208,
    topic: "Exception Handling",
    type: "radio",
    question: "Mục đích chính của Runtime Exceptions (Unchecked) là gì?",
    options: [
      "Chỉ ra rằng tệp không tồn tại.",
      "Giúp lập trình viên tìm ra các lỗi logic (bugs) trong quá trình phát triển và kiểm thử.",
      "Buộc phải đóng kết nối mạng.",
      "Đảm bảo mã chạy nhanh hơn.",
    ],
    answer: 1,
    explanation:
      "Bạn MUỐN RuntimeExceptions xảy ra trong thời gian phát triển và kiểm thử để tìm lỗi logic [44].",
  },
  {
    id: 2209,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là SAI về `NumberFormatException`?",
    options: [
      "Nó là Unchecked Exception.",
      "Nó xảy ra nếu bạn cố gắng chuyển đổi chuỗi 'two' thành số nguyên.",
      "Nó xảy ra ở thời điểm biên dịch.",
      "Nó có thể được ném ra bởi `Integer.parseInt()`.",
    ],
    answer: 2,
    explanation:
      "NumberFormatException là Runtime Exception, xảy ra ở thời điểm chạy [36, 59].",
  },
  {
    id: 2210,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối lệnh nào phải được thực thi sau khi khối `try` hoàn tất, bất kể có ngoại lệ xảy ra hay không?",
    options: [
      "catch block",
      "finally block",
      "throw statement",
      "method main()",
    ],
    answer: 1,
    explanation:
      "Bất kỳ code nào phải được thực thi sau khi khối `try` hoàn thành đều được đặt trong khối `finally`. Khối `finally` luôn được thực thi [6, 13, 41, 63].",
  },
  {
    id: 2211,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu khối `try` thực thi thành công (không có ngoại lệ), luồng điều khiển sẽ chuyển đến đâu sau khi `try` kết thúc?",
    options: [
      "Đến khối `catch` liên quan.",
      "Đến khối `finally`.",
      "Đến đầu phương thức.",
      "Đến code ngay sau khối `finally`.",
    ],
    answer: 1,
    explanation:
      "Nếu khối `try` thành công, luồng điều khiển bỏ qua khối `catch` và chuyển đến khối `finally` [28].",
  },
  {
    id: 2212,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một ngoại lệ được ném ra trong khối `try` và được bắt bởi khối `catch`, luồng điều khiển sau khi `catch` hoàn thành sẽ chuyển đến đâu?",
    options: [
      "Đến khối `finally`.",
      "Trở lại khối `try`.",
      "Đến phần code sau khối `try-catch-finally`.",
      "Chương trình kết thúc.",
    ],
    answer: 0,
    explanation:
      "Nếu `catch` hoàn thành, khối `finally` sẽ chạy. Sau khi `finally` hoàn thành, phần còn lại của phương thức tiếp tục [28].",
  },
  {
    id: 2213,
    topic: "Exception Handling",
    type: "radio",
    question: "Khối `finally` thường được sử dụng cho mục đích nào?",
    options: [
      "Xử lý logic nghiệp vụ chính.",
      "Khởi tạo các đối tượng.",
      "Đặt các mã quan trọng như đóng file hoặc đóng kết nối (cleanup code).",
      "Chỉ để in thông báo lỗi.",
    ],
    answer: 2,
    explanation:
      "Khối `finally` thường được sử dụng để đặt các mã quan trọng như đóng file hoặc đóng kết nối [13, 64].",
  },
  {
    id: 2214,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì xảy ra nếu khối `try` có câu lệnh `return`?",
    options: [
      "Khối `finally` bị bỏ qua.",
      "Khối `finally` vẫn chạy, sau đó luồng lệnh quay trở lại `return`.",
      "Lỗi biên dịch.",
      "Chương trình dừng ngay lập tức.",
    ],
    answer: 1,
    explanation:
      "Nếu khối `try` hoặc `catch` có câu lệnh `return`, `finally` vẫn sẽ chạy. Luồng lệnh nhảy đến `finally`, sau đó quay trở lại `return` [28].",
  },
  {
    id: 2215,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu khối `try` thất bại do ngoại lệ, phần còn lại của khối `try` sẽ chạy không?",
    options: [
      "Có, nếu ngoại lệ được bắt.",
      "Không, luồng điều khiển ngay lập tức chuyển sang khối `catch` phù hợp.",
      "Chỉ nếu ngoại lệ là Unchecked.",
      "Chỉ nếu ngoại lệ là Checked.",
    ],
    answer: 1,
    explanation:
      "Nếu khối `try` thất bại (một ngoại lệ), luồng điều khiển ngay lập tức chuyển sang khối `catch` (phần còn lại của `try` không chạy) [20].",
  },
  {
    id: 2216,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là SAI về khối `finally`?",
    options: [
      "Nó luôn chạy.",
      "Nó là tùy chọn.",
      "Nó chạy ngay cả khi có `return` trong `try`.",
      "Nó có thể tồn tại mà không cần khối `try` đi kèm.",
    ],
    answer: 3,
    explanation:
      "Khối `finally` không thể tồn tại mà không có khối `try` đi kèm [21, 50].",
  },
  {
    id: 2217,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu `try` ném ra ngoại lệ và không có `catch` nào khớp, khối `finally` sẽ chạy không?",
    options: [
      "Không bao giờ.",
      "Có, nó luôn chạy trước khi JVM chấm dứt chương trình bất thường.",
      "Chỉ khi ngoại lệ là `Error`.",
      "Chỉ khi ngoại lệ là `NullPointerException`.",
    ],
    answer: 1,
    explanation:
      "Khối `finally` luôn chạy, ngay cả khi ngoại lệ không được bắt và chương trình bị chấm dứt [28].",
  },
  {
    id: 2218,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi sử dụng khối `finally`, nếu bạn có code dọn dẹp (ví dụ: `turnOvenOff()`), bạn nên đặt nó ở đâu?",
    options: [
      "Lặp lại trong cả `try` và `catch`.",
      "Chỉ trong `try`.",
      "Chỉ trong `catch`.",
      "Chỉ trong `finally` để tránh lặp lại code và đảm bảo nó chạy trong mọi trường hợp.",
    ],
    answer: 3,
    explanation:
      "Khối `finally` cho phép bạn đặt tất cả code dọn dẹp quan trọng vào một nơi thay vì lặp lại nó trong cả `try` và `catch` [65].",
  },
  {
    id: 2219,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Giả sử `try` thành công và có `finally`. Trình tự thực hiện là gì?",
    options: [
      "try -> finally -> code sau finally.",
      "try -> catch -> finally.",
      "finally -> try -> code sau finally.",
      "Chỉ try và code sau finally.",
    ],
    answer: 0,
    explanation:
      "Nếu `try` thành công, luồng lệnh chuyển đến `finally`, sau đó code sau `finally` tiếp tục [28, 29].",
  },
  {
    id: 2220,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Giả sử `try` thất bại và được `catch`, và có `finally`. Trình tự thực hiện là gì?",
    options: [
      "try (một phần) -> catch -> finally -> code sau finally.",
      "try -> finally -> catch.",
      "Chỉ catch và finally.",
      "try (một phần) -> finally -> catch.",
    ],
    answer: 0,
    explanation:
      "Nếu `try` thất bại, flow chuyển ngay lập tức đến `catch`, sau đó `finally` chạy. Cuối cùng, code sau `finally` tiếp tục [20, 28].",
  },
  {
    id: 2221,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu `try` ném ngoại lệ và không có `catch` nào được cung cấp (chỉ có `finally`), code dọn dẹp trong `finally` sẽ chạy khi nào?",
    options: [
      "Ngay sau khi ngoại lệ xảy ra trong `try`, trước khi JVM đóng chương trình.",
      "Không bao giờ.",
      "Sau khi chương trình kết thúc bất thường.",
      "Chỉ khi ngoại lệ là Runtime Exception.",
    ],
    answer: 0,
    explanation:
      "Nếu `try` thất bại (có ngoại lệ), luồng lệnh chuyển ngay đến `finally` [28].",
  },
  {
    id: 2222,
    topic: "Exception Handling",
    type: "radio",
    question: "Lựa chọn nào sau đây mô tả chính xác mục đích của `finally`?",
    options: [
      "Để khởi tạo các biến local.",
      "Để chứa code phải chạy để đảm bảo trạng thái hệ thống nhất quán (ví dụ: đóng tài nguyên) dù lỗi có xảy ra hay không.",
      "Để bắt tất cả các Runtime Exceptions.",
      "Để thay thế khối `catch`.",
    ],
    answer: 1,
    explanation:
      "Khối `finally` là nơi bạn đặt code phải chạy bất kể có ngoại lệ hay không, thường là code dọn dẹp quan trọng [13, 64].",
  },
  {
    id: 2223,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì xảy ra nếu khối `finally` cũng ném ra một ngoại lệ?",
    options: [
      "Nó ném ra ngoại lệ ban đầu.",
      "Nó ghi đè lên ngoại lệ ban đầu (nếu có) và ngoại lệ mới được ném lên stack.",
      "Ngoại lệ bị nuốt chửng.",
      "JVM tự động bắt nó.",
    ],
    answer: 1,
    explanation:
      "Mặc dù không được đề cập trực tiếp, nguyên tắc cơ bản là nếu `finally` ném ra ngoại lệ, ngoại lệ đó sẽ được ưu tiên và ném ra, thay thế ngoại lệ trước đó.",
  },
  {
    id: 2224,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một khối `try` không có `catch`, nhưng có `finally`, và code trong `try` ném ra Unchecked Exception. Điều gì là đúng?",
    options: [
      "Code không biên dịch.",
      "Khối `finally` chạy, sau đó JVM đóng chương trình.",
      "Khối `finally` không chạy.",
      "Ngoại lệ bị bỏ qua.",
    ],
    answer: 1,
    explanation:
      "Unchecked Exception không cần khai báo để biên dịch [40]. Khối `finally` luôn chạy [28].",
  },
  {
    id: 2225,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi khối `try` chứa `System.exit(0)`, điều gì xảy ra với khối `finally`?",
    options: [
      "Khối `finally` luôn chạy.",
      "Khối `finally` bị bỏ qua.",
      "Phụ thuộc vào loại ngoại lệ.",
      "Chỉ chạy nếu `catch` được thực thi.",
    ],
    answer: 1,
    explanation:
      "Trong hầu hết các trường hợp, `System.exit()` sẽ ngăn `finally` chạy (thông tin bên ngoài nguồn, nhưng cần thiết để giải thích giới hạn của 'always runs'). Tuy nhiên, dựa trên nguồn, `finally` chạy trừ khi JVM bị shutdown đột ngột [28] (Giả định rằng `System.exit(0)` là shutdown đột ngột trong ngữ cảnh này).",
  },
  {
    id: 2226,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một khối `catch` ném lại ngoại lệ (rethrow), khối nào vẫn được đảm bảo thực thi?",
    options: [
      "Khối `try`.",
      "Khối `finally`.",
      "Phương thức gọi.",
      "Default exception handler.",
    ],
    answer: 1,
    explanation:
      "Dù `try` hay `catch` có `return` hay ném ngoại lệ, `finally` vẫn chạy [28].",
  },
  {
    id: 2227,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều kiện nào sau đây phải xảy ra để khối `finally` được thực thi?",
    options: [
      "Phải có ít nhất một `catch`.",
      "Phải có một ngoại lệ được ném ra.",
      "Chỉ cần khối `try` được nhập (executed).",
      "Phải có `throws` trong khai báo phương thức.",
    ],
    answer: 2,
    explanation:
      "Khối `finally` được định nghĩa là code chạy sau khi khối `try` hoàn thành (nghĩa là `try` đã được chạy, dù thành công hay thất bại) [6].",
  },
  {
    id: 2228,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối nào sau đây có thể chứa code dọn dẹp cho tài nguyên được mở trong khối `try`?",
    options: [
      "Khối `catch`.",
      "Khối `finally`.",
      "Khối `try`.",
      "Cả ba khối đều có thể chứa code dọn dẹp, nhưng `finally` là nơi tốt nhất.",
    ],
    answer: 3,
    explanation:
      "Code dọn dẹp (ví dụ: đóng file) có thể đặt trong `finally` để đảm bảo nó chạy [13, 64]. Nếu không có `finally`, bạn phải lặp lại nó trong `try` và `catch` [65].",
  },
  {
    id: 2229,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một ngoại lệ xảy ra ở dòng 10 trong `try` và `finally` bắt đầu ở dòng 20, dòng code nào giữa 10 và 20 sẽ được thực thi?",
    options: [
      "Tất cả các dòng code.",
      "Không có dòng code nào.",
      "Chỉ những dòng code được `catch`.",
      "Chỉ dòng code cuối cùng trước `finally`.",
    ],
    answer: 1,
    explanation:
      "Nếu khối `try` thất bại do ngoại lệ, phần còn lại của khối `try` không chạy (luồng điều khiển chuyển ngay lập tức) [20].",
  },
  {
    id: 2230,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là hợp lệ về cú pháp của khối `try-catch`?",
    options: [
      "Nhiều khối `try` có thể được xếp chồng.",
      "Nhiều khối `catch` được phép, theo sau là tối đa một `finally`.",
      "Một khối `catch` có thể được đặt trước `try`.",
      "Một khối `finally` là bắt buộc.",
    ],
    answer: 1,
    explanation:
      "Nhiều khối `catch` được phép [7]. `finally` là tùy chọn [13]. `catch` phải theo sau `try` [21].",
  },
  {
    id: 2231,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức có một khối `try/finally` (không `catch`) và `try` ném ra Checked Exception, điều gì xảy ra nếu phương thức không khai báo `throws`?",
    options: [
      "Chương trình chạy bình thường.",
      "Lỗi biên dịch.",
      "Khối `finally` vẫn chạy và ngoại lệ bị nuốt chửng.",
      "Khối `try` bị bỏ qua.",
    ],
    answer: 1,
    explanation:
      "Một `try` không có `catch` không thỏa mãn luật Handle or Declare, trừ khi phương thức được khai báo `throws` ngoại lệ [22]. Nếu không có `throws`, nó sẽ lỗi biên dịch.",
  },
  {
    id: 2232,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong trường hợp nào, `finally` vẫn chạy nhưng không có code nào sau đó được thực thi?",
    options: [
      "Khi có lỗi cú pháp.",
      "Khi JVM đóng chương trình (ví dụ: `main()` duck ngoại lệ).",
      "Khi không có `catch` nào khớp.",
      "Khi `try` thành công.",
    ],
    answer: 1,
    explanation:
      "Nếu ngoại lệ được ném ra và lan truyền đến JVM (ví dụ: `main()` duck nó), JVM đóng chương trình. Khối `finally` chạy trước khi JVM đóng [51, 52].",
  },
  {
    id: 2233,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Để đảm bảo rằng code dọn dẹp được thực thi ngay cả khi code trong `try` ném ngoại lệ và có câu lệnh `return`, bạn nên đặt code đó ở đâu?",
    options: [
      "Khối `try`.",
      "Khối `catch`.",
      "Khối `finally`.",
      "Trước khối `try`.",
    ],
    answer: 2,
    explanation:
      "Khối `finally` chạy ngay cả khi có `return` trong `try` [28].",
  },
  {
    id: 2234,
    topic: "Exception Handling",
    type: "radio",
    question: "Có thể đặt code giữa khối `try` và khối `catch` không?",
    options: [
      "Có, nếu đó là khai báo biến.",
      "Có, nếu đó là lệnh gọi phương thức.",
      "Không, code giữa `try` và `catch` là KHÔNG hợp lệ về mặt cú pháp.",
      "Chỉ khi sử dụng `throws`.",
    ],
    answer: 2,
    explanation: "Bạn không thể đặt code giữa `try` và `catch` [21].",
  },
  {
    id: 2235,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khối `finally` có thể tự định nghĩa một khối `try-catch` bên trong nó không?",
    options: [
      "Có, để xử lý lỗi dọn dẹp.",
      "Không bao giờ.",
      "Chỉ khi không có `catch` bên ngoài.",
      "Chỉ khi code trong `try` thất bại.",
    ],
    answer: 0,
    explanation:
      "Ngoại lệ có thể xảy ra trong khối `finally` (ví dụ: khi đóng một tài nguyên) và cần được xử lý.",
  },
  {
    id: 2236,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu khối `try` có lệnh `throw` và `finally` cũng có lệnh `throw`, ngoại lệ nào sẽ được ném ra ngoài phương thức?",
    options: [
      "Ngoại lệ từ `try`.",
      "Ngoại lệ từ `finally`.",
      "Cả hai ngoại lệ.",
      "Không có ngoại lệ nào.",
    ],
    answer: 1,
    explanation:
      "Khối `finally` được đảm bảo chạy sau `try` và `catch`. Nếu `finally` ném ngoại lệ, nó sẽ được ném ra khỏi phương thức.",
  },
  {
    id: 2237,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là hợp lệ về cú pháp của `try-catch-finally`?",
    options: [
      "`catch` phải là block cuối cùng.",
      "Một `try` phải có ít nhất một `catch` hoặc `finally`.",
      "`finally` phải được đặt trước tất cả các khối `catch`.",
      "Chỉ một `catch` được phép.",
    ],
    answer: 1,
    explanation:
      "Một khối `try` PHẢI được theo sau bởi `catch` hoặc `finally` [21, 66].",
  },
  {
    id: 2238,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu khối `try` gọi `System.exit(0)`, điều gì có khả năng xảy ra với khối `finally`?",
    options: [
      "Nó sẽ chạy.",
      "Nó sẽ bị bỏ qua vì JVM kết thúc đột ngột.",
      "Nó được chuyển cho default handler.",
      "Nó chạy nếu ngoại lệ được ném ra.",
    ],
    answer: 1,
    explanation:
      "Khối `finally` không chạy nếu JVM bị buộc dừng (ví dụ: `System.exit()`).",
  },
  {
    id: 2239,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu khối `try` có `return`, sau khi `finally` thực thi, luồng điều khiển sẽ đi đến đâu?",
    options: [
      "Ngay sau khối `finally`.",
      "Quay lại điểm `return` trong `try` để trả về giá trị.",
      "Đến `catch`.",
      "Đến `main()`.",
    ],
    answer: 1,
    explanation:
      "Nếu `try` hoặc `catch` có `return`, luồng nhảy đến `finally`, sau đó quay lại `return` [28].",
  },
  {
    id: 2240,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong trường hợp `try` thành công, code trong `catch` sẽ được thực thi không?",
    options: [
      "Có, nếu đó là `RuntimeException`.",
      "Không, khối `catch` bị bỏ qua.",
      "Có, nếu có `finally`.",
      "Chỉ nếu `try` có `return`.",
    ],
    answer: 1,
    explanation:
      "Nếu `try` thành công (không có ngoại lệ), luồng điều khiển bỏ qua khối `catch` [20, 28].",
  },
  {
    id: 2241,
    topic: "Exception Handling",
    type: "radio",
    question: "Mệnh đề `finally` là **bắt buộc** trong trường hợp nào?",
    options: [
      "Khi có `try` và `catch`.",
      "Khi muốn đảm bảo tài nguyên được đóng.",
      "Nó không bao giờ là bắt buộc, chỉ là tùy chọn.",
      "Khi `try` không có `catch`.",
    ],
    answer: 1,
    explanation:
      "Khối `finally` là tùy chọn [13, 67, 68]. Tuy nhiên, trong thực tế, nó được sử dụng rộng rãi để đảm bảo dọn dẹp.",
  },
  {
    id: 2242,
    topic: "Exception Handling",
    type: "radio",
    question: "Khi nào thì khối `catch` không được thực thi?",
    options: [
      "Khi khối `try` hoàn thành thành công (không ngoại lệ).",
      "Khi `try` ném ra ngoại lệ không được bắt bởi bất kỳ khối `catch` nào.",
      "A và B đều đúng.",
      "Không bao giờ, `catch` luôn chạy.",
    ],
    answer: 2,
    explanation:
      "`catch` không chạy nếu `try` thành công [20]. Nếu `try` thất bại và không có `catch` nào khớp, `catch` cũng không chạy [11].",
  },
  {
    id: 2243,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một khối `try` có `return` và sau đó ném ra một ngoại lệ được `catch`, điều gì xảy ra?",
    options: [
      "Câu lệnh `return` được ưu tiên.",
      "Ngoại lệ được ưu tiên; `return` bị bỏ qua, `finally` chạy.",
      "Lỗi biên dịch.",
      "Chương trình chạy bình thường.",
    ],
    answer: 1,
    explanation:
      "Nếu ngoại lệ xảy ra, luồng lệnh chuyển sang `catch`, bỏ qua phần còn lại của `try` (bao gồm `return` nếu nó đứng sau điểm lỗi) [20]. `finally` vẫn chạy [28].",
  },
  {
    id: 2244,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì là đúng nếu khối `try` ném một ngoại lệ được bắt và xử lý bởi `catch`?",
    options: [
      "Khối `finally` chạy trước `catch`.",
      "Code sau `finally` không chạy.",
      "Khối `catch` chạy, sau đó là `finally`, và sau đó code sau đó chạy.",
      "Code sẽ dừng ở `catch`.",
    ],
    answer: 2,
    explanation: "try (một phần) -> catch -> finally -> code sau finally [28].",
  },
  {
    id: 2245,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Trong ngữ cảnh `try-catch`, `catch` không có `finally`. Nếu `try` thành công, luồng điều khiển đi đến đâu?",
    options: [
      "Đến `catch`.",
      "Đến code ngay sau `catch`.",
      "Kết thúc phương thức.",
      "Lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Nếu không có `finally` và `try` thành công, luồng điều khiển bỏ qua `catch` và chuyển đến code sau `catch` [20, 28].",
  },
  {
    id: 2246,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu `try` có `return` và `finally` cũng có `return`, giá trị nào được trả về?",
    options: [
      "Giá trị trả về của `try`.",
      "Giá trị trả về của `finally`.",
      "Giá trị trả về của `catch`.",
      "Lỗi runtime.",
    ],
    answer: 1,
    explanation:
      "Vì `finally` được thực thi sau `try`, câu lệnh `return` trong `finally` sẽ ghi đè và là giá trị cuối cùng được trả về.",
  },
  {
    id: 2247,
    topic: "Exception Handling",
    type: "radio",
    question: "Khối nào phải được đặt ngay sau khối `try`?",
    options: [
      "Khối `catch` hoặc khối `finally` (hoặc cả hai, với `catch` trước `finally`).",
      "Chỉ có thể là `catch`.",
      "Chỉ có thể là `finally`.",
      "Code xử lý logic nghiệp vụ.",
    ],
    answer: 0,
    explanation:
      "Một `try` PHẢI được theo sau bởi `catch` hoặc `finally` [21].",
  },
  {
    id: 2248,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là KHÔNG đúng về `finally`?",
    options: [
      "Nó có thể thay thế `catch` hoàn toàn.",
      "Nó có thể được sử dụng để đóng các luồng I/O.",
      "Nó không chạy nếu `try` gọi `System.exit(0)`.",
      "Nó chỉ chạy nếu ngoại lệ được ném ra.",
    ],
    answer: 3,
    explanation:
      "`finally` chạy BẤT KỂ ngoại lệ có được ném ra hay không [6, 64].",
  },
  {
    id: 2249,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu `try` ném ngoại lệ và không có `catch`. Sau khi `finally` chạy, điều gì xảy ra?",
    options: [
      "Ngoại lệ được ném lên cho phương thức gọi.",
      "Ngoại lệ bị nuốt chửng.",
      "Code dừng.",
      "Lỗi biên dịch.",
    ],
    answer: 0,
    explanation:
      "Nếu không có `catch`, `finally` vẫn chạy, sau đó ngoại lệ vẫn được ném lên stack cho đến khi được bắt hoặc đến JVM [51].",
  },
  {
    id: 2250,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Từ khóa nào được sử dụng để ném một đối tượng ngoại lệ được tạo thủ công?",
    options: ["throw", "throws", "catch", "finally"],
    answer: 0,
    explanation:
      "Để ném một ngoại lệ thủ công, sử dụng từ khóa `throw` [6, 49].",
  },
  {
    id: 2251,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Từ khóa nào được sử dụng để khai báo (specify) một hoặc nhiều ngoại lệ mà một phương thức có thể ném ra?",
    options: ["throw", "throws", "catch", "new"],
    answer: 1,
    explanation:
      "Từ khóa `throws` được sử dụng để chỉ định các ngoại lệ mà một phương thức có thể ném ra [6, 18].",
  },
  {
    id: 2252,
    topic: "Exception Handling",
    type: "radio",
    question: "Khi sử dụng từ khóa `throw`, nó phải được theo sau bởi điều gì?",
    options: [
      "Một kiểu dữ liệu.",
      "Một từ khóa.",
      "Một tham chiếu đến một đối tượng Exception mới.",
      "Tên của phương thức.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `throw` phải được theo sau bởi một đối tượng ngoại lệ mới (throw new Exception()) [49, 69].",
  },
  {
    id: 2253,
    topic: "Exception Handling",
    type: "radio",
    question: "Từ khóa `throws` thường được sử dụng cho loại ngoại lệ nào?",
    options: [
      "Error.",
      "Unchecked Exceptions (Runtime Exceptions).",
      "Checked Exceptions (Compiler-checked exceptions).",
      "Tất cả các loại ngoại lệ đều được sử dụng như nhau.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `throws` được sử dụng để chỉ định các Checked Exceptions [39, 41].",
  },
  {
    id: 2254,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi cả lớp cơ sở (Base) và lớp dẫn xuất (Derived) đều được bắt làm ngoại lệ, thứ tự nào là đúng trong các khối `catch`?",
    options: [
      "Lớp Base trước lớp Derived.",
      "Lớp Derived trước lớp Base.",
      "Thứ tự không quan trọng.",
      "Chỉ được phép bắt lớp Derived.",
    ],
    answer: 1,
    explanation:
      "Catch block của lớp dẫn xuất phải xuất hiện trước lớp cơ sở. Ngược lại sẽ gây ra lỗi biên dịch vì ngoại lệ lớp con đã được bắt bởi lớp cha [70-72].",
  },
  {
    id: 2255,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi sử dụng đa hình trong `catch`, tại sao `catch(Exception ex)` phải là khối cuối cùng?",
    options: [
      "Vì nó là lớp trừu tượng.",
      "Vì nó sẽ bắt tất cả các ngoại lệ, làm cho các khối `catch` cụ thể hơn sau nó không thể đạt được (unreachable).",
      "Vì nó là Unchecked Exception.",
      "Thứ tự không quan trọng.",
    ],
    answer: 1,
    explanation:
      "`catch(Exception ex)` là khối lớn nhất, nếu đặt trước các khối nhỏ hơn, trình biên dịch sẽ báo lỗi 'exception... has already been caught' [70-72].",
  },
  {
    id: 2256,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Để tạo User-defined exception, class mới phải là lớp con của lớp nào?",
    options: ["Error", "Throwable", "Exception", "RuntimeException"],
    answer: 2,
    explanation:
      "Tất cả các ngoại lệ đều là lớp con của class `Exception` [58, 73, 74].",
  },
  {
    id: 2257,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì là bắt buộc khi ném một ngoại lệ do người dùng tự định nghĩa (User-defined exception)?",
    options: [
      "Sử dụng từ khóa `throws` trong constructor.",
      "Tạo một đối tượng của lớp ngoại lệ đó và ném nó bằng từ khóa `throw`.",
      "Nó phải là Unchecked Exception.",
      "Chỉ cần khai báo tên lớp.",
    ],
    answer: 1,
    explanation:
      "Để ném ngoại lệ do người dùng định nghĩa, chúng ta cần tạo một đối tượng cho lớp ngoại lệ của nó và ném nó bằng mệnh đề `throw` [69].",
  },
  {
    id: 2258,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu `BaseException` kế thừa `Exception`, và `DerivedException` kế thừa `BaseException`. Khối `catch` nào sau đây là không hợp lệ?",
    options: [
      "`catch(DerivedException d) {} catch(BaseException b) {}`",
      "`catch(BaseException b) {} catch(DerivedException d) {}`",
      "`catch(Exception e) {}`",
      "`catch(DerivedException d) {}`",
    ],
    answer: 1,
    explanation:
      "Lớp cha (`BaseException`) phải được đặt sau lớp con (`DerivedException`) [70, 72].",
  },
  {
    id: 2259,
    topic: "Exception Handling",
    type: "radio",
    question: "Điều gì là mục đích của từ khóa `throw`?",
    options: [
      "Định nghĩa ra một ngoại lệ mới.",
      "Khai báo rằng phương thức có thể ném ngoại lệ.",
      "Thực hiện hành động ném ngoại lệ tại một điểm cụ thể trong code.",
      "Ngăn chặn ngoại lệ xảy ra.",
    ],
    answer: 2,
    explanation: "`throw` được sử dụng để ném một ngoại lệ thủ công [6].",
  },
  {
    id: 2260,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức sử dụng `throws IOException`, điều này được gọi là hành động gì (liên quan đến luật Handle or Declare)?",
    options: [
      "Handling (Xử lý).",
      "Declaring/Ducking (Khai báo/Né tránh).",
      "Catching (Bắt).",
      "Throwing (Ném).",
    ],
    answer: 1,
    explanation:
      "Khai báo ngoại lệ bằng `throws` là hành động 'Declare' hoặc 'Duck' ngoại lệ [45, 47, 50].",
  },
  {
    id: 2261,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu bạn muốn chuyển đổi một Unchecked Exception thành Checked Exception, bạn có thể làm gì?",
    options: [
      "Không thể làm được.",
      "Bọc code trong `try/catch`.",
      "Định nghĩa một phương thức ném ra một ngoại lệ Checked mới nếu điều kiện Unchecked Exception xảy ra.",
      "Chỉ cần gọi `System.gc()`.",
    ],
    answer: 2,
    explanation:
      "Ví dụ về chuyển Unchecked sang Checked là kiểm tra điều kiện (y==0) và `throw new Exception` (là Checked) [34].",
  },
  {
    id: 2262,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Khi bắt đa ngoại lệ bằng đa hình, thứ tự của các khối `catch` phải là gì?",
    options: [
      "Từ tổng quát nhất đến cụ thể nhất.",
      "Thứ tự không quan trọng đối với các lớp con.",
      "Từ cụ thể nhất đến tổng quát nhất.",
      "Chỉ cần bắt các lớp Base trước.",
    ],
    answer: 2,
    explanation:
      "Các khối catch đa hình phải được sắp xếp từ cụ thể nhất (nhỏ nhất) đến tổng quát nhất (lớn nhất) [50, 71, 72].",
  },
  {
    id: 2263,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Điều gì xảy ra nếu bạn không sử dụng từ khóa `new` khi ném một ngoại lệ thủ công?",
    options: [
      "Ngoại lệ được ném ra bình thường.",
      "Lỗi biên dịch, vì `throw` yêu cầu một đối tượng Exception mới.",
      "Chỉ áp dụng cho User-defined exception.",
      "Nó trở thành Unchecked Exception.",
    ],
    answer: 1,
    explanation:
      "`throw` phải được theo sau bởi một đối tượng ngoại lệ (thường là `new Exception()`) [49, 69]. Thiếu `new` nếu đó là một lớp exception sẽ gây lỗi biên dịch.",
  },
  {
    id: 2264,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu bạn muốn tạo một User-defined Exception là Checked, bạn nên kế thừa từ lớp nào?",
    options: [
      "java.lang.Error",
      "java.lang.RuntimeException",
      "java.lang.Exception",
      "java.lang.Object",
    ],
    answer: 2,
    explanation:
      "Để tạo Checked Exception, class mới phải kế thừa `Exception` [73]. Kế thừa `RuntimeException` sẽ tạo ra Unchecked Exception [39].",
  },
  {
    id: 2265,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu `catch(BaseA a)` được đặt trước `catch(DerivedB b)` (trong đó B kế thừa A), điều gì xảy ra nếu ngoại lệ B được ném ra?",
    options: [
      "Ngoại lệ B được bắt bởi khối `catch(DerivedB b)`.",
      "Ngoại lệ B được bắt bởi khối `catch(BaseA a)`.",
      "Gây ra lỗi biên dịch vì thứ tự không đúng.",
      "Ngoại lệ B được ném lên cho JVM.",
    ],
    answer: 1,
    explanation:
      "Vì `catch(BaseA a)` có thể bắt ngoại lệ lớp con (đa hình), khối `catch(DerivedB b)` trở nên không thể đạt được (unreachable), gây ra lỗi biên dịch [70, 72].",
  },
  {
    id: 2266,
    topic: "Exception Handling",
    type: "radio",
    question: "Mệnh đề `throws` được đặt ở đâu trong code?",
    options: [
      "Bên trong khối `try`.",
      "Sau tên phương thức, trước dấu `{`.",
      "Sau khối `finally`.",
      "Trong khối `catch`.",
    ],
    answer: 1,
    explanation:
      "Từ khóa `throws` được đặt trong khai báo phương thức (method declaration) [18].",
  },
  {
    id: 2267,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Từ khóa nào được sử dụng để ném một ngoại lệ cho phép bạn kiểm soát thông báo chi tiết (detail) về lỗi?",
    options: ["throws", "finally", "throw", "return"],
    answer: 2,
    explanation:
      "Khi tạo User-defined exception, constructor thường nhận một chuỗi `detail` và truyền nó cho `super(detail)` [58]. Sau đó dùng `throw` để ném đối tượng này.",
  },
  {
    id: 2268,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu một phương thức gọi được khai báo `throws IOException`, điều gì là đúng về việc xử lý ngoại lệ này?",
    options: [
      "Phương thức gọi phải là `main()`.",
      "Phương thức gọi có thể dùng `try/catch` hoặc `throws` tiếp.",
      "Phương thức gọi phải dùng `finally`.",
      "Không cần xử lý vì đó là `IOException`.",
    ],
    answer: 1,
    explanation:
      "Khi phương thức gọi duck ngoại lệ, người gọi phương thức đó phải tuân theo luật Handle or Declare (try/catch hoặc throws) [42, 47].",
  },
  {
    id: 2269,
    topic: "Exception Handling",
    type: "radio",
    question: "Mục đích của việc sử dụng các khối `catch` đa hình là gì?",
    options: [
      "Để giảm số lượng các khối `try`.",
      "Để xử lý nhiều loại ngoại lệ bằng ít code hơn, tùy chỉnh xử lý cho những ngoại lệ cụ thể cần thiết.",
      "Để chỉ bắt Runtime Exceptions.",
      "Để đảm bảo `finally` chạy.",
    ],
    answer: 1,
    explanation:
      "Bạn có thể sử dụng các khối `catch` đa hình để bắt các ngoại lệ con bằng lớp cha [24, 55], cho phép tùy chỉnh xử lý cho những ngoại lệ cần thiết [57].",
  },
  {
    id: 2270,
    topic: "Exception Handling",
    type: "radio",
    question:
      "Nếu phương thức A ném `ExceptionA` (Checked) và B gọi A mà không `try/catch`. Nếu B cũng khai báo `throws ExceptionA`, điều gì xảy ra?",
    options: [
      "Bây giờ, bất kỳ phương thức nào gọi B phải Handle or Declare `ExceptionA`.",
      "Ngoại lệ biến mất.",
      "Chỉ phương thức `main()` mới có thể gọi B.",
      "Đây là lỗi biên dịch.",
    ],
    answer: 0,
    explanation:
      "Nếu B duck ngoại lệ bằng `throws`, thì bất kỳ ai gọi B phải tuân thủ luật Handle or Declare [46, 47].",
  },
  {
    id: 2271,
    topic: "Exception Handling",
    type: "code",
    question:
      "Hãy xem xét đoạn mã sau. Nếu không có ngoại lệ nào xảy ra trong khối `try`, đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("1");\n    } catch (Exception e) {\n      System.out.print("2");\n    } finally {\n      System.out.print("3");\n    }\n    System.out.print("4");\n  }\n}',
    options: ["1234", "134", "14", "234"],
    answer: 1,
    explanation:
      "Nếu khối `try` thành công, nó thực thi xong (in '1'), bỏ qua `catch` (không in '2'), `finally` chạy (in '3'), và phần còn lại của phương thức tiếp tục (in '4') [28, 29].",
  },
  {
    id: 2272,
    topic: "Exception Handling",
    type: "code",
    question:
      "Giả sử `doRisky()` ném ra một `RuntimeException`. Đầu ra của đoạn mã sau là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("A");\n      doRisky(); // throws RuntimeException\n      System.out.print("B");\n    } catch (Exception e) {\n      System.out.print("C");\n    } finally {\n      System.out.print("D");\n    }\n    System.out.print("E");\n  }\n  static void doRisky() { throw new RuntimeException(); }\n}',
    options: ["ABDE", "ACDE", "ADE", "Lỗi runtime không thể bắt."],
    answer: 1,
    explanation:
      "Khối `try` chạy (in 'A'), `doRisky()` ném ngoại lệ (bỏ qua 'B'), `catch` bắt (in 'C'), `finally` chạy (in 'D'), code sau `finally` chạy (in 'E'). Đầu ra: ACDE [20, 24].",
  },
  {
    id: 2273,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `doRisky()` ném `RuntimeException` nhưng `catch` không có tham số (hoặc chỉ bắt `CheckedException`). Đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("X");\n      doRisky(); // throws RuntimeException\n      System.out.print("Y");\n    } catch (java.io.IOException e) {\n      System.out.print("Z");\n    } finally {\n      System.out.print("W");\n    }\n    System.out.print("K");\n  }\n  static void doRisky() { throw new RuntimeException(); }\n}',
    options: [
      "XWK và kết thúc bất thường.",
      "XYWK",
      "XW và kết thúc bất thường.",
      "XZWK",
    ],
    answer: 2,
    explanation:
      "Khối `try` chạy (in 'X'). `RuntimeException` được ném, không có `catch` khớp (bỏ qua 'Z'). `finally` chạy (in 'W'). Ngoại lệ lan truyền và được JVM xử lý mặc định (kết thúc bất thường, bỏ qua 'K') [11, 28].",
  },
  {
    id: 2274,
    topic: "Exception Handling",
    type: "code",
    question: "Điều gì được in ra khi phương thức `go()` được gọi?",
    code: 'public class TestFlow {\n  static String go() {\n    try {\n      System.out.print("T");\n      return "R1";\n    } finally {\n      System.out.print("F");\n      return "R2";\n    }\n  }\n  public static void main(String[] args) {\n    System.out.print(go());\n  }\n}',
    options: ["TR1", "TR2", "TF R1", "TF R2"],
    answer: 3,
    explanation:
      "`try` chạy (in 'T'), gặp `return` ('R1'). `finally` chạy trước (in 'F'), và `return` trong `finally` ('R2') ghi đè `return` của `try`. Đầu ra: TF R2 [28].",
  },
  {
    id: 2275,
    topic: "Exception Handling",
    type: "code",
    question: "Giả sử `RiskyException` là Checked Exception. Đầu ra là gì?",
    code: 'class RiskyException extends Exception {}\nclass TestFlow {\n  static void doRisky() throws RiskyException { throw new RiskyException(); }\n  public static void main(String[] args) {\n    try {\n      System.out.print("1");\n      doRisky();\n      System.out.print("2");\n    } catch (RiskyException e) {\n      System.out.print("3");\n    } finally {\n      System.out.print("4");\n    }\n    System.out.print("5");\n  }\n}',
    options: ["12345", "1345", "125", "145"],
    answer: 1,
    explanation:
      "try chạy (in '1'), `doRisky()` ném ngoại lệ (bỏ qua '2'). `catch` bắt (in '3'). `finally` chạy (in '4'). Code sau đó chạy (in '5'). Đầu ra: 1345 [20, 28].",
  },
  {
    id: 2276,
    topic: "Exception Handling",
    type: "code",
    question:
      "Điều gì xảy ra khi code sau được biên dịch và chạy (giả sử `doRisky` là `void` và ném `CheckedException`)?",
    code: 'public class TestFlow {\n  static void go() {\n    try {\n      System.out.print("A");\n      doRisky(); // throws CheckedException\n      System.out.print("B");\n    } finally {\n      System.out.print("C");\n    }\n    System.out.print("D");\n  }\n  static void doRisky() throws Exception { throw new Exception(); }\n  public static void main(String[] args) throws Exception {\n    go();\n  }\n}',
    options: [
      "ABCD",
      "AC và chương trình kết thúc bất thường.",
      "Lỗi biên dịch.",
      "ACD",
    ],
    answer: 2,
    explanation:
      "`go()` gọi `doRisky()` (ném Checked Exception) mà không có `catch` tương ứng. Vì `go()` cũng không khai báo `throws`, nó sẽ gây lỗi biên dịch 'unreported exception' [22, 42].",
  },
  {
    id: 2277,
    topic: "Exception Handling",
    type: "code",
    question:
      "Giả sử `Base` kế thừa `Exception`, `Derived` kế thừa `Base`. Đoạn code sau có biên dịch không?",
    code: 'public class CatchOrderTest {\n  public static void main(String[] args) {\n    try {\n      throw new Derived();\n    } catch (Base b) {\n      System.out.println("Caught Base");\n    } catch (Derived d) {\n      System.out.println("Caught Derived");\n    }\n  }\n}',
    options: [
      "Có, và in ra 'Caught Base'.",
      "Có, và in ra 'Caught Derived'.",
      "Lỗi biên dịch: 'exception Derived has already been caught'.",
      "Lỗi runtime.",
    ],
    answer: 2,
    explanation:
      "Khối catch của lớp Base phải đứng SAU lớp Derived. Đặt lớp Base trước sẽ khiến trình biên dịch báo lỗi vì Derived đã được Base bắt (đa hình) [70-72].",
  },
  {
    id: 2278,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `process()` ném `IOException`. Đầu ra của đoạn mã sau là gì?",
    code: 'import java.io.IOException;\nclass Test {\n  static void process() throws IOException { throw new IOException(); }\n  public static void main(String[] args) {\n    try {\n      process();\n      System.out.print("T");\n    } catch (IOException e) {\n      System.out.print("C");\n    } finally {\n      System.out.print("F");\n    }\n    System.out.print("E");\n  }\n}',
    options: ["TCFE", "CFE", "C T F E", "Lỗi biên dịch."],
    answer: 1,
    explanation:
      "`process()` ném ngoại lệ (bỏ qua 'T'). `catch` bắt (in 'C'). `finally` chạy (in 'F'). Code sau đó chạy (in 'E'). Đầu ra: CFE [20, 28].",
  },
  {
    id: 2279,
    topic: "Exception Handling",
    type: "code",
    question:
      "Điều gì xảy ra nếu khối `try` có `return`, nhưng `catch` ném lại một ngoại lệ?",
    code: 'class TestFlow {\n  static void go() {\n    try {\n      System.out.print("1");\n      if (true) throw new RuntimeException();\n      return;\n    } catch (RuntimeException e) {\n      System.out.print("2");\n      throw e;\n    } finally {\n      System.out.print("3");\n    }\n  }\n  public static void main(String[] args) {\n    try { go(); } catch (RuntimeException e) { System.out.print("4"); }\n  }\n}',
    options: ["1234", "123 và kết thúc bất thường.", "134", "Lỗi runtime."],
    answer: 0,
    explanation:
      "`go()`: `try` in '1', ném ngoại lệ. `catch` in '2', ném lại ngoại lệ. `finally` in '3'. Ngoại lệ được ném lên `main()`. `main()` bắt (in '4'). Đầu ra: 1234 [28].",
  },
  {
    id: 2280,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `try` thành công. Đầu ra của đoạn code sau là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    int result = 0;\n    try {\n      result = 10;\n      System.out.print("T");\n    } finally {\n      result = 20;\n      System.out.print("F");\n    }\n    System.out.print(result);\n  }\n}',
    options: ["T20", "T10F", "TF20", "T F 10"],
    answer: 2,
    explanation:
      "try chạy (result=10, in 'T'). finally chạy (result=20, in 'F'). Code sau đó in giá trị cuối cùng của result là 20. Đầu ra: TF20 [28].",
  },
  {
    id: 2281,
    topic: "Exception Handling",
    type: "code",
    question: "Điều gì là kết quả của đoạn code sau?",
    code: "public class TestFlow {\n  static int calculate(int x) {\n    try {\n      return x / (x - 1);\n    } catch (ArithmeticException e) {\n      return 0;\n    } finally {\n      return 5;\n    }\n  }\n  public static void main(String[] args) {\n    System.out.print(calculate(1));\n  }\n}",
    options: ["0", "5", "1", "Lỗi runtime."],
    answer: 1,
    explanation:
      "Khi x=1, `try` ném `ArithmeticException` (chia cho 0). `catch` chạy (return 0). Nhưng `finally` chạy sau, và `return 5` của `finally` ghi đè giá trị trả về. Đầu ra: 5 [28].",
  },
  {
    id: 2282,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `BadException` là Checked Exception. Đầu ra là gì?",
    code: 'class BadException extends Exception {}\nclass TestFlow {\n  static void check(boolean fail) throws BadException {\n    try {\n      if (fail) throw new BadException();\n      System.out.print("T");\n    } catch (BadException e) {\n      System.out.print("C");\n    } finally {\n      System.out.print("F");\n    }\n  }\n  public static void main(String[] args) throws BadException {\n    check(true);\n    System.out.print("E");\n  }\n}',
    options: ["TCFE", "CFE", "TCE", "CF E"],
    answer: 3,
    explanation:
      "`check(true)`: `try` ném ngoại lệ (bỏ qua 'T'). `catch` bắt (in 'C'). `finally` chạy (in 'F'). Code sau đó chạy (in 'E'). Đầu ra: CFE [20, 28].",
  },
  {
    id: 2283,
    topic: "Exception Handling",
    type: "code",
    question:
      "Giả sử `ParentException` và `ChildException` (`Child` extends `Parent`). Thứ tự catch nào sau đây là **hợp lệ**?",
    code: "  // Snippet 1\n  try { throw new ChildException(); } \n  catch (ParentException p) {} \n  catch (ChildException c) {} \n  // Snippet 2\n  try { throw new ChildException(); } \n  catch (ChildException c) {} \n  catch (ParentException p) {}",
    options: [
      "Cả Snippet 1 và 2 đều hợp lệ.",
      "Snippet 1 lỗi biên dịch, Snippet 2 hợp lệ.",
      "Snippet 1 hợp lệ, Snippet 2 lỗi biên dịch.",
      "Cả hai đều lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Snippet 1 lỗi biên dịch vì `ParentException` bắt `ChildException` trước, khiến `catch(ChildException)` không thể đạt được [70]. Snippet 2 hợp lệ vì lớp cụ thể hơn đứng trước [48, 71].",
  },
  {
    id: 2284,
    topic: "Exception Handling",
    type: "code",
    question: "Điều gì xảy ra khi `process()` ném `ArithmeticException`?",
    code: 'public class TestFlow {\n  static void process() {\n    System.out.print("P");\n    int x = 1 / 0;\n  }\n  public static void main(String[] args) {\n    try {\n      process();\n    } catch (NullPointerException e) {\n      System.out.print("N");\n    } finally {\n      System.out.print("F");\n    }\n  }\n}',
    options: [
      "PF và kết thúc bất thường.",
      "PNF.",
      "Lỗi biên dịch.",
      "F P và kết thúc bất thường.",
    ],
    answer: 0,
    explanation:
      "`process()` in 'P', ném `ArithmeticException`. `catch(NullPointerException)` không khớp. `finally` chạy (in 'F'). Ngoại lệ lan truyền và kết thúc bất thường. Đầu ra: PF [28].",
  },
  {
    id: 2285,
    topic: "Exception Handling",
    type: "code",
    question: "Đầu ra của đoạn code sau là gì?",
    code: 'public class TestFlow {\n  static int getValue(int x) {\n    try {\n      if (x == 0) throw new Exception();\n      return 10;\n    } catch (Exception e) {\n      return 20;\n    } finally {\n      System.out.print("F");\n    }\n  }\n  public static void main(String[] args) {\n    System.out.print(getValue(0));\n  }\n}',
    options: ["F 10", "F 20", "10", "20"],
    answer: 1,
    explanation:
      "Khi x=0, `try` ném `Exception`. `catch` bắt (return 20). `finally` chạy (in 'F'). Giá trị trả về là 20. Đầu ra: F20 [28].",
  },
  {
    id: 2286,
    topic: "Exception Handling",
    type: "code",
    question:
      "Điều gì xảy ra nếu `main()` được thay đổi thành `public static void main(String[] args) throws Exception`?",
    code: 'public class TestFlow {\n  static void process() { int x = 1 / 0; }\n  public static void main(String[] args) {\n    try {\n      process();\n    } catch (ArithmeticException e) {\n      // nothing\n    } finally {\n      System.out.print("F");\n    }\n    System.out.print("E");\n  }\n}',
    options: [
      "Không ảnh hưởng, vì `ArithmeticException` là Unchecked.",
      "Bắt buộc phải thêm `throws`.",
      "Lỗi biên dịch.",
      "Chỉ chạy `process()`.",
    ],
    answer: 0,
    explanation:
      "`ArithmeticException` là Unchecked, không cần khai báo `throws` để biên dịch [40]. Thay đổi `main()` không ảnh hưởng đến code này.",
  },
  {
    id: 2287,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `try` thất bại. Đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("1");\n      throw new RuntimeException();\n    } catch (Exception e) {\n      System.out.print("2");\n    }\n    System.out.print("3");\n  }\n}',
    options: ["123", "12", "13", "23"],
    answer: 0,
    explanation:
      "`try` in '1', ném ngoại lệ (bỏ qua phần còn lại của `try`). `catch` bắt (in '2'). Code sau đó chạy (in '3'). Đầu ra: 123 [20].",
  },
  {
    id: 2288,
    topic: "Exception Handling",
    type: "code",
    question: "Đầu ra của đoạn code sau là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("A");\n    } finally {\n      System.out.print("B");\n    }\n    System.out.print("C");\n  }\n}',
    options: ["A B C", "B C A", "A B", "A C"],
    answer: 0,
    explanation:
      "`try` thành công (in 'A'). `finally` chạy (in 'B'). Code sau đó chạy (in 'C'). Đầu ra: ABC [28, 29].",
  },
  {
    id: 2289,
    topic: "Exception Handling",
    type: "code",
    question:
      "Giả sử `Checked` là Checked Exception. Đoạn code nào sau đây gây lỗi biên dịch?",
    code: 'class Checked extends Exception {}\nclass TestFlow {\n  public static void main(String[] args) {\n    try {\n      throw new Checked();\n    } finally {\n      System.out.print("F");\n    }\n    System.out.print("E");\n  }\n}',
    options: [
      "Có, vì `try` không có `catch` và `main()` không `throws`.",
      "Không, vì `finally` có thể thay thế `catch`.",
      "Có, vì thiếu `return`.",
      "Không có lỗi biên dịch.",
    ],
    answer: 0,
    explanation:
      "Code ném Checked Exception. `try/finally` không xử lý ngoại lệ; do đó `main()` phải khai báo `throws` (Declare) hoặc thêm `catch` (Handle). Thiếu cả hai gây lỗi biên dịch [22].",
  },
  {
    id: 2290,
    topic: "Exception Handling",
    type: "code",
    question: "Điều gì xảy ra khi `go()` ném `RuntimeException`?",
    code: 'public class TestFlow {\n  static String go() {\n    try {\n      System.out.print("T");\n      throw new RuntimeException();\n    } catch (Exception e) {\n      System.out.print("C");\n      return "R1";\n    } finally {\n      System.out.print("F");\n      return "R2";\n    }\n  }\n  public static void main(String[] args) {\n    System.out.print(go());\n  }\n}',
    options: ["T C F R1", "T C F R2", "TCF", "T C F R1 R2"],
    answer: 1,
    explanation:
      "`try` in 'T', ném ngoại lệ. `catch` bắt (in 'C', return 'R1'). `finally` chạy (in 'F'), return 'R2' ghi đè. Đầu ra: T C F R2 [28].",
  },
  {
    id: 2291,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `MyEx` là User-defined Exception. Đầu ra khi chạy với đối số `yes` là gì?",
    code: 'class MyEx extends Exception { }\npublic class ExTestDrive {\n  public static void main(String [] args) {\n    String test = args;\n    try {\n      System.out.print("t");\n      doRisky(test);\n      System.out.print("o");\n    } catch ( MyEx e) {\n      System.out.print("a");\n    } finally {\n      System.out.print("w");\n    }\n    System.out.println("s");\n  }\n  static void doRisky(String t) throws MyEx {\n    System.out.print("h");\n    if ("yes".equals(t)) {\n      throw new MyEx();\n    }\n    System.out.print("r");\n  }\n}',
    options: ["thaws", "thras", "thaws", "Lỗi biên dịch."],
    answer: 0,
    explanation:
      "Input 'yes': `main` in 't'. `doRisky` in 'h', ném `MyEx` (bỏ qua 'r'). `main` catch `MyEx` (in 'a') [75]. `finally` in 'w'. Cuối cùng in 's'. Đầu ra: thaws [68].",
  },
  {
    id: 2292,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `MyEx` là User-defined Exception. Đầu ra khi chạy với đối số `no` là gì?",
    code: 'class MyEx extends Exception { }\npublic class ExTestDrive {\n  public static void main(String [] args) {\n    String test = args;\n    try {\n      System.out.print("t");\n      doRisky(test);\n      System.out.print("o");\n    } catch ( MyEx e) {\n      System.out.print("a");\n    } finally {\n      System.out.print("w");\n    }\n    System.out.println("s");\n  }\n  static void doRisky(String t) throws MyEx {\n    System.out.print("h");\n    if ("yes".equals(t)) {\n      throw new MyEx();\n    }\n    System.out.print("r");\n  }\n}',
    options: ["thraws", "thaws", "thwr", "throws"],
    answer: 3,
    explanation:
      "Input 'no': `main` in 't'. `doRisky` in 'h', in 'r' (không ném ngoại lệ). `main` in 'o'. `finally` in 'w'. Cuối cùng in 's'. Đầu ra: throws [68].",
  },
  {
    id: 2293,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `try` thành công. Giá trị của `result` sau khi kết thúc `main()` là gì?",
    code: "public class TestFlow {\n  static int calculate() {\n    int result = 0;\n    try {\n      result = 10;\n      return result;\n    } finally {\n      result = 5;\n    }\n  }\n  public static void main(String[] args) {\n    System.out.print(calculate());\n  }\n}",
    options: ["10", "5", "0", "Lỗi biên dịch."],
    answer: 0,
    explanation:
      "`try` đặt `result` là 10 và cố gắng return. `finally` chạy, đặt `result` là 5. Nhưng giá trị 10 đã được lưu để trả về. Giá trị trả về là 10. (Lưu ý: biến `result` cục bộ trong `calculate()` có giá trị là 5 khi phương thức kết thúc, nhưng giá trị được trả về là 10) [28].",
  },
  {
    id: 2294,
    topic: "Exception Handling",
    type: "code",
    question:
      "Giả sử `Derived` là lớp con của `Base`. Thứ tự nào sau đây là **đúng** và hợp lệ?",
    code: "  // Snippet 1\n  catch (Derived d) {} catch (Base b) {}\n  // Snippet 2\n  catch (Base b) {} catch (Derived d) {}",
    options: [
      "Snippet 1 đúng, Snippet 2 lỗi biên dịch.",
      "Snippet 2 đúng, Snippet 1 lỗi biên dịch.",
      "Cả hai đều đúng.",
      "Cả hai đều lỗi biên dịch.",
    ],
    answer: 0,
    explanation:
      "Lớp con (Derived) phải đứng trước lớp cha (Base) [48, 71, 72].",
  },
  {
    id: 2295,
    topic: "Exception Handling",
    type: "code",
    question:
      "Điều gì xảy ra nếu `Risky.go()` ném `CheckedException` và `main()` không có `try/catch`?",
    code: "class CheckedException extends Exception {}\nclass Risky {\n  static void go() throws CheckedException { throw new CheckedException(); }\n}\npublic class TestFlow {\n  public static void main(String[] args) {\n    Risky.go(); \n  }\n}",
    options: [
      "Biên dịch không lỗi.",
      "Lỗi biên dịch: Unreported exception.",
      "Chạy và ném `RuntimeException`.",
      "Chạy và kết thúc bình thường.",
    ],
    answer: 1,
    explanation:
      "Phương thức `go()` ném Checked Exception. `main()` phải Handle or Declare. Thiếu cả hai dẫn đến lỗi biên dịch [42].",
  },
  {
    id: 2296,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `throw new NullPointerException()` được gọi trong `try`, đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("1");\n      throw new NullPointerException();\n    } catch (NullPointerException e) {\n      System.out.print("2");\n    } finally {\n      System.out.print("3");\n    }\n    System.out.print("4");\n  }\n}',
    options: ["1234", "134", "124", "Lỗi runtime."],
    answer: 0,
    explanation:
      "`try` in '1', ném ngoại lệ. `catch(NullPointerException)` bắt (in '2'). `finally` in '3'. Code sau đó in '4'. Đầu ra: 1234.",
  },
  {
    id: 2297,
    topic: "Exception Handling",
    type: "code",
    question: "Đoạn code sau có biên dịch không?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("A");\n    } \n    System.out.print("B");\n    catch (Exception e) {\n      System.out.print("C");\n    }\n  }\n}',
    options: [
      "Có, in ra ABC.",
      "Lỗi biên dịch, không được đặt code giữa `try` và `catch`.",
      "Lỗi biên dịch, thiếu `finally`.",
      "Có, in ra A B.",
    ],
    answer: 1,
    explanation:
      "Không được phép đặt code giữa khối `try` và khối `catch` [21].",
  },
  {
    id: 2298,
    topic: "Exception Handling",
    type: "code",
    question:
      "Điều gì xảy ra nếu `go()` được thay đổi thành `static int go()` và `return x` được thêm vào cuối `finally`?",
    code: "public class TestFlow {\n  static int go(int x) {\n    try {\n      return x;\n    } finally {\n      x = 5;\n      // return x; <--- được thêm vào đây\n    }\n  }\n  public static void main(String[] args) {\n    System.out.print(go(10));\n  }\n}",
    options: ["10", "5", "Lỗi biên dịch.", "Lỗi runtime."],
    answer: 1,
    explanation:
      "`try` cố gắng return 10. `finally` chạy, thay đổi x=5 VÀ return 5. `return` của `finally` ghi đè giá trị trả về của `try`. Đầu ra: 5 [28].",
  },
  {
    id: 2299,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `CheckedA` và `CheckedB` là hai Checked Exceptions không có quan hệ kế thừa. Thứ tự nào sau đây là **luôn** hợp lệ?",
    code: "  // Catch blocks for CheckedA and CheckedB",
    options: [
      "`catch (CheckedA a) {} catch (CheckedB b) {}`",
      "`catch (CheckedB b) {} catch (CheckedA a) {}`",
      "Cả A và B đều luôn hợp lệ.",
      "Cả A và B đều không hợp lệ.",
    ],
    answer: 2,
    explanation:
      "Các ngoại lệ anh chị em (Siblings) có thể nằm trong bất kỳ thứ tự nào vì chúng không thể bắt ngoại lệ của nhau [76].",
  },
  {
    id: 2300,
    topic: "Exception Handling",
    type: "code",
    question: "Đoạn code sau có biên dịch không?",
    code: "public class TestFlow {\n  static void risky() throws Exception { throw new Exception(); }\n  public static void main(String[] args) {\n    try {\n      risky();\n    } finally {\n      // cleanup\n    }\n  }\n}",
    options: [
      "Lỗi biên dịch.",
      "Không có lỗi biên dịch.",
      "Chỉ biên dịch nếu `Exception` là `RuntimeException`.",
      "Chỉ biên dịch nếu thêm `catch`.",
    ],
    answer: 0,
    explanation:
      "Checked Exception (`Exception`) được ném, `main()` không Handle (`catch`) và cũng không Declare (`throws`). Lỗi biên dịch [22].",
  },
  {
    id: 2301,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `try` thành công. Giá trị của `y` sau khi `main()` kết thúc là gì?",
    code: "public class TestFlow {\n  static int x = 10; \n  static int y = 0;\n  static void process() {\n    try {\n      x = 5;\n      return; \n    } finally {\n      y = 10;\n    }\n  }\n  public static void main(String[] args) {\n    process();\n    System.out.print(y);\n  }\n}",
    options: ["0", "10", "5", "Lỗi biên dịch."],
    answer: 1,
    explanation:
      "`try` chạy, đặt x=5, gặp `return`. `finally` chạy (y=10). Dù có `return`, `finally` vẫn chạy, nên y = 10 [28]. Đầu ra: 10.",
  },
  {
    id: 2302,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `main()` không khai báo `throws`, đoạn code sau sẽ làm gì?",
    code: 'public class TestFlow {\n  static void risky() throws Exception { throw new Exception(); }\n  public static void main(String[] args) {\n    try {\n      risky();\n    } catch (Exception e) {\n      System.out.print("C");\n    }\n  }\n}',
    options: [
      "Biên dịch thành công.",
      "Lỗi biên dịch.",
      "Lỗi runtime.",
      "In ra C.",
    ],
    answer: 0,
    explanation:
      "Mặc dù `Exception` là Checked, khối `catch (Exception e)` đã Handle nó, nên không cần `throws` trong `main()` [24, 49].",
  },
  {
    id: 2303,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `try` ném `RuntimeException`. Đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("1");\n      throw new RuntimeException();\n    } catch (Throwable t) {\n      System.out.print("2");\n    } finally {\n      System.out.print("3");\n    }\n    System.out.print("4");\n  }\n}',
    options: ["1234", "134", "123", "Lỗi runtime."],
    answer: 0,
    explanation:
      "`Throwable` là lớp cha của mọi ngoại lệ và lỗi, nó bắt được `RuntimeException`. try in '1', ném ngoại lệ. `catch` in '2'. `finally` in '3'. Code sau đó in '4'. Đầu ra: 1234 [14, 20, 28].",
  },
  {
    id: 2304,
    topic: "Exception Handling",
    type: "code",
    question: "Điều gì xảy ra khi `go()` được gọi?",
    code: 'public class TestFlow {\n  static int go() {\n    try {\n      System.out.print("T");\n      return 1;\n    } finally {\n      System.out.print("F");\n      if (true) throw new RuntimeException();\n    }\n  }\n  public static void main(String[] args) {\n    try { System.out.print(go()); } catch(RuntimeException e) { System.out.print("C"); }\n  }\n}',
    options: ["T F 1 C", "T F C", "T C F 1", "T 1 F C"],
    answer: 1,
    explanation:
      "`go()`: `try` in 'T', return 1. `finally` chạy, in 'F', ném `RuntimeException` (ghi đè `return`). Ngoại lệ lan truyền đến `main()`. `main()` bắt (in 'C'). Đầu ra: TFC.",
  },
  {
    id: 2305,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `try` thành công. Đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("A");\n    } catch (Exception e) {\n      System.out.print("B");\n    } finally {\n      System.out.print("C");\n    }\n    System.out.print("D");\n  }\n}',
    options: ["ABCD", "ACD", "ABD", "BCD"],
    answer: 1,
    explanation:
      "`try` in 'A'. Bỏ qua `catch` ('B'). `finally` in 'C'. Code sau đó in 'D'. Đầu ra: ACD [28, 29].",
  },
  {
    id: 2306,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `doRisky()` ném `RuntimeException`. Đầu ra là gì?",
    code: 'public class TestFlow {\n  public static void main(String[] args) {\n    try {\n      System.out.print("X");\n      if (true) throw new RuntimeException();\n    } catch (Error e) {\n      System.out.print("Y");\n    } finally {\n      System.out.print("Z");\n    }\n  }\n}',
    options: ["X Y Z", "X Z và kết thúc bất thường.", "X Y", "X Z"],
    answer: 1,
    explanation:
      "`RuntimeException` không phải là `Error`. `try` in 'X', ném ngoại lệ (không khớp `catch`). `finally` in 'Z'. Ngoại lệ lan truyền và JVM xử lý mặc định. Đầu ra: XZ.",
  },
  {
    id: 2307,
    topic: "Exception Handling",
    type: "code",
    question:
      "Nếu `Parent` và `Child` là hai Exceptions (Checked). Đoạn code nào sau đây gây lỗi biên dịch?",
    code: "  // P extends Exception, C extends P\n  public static void main(String[] args) {\n    try { throw new Child(); }\n    catch (Child c) {} \n    catch (Parent p) {}\n  }",
    options: [
      "Lỗi biên dịch.",
      "Không có lỗi biên dịch.",
      "Lỗi runtime.",
      "Cần thêm `finally`.",
    ],
    answer: 1,
    explanation:
      "Thứ tự Cụ thể (Child) trước Tổng quát (Parent) là chính xác [48, 71]. Vì chúng là Checked Exception, và được bắt, nên không cần `throws` trong `main()`. Code biên dịch thành công.",
  },
  {
    id: 2308,
    topic: "Exception Handling",
    type: "code",
    question:
      "Trong cú pháp sau, điều gì xảy ra nếu `Risky.go()` ném `CheckedException`?",
    code: 'class CheckedException extends Exception {}\nclass Risky {\n  static void go() throws CheckedException { throw new CheckedException(); }\n}\npublic class TestFlow {\n  public static void main(String[] args) throws CheckedException {\n    try {\n      Risky.go();\n    } finally {\n      System.out.print("F");\n    }\n    System.out.print("E");\n  }\n}',
    options: [
      "FE và kết thúc bất thường.",
      "F E.",
      "F E và kết thúc bất thường.",
      "Lỗi biên dịch.",
    ],
    answer: 0,
    explanation:
      "go() ném ngoại lệ. `main()` có `throws` (Declare) và `finally`. `finally` in 'F' [28]. Ngoại lệ tiếp tục lan truyền và được JVM xử lý mặc định (kết thúc bất thường, bỏ qua 'E'). Đầu ra: F.",
  },
  {
    id: 2309,
    topic: "Exception Handling",
    type: "code",
    question: "Nếu `try` thành công. Giá trị cuối cùng của `result` là gì?",
    code: "public class TestFlow {\n  static int calculate(boolean error) {\n    int result = 1;\n    try {\n      if (error) throw new RuntimeException();\n      result = 2;\n    } catch (RuntimeException e) {\n      result = 3;\n    } finally {\n      result = result * 10;\n    }\n    return result;\n  }\n  public static void main(String[] args) {\n    System.out.print(calculate(false));\n  }\n}",
    options: ["10", "20", "30", "1"],
    answer: 1,
    explanation:
      "calculate(false): result = 1. `try` đặt result = 2. `catch` bị bỏ qua. `finally` chạy: result = 2 * 10 = 20. Trả về 20. Đầu ra: 20.",
  },
  {
    id: 2500,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế (Design Pattern) được định nghĩa là gì?",
    options: [
      "Các lớp hoặc đối tượng cụ thể được định nghĩa sẵn.",
      "Các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm.",
      "Các thuật toán phức tạp được tích hợp sẵn trong Java.",
      "Các cú pháp bắt buộc trong ngôn ngữ lập trình hướng đối tượng.",
    ],
    answer: 1,
    explanation:
      "Design patterns là các giải pháp có thể tái sử dụng cho các vấn đề phổ biến trong thiết kế phần mềm [1, 2].",
  },
  {
    id: 2501,
    topic: "Design Patterns",
    type: "radio",
    question: "Lợi ích nào sau đây được đề cập khi sử dụng Design Patterns?",
    options: [
      "Giảm thiểu sự cần thiết của lập trình hướng đối tượng.",
      "Thúc đẩy việc tái sử dụng thiết kế trong các hệ thống tương lai.",
      "Làm cho mã nguồn phụ thuộc vào ngôn ngữ lập trình cụ thể (ví dụ: Java).",
      "Kéo dài giai đoạn thiết kế của quy trình phát triển phần mềm.",
    ],
    answer: 1,
    explanation:
      "Design patterns thúc đẩy việc tái sử dụng thiết kế trong các hệ thống tương lai [3].",
  },
  {
    id: 2502,
    topic: "Design Patterns",
    type: "radio",
    question: "Design Patterns giúp ích gì cho các nhà phát triển?",
    options: [
      "Chúng thiết lập một từ vựng thiết kế chung giữa các nhà phát triển.",
      "Chúng là các lớp và đối tượng cụ thể để khởi tạo.",
      "Chúng chỉ có thể được triển khai trong Java.",
      "Chúng là tập hợp các phương thức tĩnh.",
    ],
    answer: 0,
    explanation:
      "Design patterns thiết lập một từ vựng thiết kế chung giữa các nhà phát triển và rút ngắn giai đoạn thiết kế của quy trình phát triển phần mềm [3].",
  },
  {
    id: 2503,
    topic: "Design Patterns",
    type: "radio",
    question: "Design Pattern được phân loại thành bao nhiêu nhóm chính?",
    options: [
      "Hai: Creational và Structural.",
      "Ba: Creational, Structural và Behavioral.",
      "Bốn: Basic, Advanced, Enterprise và Core.",
      "Năm: SOLID.",
    ],
    answer: 1,
    explanation:
      "Có ba thể loại Design Patterns: Creational (Khởi tạo), Structural (Cấu trúc) và Behavioral (Hành vi) [4].",
  },
  {
    id: 2504,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục tiêu chính của Creational Patterns là gì?",
    options: [
      "Tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả.",
      "Tập trung vào giao tiếp và trách nhiệm giữa các đối tượng.",
      "Tập trung vào việc tạo đối tượng để đảm bảo tính linh hoạt và tái sử dụng.",
      "Ẩn giấu các chi tiết triển khai phức tạp.",
    ],
    answer: 2,
    explanation:
      "Creational patterns tập trung vào việc tạo đối tượng để đảm bảo tính linh hoạt và tái sử dụng [4, 5].",
  },
  {
    id: 2505,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục tiêu chính của Structural Patterns là gì?",
    options: [
      "Đảm bảo chỉ có một instance của một class.",
      "Tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả.",
      "Định nghĩa một nhóm các thuật toán có thể hoán đổi cho nhau.",
      "Cung cấp các giải pháp kế thừa.",
    ],
    answer: 1,
    explanation:
      "Structural patterns tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả [4, 6].",
  },
  {
    id: 2506,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục tiêu chính của Behavioral Patterns là gì?",
    options: [
      "Tập trung vào object creation (khởi tạo đối tượng).",
      "Tập trung vào giao tiếp và trách nhiệm giữa các đối tượng.",
      "Cung cấp một cầu nối giữa các interface không tương thích.",
      "Giúp tạo ra các đối tượng mới bằng cách sao chép đối tượng hiện có.",
    ],
    answer: 1,
    explanation:
      "Behavioral patterns tập trung vào giao tiếp và trách nhiệm giữa các đối tượng [4, 7].",
  },
  {
    id: 2507,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế nào sau đây thuộc nhóm Creational Pattern?",
    options: ["Adapter", "Decorator", "Singleton", "Iterator"],
    answer: 2,
    explanation: "Singleton là một Creational Pattern [4, 6].",
  },
  {
    id: 2508,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế nào sau đây thuộc nhóm Structural Pattern?",
    options: ["Factory method", "Strategy", "Adapter", "Prototype"],
    answer: 2,
    explanation:
      "Adapter, Composite, và Decorator là Structural Patterns được giới thiệu [4, 8].",
  },
  {
    id: 2509,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế nào sau đây thuộc nhóm Behavioral Pattern?",
    options: ["Abstract factory", "Composite", "Strategy", "Façade"],
    answer: 2,
    explanation: "Strategy là một Behavioral Pattern [9].",
  },
  {
    id: 2510,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Decorator thuộc thể loại Design Pattern nào?",
    options: ["Creational", "Structural", "Behavioral", "Utility"],
    answer: 1,
    explanation: "Decorator là một Structural Design Pattern [4, 8].",
  },
  {
    id: 2511,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Prototype thuộc thể loại Design Pattern nào?",
    options: ["Creational", "Structural", "Behavioral", "Utility"],
    answer: 0,
    explanation: "Prototype là một Creational Design Pattern [4].",
  },
  {
    id: 2512,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Template Method thuộc thể loại Design Pattern nào?",
    options: ["Creational", "Structural", "Behavioral", "Utility"],
    answer: 2,
    explanation: "Template Method là một Behavioral Pattern [9].",
  },
  {
    id: 2513,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Theo tài liệu, Design Pattern giúp xây dựng phần mềm đáng tin cậy bằng cách tận dụng những gì?",
    options: [
      "Các thuật toán mới nhất.",
      "Các kiến trúc đã được chứng minh và kinh nghiệm tích lũy trong ngành.",
      "Sự phụ thuộc chặt chẽ vào ngôn ngữ Java.",
      "Việc loại bỏ hoàn toàn các lớp trừu tượng.",
    ],
    answer: 1,
    explanation:
      "Chúng giúp xây dựng phần mềm đáng tin cậy bằng cách tận dụng các kiến trúc đã được chứng minh và kinh nghiệm tích lũy trong ngành [3].",
  },
  {
    id: 2514,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào tập trung vào việc tổ chức và kết hợp các đối tượng?",
    options: [
      "Creational patterns",
      "Structural patterns",
      "Behavioral patterns",
      "Utility patterns",
    ],
    answer: 1,
    explanation:
      "Structural patterns tập trung vào việc tổ chức và kết hợp các đối tượng để có mối quan hệ hiệu quả [10].",
  },

  // --- CHỦ ĐỀ: SINGLETON PATTERN (Q2515-Q2559) ---
  {
    id: 2515,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích chính của Singleton Pattern là gì?",
    options: [
      "Đảm bảo rằng một class có thể được kế thừa.",
      "Đảm bảo rằng chỉ có một instance của một class tồn tại trong hệ thống.",
      "Cho phép tạo nhiều đối tượng bằng cách sử dụng một factory.",
      "Đảm bảo rằng constructor có tham số luôn được gọi.",
    ],
    answer: 1,
    explanation:
      "Singleton Pattern đảm bảo rằng chỉ có một instance duy nhất của một class tồn tại [9, 11].",
  },
  {
    id: 2516,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Cơ chế nào sau đây là yêu cầu cơ bản để triển khai Singleton Pattern?",
    options: [
      "Một constructor công khai (public constructor).",
      "Một phương thức trừu tượng (abstract method).",
      "Một constructor private (private constructor).",
      "Việc triển khai interface `Serializable`.",
    ],
    answer: 2,
    explanation:
      "Singleton Pattern thường yêu cầu một Private Constructor để ngăn chặn việc tạo đối tượng bên ngoài class [12].",
  },
  {
    id: 2517,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Singleton Pattern, tại sao constructor cần phải là private?",
    options: [
      "Để cho phép class đó được kế thừa.",
      "Để ngăn chặn việc tạo đối tượng bên ngoài class.",
      "Để cho phép Garbage Collector thu hồi đối tượng.",
      "Để đảm bảo rằng phương thức `getInstance()` là non-static.",
    ],
    answer: 1,
    explanation:
      "Constructor Private ngăn chặn việc tạo đối tượng bên ngoài class [12].",
  },
  {
    id: 2518,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu cố gắng kế thừa một class có constructor private, điều gì sẽ xảy ra?",
    options: [
      "Lỗi runtime.",
      "Lỗi biên dịch.",
      "Class con sẽ được tạo thành công nhưng không thể khởi tạo.",
      "Nó hoạt động bình thường, nhưng class con không thể có constructor riêng.",
    ],
    answer: 1,
    explanation:
      "Nếu chúng ta cố gắng mở rộng một class có constructor private, một lỗi biên dịch sẽ xảy ra [13].",
  },
  {
    id: 2519,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Phương thức nào được sử dụng để truy cập instance duy nhất trong Singleton Pattern?",
    options: [
      "new Singleton()",
      "static createObject()",
      "public final getUnique()",
      "static Singleton getInstance()",
    ],
    answer: 3,
    explanation:
      "Trong ví dụ mã nguồn, instance được truy cập thông qua phương thức static `getInstance()` [14].",
  },
  {
    id: 2520,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Instance duy nhất của Singleton class thường được lưu trữ trong một biến nào?",
    options: [
      "final non-static",
      "private static",
      "public non-static",
      "protected volatile",
    ],
    answer: 1,
    explanation:
      "Trong ví dụ, instance duy nhất được lưu trữ trong một trường private static final [14].",
  },
  {
    id: 2521,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong bối cảnh hệ thống, ví dụ điển hình nào được sử dụng để minh họa Singleton Pattern?",
    options: [
      "Tạo nhiều đối tượng Xe (Vehicle) khác nhau.",
      "Quản lý kết nối đến cơ sở dữ liệu (Database connection).",
      "Thêm chức năng động vào một đối tượng.",
      "Thao tác các đối tượng trong cấu trúc thư mục.",
    ],
    answer: 1,
    explanation:
      "Một ví dụ là một số hệ thống kết nối với cơ sở dữ liệu bằng cách sử dụng một đối tượng duy nhất quản lý các kết nối cơ sở dữ liệu [9].",
  },
  {
    id: 2522,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu tất cả các phương thức trong một class đều là static, điều gì có thể được sử dụng để ngăn chặn việc tạo đối tượng không cần thiết?",
    options: [
      "Một constructor public.",
      "Một constructor private.",
      "Khai báo class là abstract.",
      "Khai báo class là interface.",
    ],
    answer: 1,
    explanation:
      "Nếu tất cả các phương thức đều là static, thì một constructor private có thể được sử dụng [12].",
  },
  {
    id: 2523,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Việc sử dụng Singleton để quản lý kết nối cơ sở dữ liệu giúp ngăn chặn điều gì có thể làm chậm hệ thống?",
    options: [
      "Việc sử dụng các phương thức non-static.",
      "Việc khởi tạo các kết nối không cần thiết bởi các đối tượng khác.",
      "Việc sử dụng quá nhiều biến cục bộ.",
      "Các lỗi liên quan đến đa hình.",
    ],
    answer: 1,
    explanation:
      "Cách tiếp cận này đảm bảo rằng không có đối tượng nào khác có thể khởi tạo các kết nối không cần thiết, điều này có thể làm chậm hệ thống [14].",
  },
  {
    id: 2524,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Điều gì xảy ra nếu hai tham chiếu được lấy từ `Singleton.getInstance()`?",
    options: [
      "Chúng luôn trỏ đến các đối tượng khác nhau.",
      "Chúng trỏ đến cùng một đối tượng Singleton.",
      "Lỗi biên dịch nếu cố gắng so sánh chúng.",
      "Một trong hai tham chiếu sẽ là null.",
    ],
    answer: 1,
    explanation:
      "Trong ví dụ mã, nếu `first == second` thì chúng tham chiếu đến cùng một đối tượng Singleton [12].",
  },
  {
    id: 2525,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Để triển khai Singleton, class cần có một phương thức khởi tạo đối tượng duy nhất. Phương thức này thường là:",
    options: [
      "public và non-static.",
      "private và non-static.",
      "public và static.",
      "private và final.",
    ],
    answer: 2,
    explanation:
      "Class Singleton cung cấp một phương thức static (ví dụ: `getInstance()`) [9, 14].",
  },
  {
    id: 2526,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Việc sử dụng constructor private trong Singleton có tác dụng phụ nào khác ngoài việc ngăn chặn khởi tạo bên ngoài?",
    options: [
      "Nó ngăn chặn class khỏi bị thu hồi bởi GC.",
      "Nó ngăn chặn class khỏi bị kế thừa (subclassing).",
      "Nó cho phép class được sử dụng trong đa luồng.",
      "Nó yêu cầu tất cả các trường phải là public.",
    ],
    answer: 1,
    explanation:
      "Private Constructor ngăn class khỏi bị kế thừa (subclassed) [12].",
  },
  {
    id: 2527,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu `Singleton` class có constructor private, điều gì xảy ra nếu ta cố gắng tạo một instance mới bằng `new Singleton()`?",
    options: [
      "Lỗi runtime (NullPointerException).",
      "Một instance mới được tạo nhưng không được khởi tạo.",
      "Lỗi biên dịch.",
      "Instance được tạo trong Thread an toàn.",
    ],
    answer: 2,
    explanation:
      "Constructor private ngăn việc tạo đối tượng bên ngoài class, dẫn đến lỗi biên dịch nếu cố ý gọi [12].",
  },
  {
    id: 2528,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Java, một class `Singleton` thường được khai báo là `public final` để nhấn mạnh điều gì?",
    options: [
      "Nó phải có ít nhất một phương thức trừu tượng.",
      "Nó là một hằng số.",
      "Nó không thể được kế thừa và có thể truy cập công khai.",
      "Nó cần được tuần tự hóa.",
    ],
    answer: 2,
    explanation:
      "Trong ví dụ, class được khai báo là `public final class Singleton` [14]. Từ khóa `final` trên class ngăn chặn việc kế thừa [15].",
  },
  {
    id: 2529,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Singleton được xếp vào nhóm Design Pattern nào?",
    options: ["Structural", "Behavioral", "Creational", "Adapter"],
    answer: 2,
    explanation: "Singleton là một Creational Pattern [4].",
  },
  {
    id: 2530,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong sơ đồ cấu trúc của Singleton, trường nào đại diện cho instance duy nhất?",
    options: [
      "static uniqueInstance data",
      "getData()",
      "operation()",
      "static Instance()",
    ],
    answer: 0,
    explanation: "Sơ đồ Singleton có 'static uniqueInstance data' [9].",
  },
  {
    id: 2531,
    topic: "Design Patterns",
    type: "radio",
    question: "Trong trường hợp nào, Singleton được xem là hữu ích nhất?",
    options: [
      "Khi cần tạo nhiều đối tượng con khác nhau.",
      "Khi cần kiểm soát truy cập đối với một tài nguyên dùng chung duy nhất.",
      "Khi cần thay đổi thuật toán ở runtime.",
      "Khi cần gói gọn các interface không tương thích.",
    ],
    answer: 1,
    explanation:
      "Singleton đảm bảo chỉ có một instance, hữu ích cho các tài nguyên giới hạn (ví dụ: kết nối DB) [9].",
  },
  {
    id: 2532,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một class Singleton có constructor private, nó ảnh hưởng đến khả năng kế thừa của nó như thế nào?",
    options: [
      "Nó chỉ có thể kế thừa các interface.",
      "Nó có thể được kế thừa nếu sử dụng từ khóa `protected`.",
      "Nó ngăn chặn class khỏi bị kế thừa.",
      "Nó không có ảnh hưởng gì.",
    ],
    answer: 2,
    explanation:
      "Constructor private ngăn class khỏi bị kế thừa (subclassed) [12].",
  },
  {
    id: 2533,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Singleton Pattern thuộc nhóm Design Patterns tập trung vào điều gì?",
    options: [
      "Organization and Composition (Tổ chức và Kết hợp).",
      "Communication and Responsibility (Giao tiếp và Trách nhiệm).",
      "Object Creation (Tạo đối tượng).",
      "Incompatible Interfaces (Giao diện không tương thích).",
    ],
    answer: 2,
    explanation:
      "Singleton là Creational Pattern, tập trung vào object creation [4].",
  },
  {
    id: 2534,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong một triển khai Singleton kiểu Eager Initialization, instance được tạo ra khi nào?",
    options: [
      "Khi phương thức `getInstance()` được gọi lần đầu tiên.",
      "Khi class được load bởi Class Loader.",
      "Khi class được khởi tạo trong constructor.",
      "Khi client tạo một đối tượng mới.",
    ],
    answer: 1,
    explanation:
      "Triển khai Eager (như ví dụ `private static final Singleton singleton = new Singleton();`) tạo instance khi class được tải [14].",
  },
  {
    id: 2535,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một class chỉ có các phương thức static, thì việc sử dụng constructor private được coi là thực hành tốt cho mục đích gì?",
    options: [
      "Cho phép class đó được sử dụng bởi các luồng khác nhau.",
      "Ngăn chặn việc tạo instance không cần thiết.",
      "Bắt buộc class đó phải được kế thừa.",
      "Cho phép truy cập các trường non-static.",
    ],
    answer: 1,
    explanation:
      "Nếu tất cả các phương thức là static, constructor private có thể được sử dụng để ngăn chặn việc tạo đối tượng [12].",
  },
  {
    id: 2536,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Điều gì xảy ra nếu trong một class Singleton, ta bỏ quên từ khóa `static` cho biến chứa instance duy nhất?",
    options: [
      "Nó vẫn là Singleton hợp lệ.",
      "Mỗi lần gọi `getInstance()` sẽ tạo ra một instance mới.",
      "Phương thức `getInstance()` phải là non-static.",
      "Nó sẽ gây ra lỗi biên dịch vì constructor là private.",
    ],
    answer: 2,
    explanation:
      "Nếu instance không phải là static, nó thuộc về đối tượng, do đó `getInstance()` cũng phải là non-static để truy cập nó, làm phá vỡ mô hình Singleton.",
  },
  {
    id: 2537,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Vì sao việc khởi tạo nhiều kết nối cơ sở dữ liệu không cần thiết lại làm chậm hệ thống?",
    options: [
      "Vì nó làm tăng số lượng phương thức cần được gọi.",
      "Vì nó tiêu tốn tài nguyên hệ thống (như bộ nhớ và cổng mạng) cho mỗi kết nối.",
      "Vì nó buộc phải sử dụng các interface trừu tượng.",
      "Vì nó vi phạm nguyên tắc Open/Closed.",
    ],
    answer: 1,
    explanation:
      "Singleton giúp ngăn các đối tượng khác khởi tạo các kết nối không cần thiết, điều này có thể làm chậm hệ thống [14].",
  },
  {
    id: 2538,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong triển khai Singleton, nếu `uniqueInstance` là `null`, điều đó có nghĩa là gì?",
    options: [
      "Class đã bị GC thu hồi.",
      "Instance duy nhất chưa được tạo.",
      "Phương thức `getInstance()` là non-static.",
      "Constructor là public.",
    ],
    answer: 1,
    explanation:
      "Nếu triển khai Lazy, instance sẽ là null cho đến khi được tạo lần đầu tiên (ngược lại với ví dụ Eager) [9].",
  },
  {
    id: 2539,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một class `Singleton` không được khai báo là `final`, nó có thể dẫn đến vấn đề nào nếu constructor là `private`?",
    options: [
      "Vẫn có thể bị kế thừa nếu sử dụng reflection (ngoài phạm vi các nguồn).",
      "Vẫn an toàn khỏi việc khởi tạo nhiều lần.",
      "Không có vấn đề gì, vì `private` constructor ngăn chặn kế thừa.",
      "Nó buộc phải sử dụng Lazy initialization.",
    ],
    answer: 2,
    explanation:
      "Constructor private đã ngăn chặn việc kế thừa trong Java [12].",
  },
  {
    id: 2540,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Singleton được sử dụng trong hệ thống khi nào?",
    options: [
      "Khi cần tạo ra một nhóm các đối tượng liên quan.",
      "Khi cần tạo nhiều instance của một đối tượng tương tự nhau.",
      "Khi hệ thống cần đảm bảo chỉ có một instance của một class tồn tại.",
      "Khi cần thiết kế các thuật toán có thể hoán đổi.",
    ],
    answer: 2,
    explanation:
      "Singleton được sử dụng để đảm bảo chỉ có một instance tồn tại [9].",
  },
  {
    id: 2541,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong triển khai Singleton (Eager Initialization), việc instance được khai báo `final` đảm bảo điều gì?",
    options: [
      "Instance có thể thay đổi trong suốt vòng đời của chương trình.",
      "Instance được tạo ra muộn nhất có thể (lazy).",
      "Tham chiếu đến instance không thể thay đổi sau khi được gán giá trị.",
      "Class đó có thể được kế thừa dễ dàng.",
    ],
    answer: 2,
    explanation:
      "Từ khóa `final` biến đó là hằng số, tức là chỉ được thiết lập một lần và không thay đổi [16].",
  },
  {
    id: 2542,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Singleton không phải là `final`, và ta cố gắng kế thừa nó, lỗi nào sẽ xảy ra nếu constructor là `private`?",
    options: [
      "ClassCastException",
      "NullPointerException",
      "Compile-time error",
      "RuntimeException",
    ],
    answer: 2,
    explanation:
      "Nếu cố gắng mở rộng một class có constructor private, lỗi biên dịch sẽ xảy ra [13].",
  },
  {
    id: 2543,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu class `Singleton` không có constructor, Java sẽ tự động thêm constructor mặc định nào?",
    options: [
      "public, không tham số.",
      "private, có tham số.",
      "protected, không tham số.",
      "public, có tham số.",
    ],
    answer: 0,
    explanation:
      "Nếu không có constructor, Java tự động cung cấp constructor mặc định không tham số, thường là `public` [17].",
  },
  {
    id: 2544,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Để đảm bảo tính toàn vẹn của Singleton trong môi trường đa luồng (multi-threaded), cần sử dụng cơ chế nào (trong các lựa chọn sau)?",
    options: [
      "Sử dụng constructor public.",
      "Sử dụng từ khóa `abstract`.",
      "Đảm bảo phương thức `getInstance()` được đồng bộ hóa (synchronized) (nếu Lazy Initialization).",
      "Chỉ sử dụng các trường non-static.",
    ],
    answer: 2,
    explanation:
      "Trong môi trường đa luồng, cần đảm bảo rằng chỉ một luồng có thể tạo instance (thường bằng `synchronized` nếu Lazy) [18].",
  },
  {
    id: 2545,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong triển khai Singleton, việc khởi tạo `Singleton` instance ngay từ đầu được gọi là gì?",
    options: [
      "Lazy Initialization.",
      "Eager Initialization.",
      "Prototype Initialization.",
      "Factory Initialization.",
    ],
    answer: 1,
    explanation:
      "Việc tạo instance ngay lập tức khi class được tải (như trong ví dụ: `private static final Singleton singleton = new Singleton();`) là Eager Initialization [14].",
  },
  {
    id: 2546,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong sơ đồ cấu trúc Singleton, `Instance()` (tức là `getInstance()`) thường có trách nhiệm gì?",
    options: [
      "Tạo ra các instance mới mỗi lần được gọi.",
      "Trả về `uniqueInstance` đã được tạo.",
      "Thiết lập lại constructor.",
      "Ngăn chặn class bị kế thừa.",
    ],
    answer: 1,
    explanation: "Sơ đồ chỉ ra `//Instance() return uniqueInstance;` [9].",
  },
  {
    id: 2547,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một hệ thống yêu cầu kiểm soát việc tạo instance để tránh lãng phí tài nguyên, mẫu nào là phù hợp nhất?",
    options: ["Factory Method", "Strategy", "Decorator", "Singleton"],
    answer: 3,
    explanation:
      "Singleton được sử dụng để ngăn chặn việc khởi tạo các kết nối không cần thiết, làm chậm hệ thống [14].",
  },
  {
    id: 2548,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Một biến Singleton được khai báo là `static` vì nó thuộc về cái gì?",
    options: [
      "Đối tượng (Object)",
      "Vòng lặp (Loop)",
      "Lớp (Class)",
      "Bộ thu rác (Garbage Collector)",
    ],
    answer: 2,
    explanation: "Các trường static thuộc về class thay vì đối tượng [19].",
  },
  {
    id: 2549,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Khi nào Singleton Pattern được xem là có vấn đề (ngoài vấn đề về đa luồng)?",
    options: [
      "Khi cần nhiều đối tượng khác nhau.",
      "Khi cần thay đổi hành vi động.",
      "Khi nó làm cho mã nguồn dễ kiểm thử (testable).",
      "Khi nó làm cho mã nguồn phụ thuộc vào một instance toàn cục.",
    ],
    answer: 3,
    explanation:
      "Việc sử dụng Singleton giới thiệu trạng thái toàn cục (global state) và có thể làm giảm khả năng kiểm thử (ngoài phạm vi các nguồn).",
  },
  {
    id: 2550,
    topic: "Design Patterns",
    type: "radio",
    question: "Điều gì là ĐÚNG về constructor trong class Singleton?",
    options: [
      "Nó phải là public để có thể truy cập.",
      "Nó không có bất kỳ tham số nào.",
      "Nó phải được khai báo là private.",
      "Nó phải gọi constructor lớp cha bằng `super()`.",
    ],
    answer: 2,
    explanation: "Singleton yêu cầu constructor private [12].",
  },
  {
    id: 2551,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu `Singleton` class được triển khai bằng `enum` (ngoài phạm vi các nguồn cụ thể), mục đích chính là gì?",
    options: [
      "Giảm bộ nhớ sử dụng.",
      "Đảm bảo an toàn luồng và ngăn chặn Serialization/Reflection (ngoài phạm vi các nguồn).",
      "Cho phép đa kế thừa.",
      "Tối ưu hóa tốc độ biên dịch.",
    ],
    answer: 1,
    explanation:
      "Việc sử dụng Enum là một cách triển khai Singleton an toàn và ngắn gọn (ngoài phạm vi các nguồn cụ thể).",
  },
  {
    id: 2552,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một class có constructor private, điều gì là KHÔNG THỂ xảy ra?",
    options: [
      "Nó có thể có các phương thức static.",
      "Nó có thể được khởi tạo bên trong chính class đó.",
      "Nó có thể được kế thừa.",
      "Nó có thể có các trường static.",
    ],
    answer: 2,
    explanation: "Constructor private ngăn class khỏi bị kế thừa [12].",
  },
  {
    id: 2553,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu Singleton được sử dụng để kiểm soát loại tài nguyên nào trong một hệ thống?",
    options: [
      "Tài nguyên bất đồng bộ (asynchronous resources).",
      "Các đối tượng chỉ có fields (trường dữ liệu).",
      "Các đối tượng cần được phân bổ trên Stack.",
      "Các tài nguyên cần được sử dụng duy nhất, như trình ghi nhật ký (Logger) hoặc bộ đệm cấu hình.",
    ],
    answer: 3,
    explanation:
      "Ví dụ về quản lý kết nối cơ sở dữ liệu cho thấy Singleton kiểm soát các tài nguyên quan trọng [9].",
  },
  {
    id: 2554,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Việc khởi tạo một đối tượng Singleton (ví dụ: `new Singleton()`) chỉ được thực hiện ở đâu?",
    options: [
      "Trong phương thức `main()` của class khác.",
      "Bên trong chính class `Singleton` đó.",
      "Bằng cách sử dụng Factory Pattern.",
      "Trong lớp con.",
    ],
    answer: 1,
    explanation:
      "Constructor private ngăn việc tạo đối tượng bên ngoài class [12]. Do đó, việc khởi tạo phải diễn ra bên trong class đó (thường là trong khai báo static hoặc trong `getInstance()`).",
  },
  {
    id: 2555,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu class Singleton được khai báo là `final`, mục đích chính của `final` là gì?",
    options: [
      "Ngăn chặn việc thay đổi giá trị của instance.",
      "Ngăn chặn class bị kế thừa.",
      "Ngăn chặn việc ghi đè phương thức.",
      "Ngăn chặn việc gọi phương thức `getInstance()`.",
    ],
    answer: 1,
    explanation: "Final class không thể được kế thừa [15].",
  },
  {
    id: 2556,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Cần sử dụng từ khóa `static` cho phương thức truy cập instance (`getInstance()`) để làm gì?",
    options: [
      "Để phương thức đó phụ thuộc vào instance.",
      "Để cho phép gọi phương thức mà không cần tạo instance.",
      "Để đảm bảo rằng phương thức đó có thể bị ghi đè.",
      "Để nó có thể truy cập các trường non-static.",
    ],
    answer: 1,
    explanation:
      "Phương thức static thuộc về class thay vì đối tượng, cho phép truy cập trực tiếp từ class [19, 20].",
  },
  {
    id: 2557,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Singleton Pattern là một giải pháp cho vấn đề gì trong thiết kế?",
    options: [
      "Giao tiếp giữa các đối tượng.",
      "Tái cấu trúc mã legacy.",
      "Kiểm soát số lượng instance được tạo.",
      "Tổ chức cấu trúc phân cấp.",
    ],
    answer: 2,
    explanation:
      "Singleton đảm bảo chỉ có một instance, kiểm soát việc tạo đối tượng [9].",
  },
  {
    id: 2558,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu class Singleton triển khai `Cloneable` và cho phép clone, điều gì xảy ra?",
    options: [
      "Nó vẫn giữ nguyên tính chất Singleton.",
      "Nó vi phạm nguyên tắc Singleton (có thể tạo nhiều hơn một instance).",
      "Nó không thể clone vì constructor là private.",
      "Nó tự động trở thành Abstract Factory.",
    ],
    answer: 1,
    explanation:
      "Nếu cho phép clone, nó sẽ tạo ra nhiều hơn một instance, vi phạm mô hình Singleton (ngoài phạm vi các nguồn).",
  },
  {
    id: 2559,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Singleton đôi khi bị chỉ trích vì làm giảm điều gì?",
    options: [
      "Tốc độ khởi tạo chương trình.",
      "Sự rõ ràng của mã nguồn.",
      "Tính linh hoạt (flexibility) và khả năng kiểm thử (testability) (ngoài nguồn).",
      "Tính đa hình.",
    ],
    answer: 2,
    explanation:
      "Singleton tạo ra trạng thái toàn cục, có thể gây khó khăn trong việc kiểm thử (ngoài phạm vi các nguồn).",
  },

  // --- CHỦ ĐỀ: FACTORY METHOD PATTERN (Q2560-Q2604) ---
  {
    id: 2560,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method Pattern là mẫu thiết kế nào?",
    options: ["Structural", "Behavioral", "Creational", "Adapter"],
    answer: 2,
    explanation:
      "Factory Method Pattern là một creational design pattern [13].",
  },
  {
    id: 2561,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích của Factory Method Pattern là gì?",
    options: [
      "Định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo.",
      "Đảm bảo rằng chỉ có một instance của một class tồn tại.",
      "Tạo các đối tượng mới bằng cách sao chép một đối tượng hiện có.",
      "Đóng gói một họ các thuật toán.",
    ],
    answer: 0,
    explanation:
      "Mục đích là định nghĩa một phương thức để tạo đối tượng, nhưng cho phép các lớp con quyết định class nào để khởi tạo [21, 22].",
  },
  {
    id: 2562,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method Pattern cung cấp một interface để làm gì?",
    options: [
      "Để truy cập các trường private.",
      "Để tạo đối tượng.",
      "Để quản lý đa luồng.",
      "Để loại bỏ constructor.",
    ],
    answer: 1,
    explanation:
      "Factory Method Pattern cung cấp một interface để tạo đối tượng [13].",
  },
  {
    id: 2563,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method Pattern, trách nhiệm xác định class cụ thể để khởi tạo được ủy quyền cho ai?",
    options: [
      "Lớp cha (Superclass).",
      "Các lớp con (Subclasses).",
      "Client class (lớp sử dụng).",
      "Singleton instance.",
    ],
    answer: 1,
    explanation:
      "Nó ủy quyền trách nhiệm xác định class cụ thể để khởi tạo cho các lớp con [13].",
  },
  {
    id: 2564,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Thay vì gọi trực tiếp constructor, client sử dụng gì trong Factory Method Pattern?",
    options: [
      "Phương thức `main()`.",
      "Một factory method.",
      "Từ khóa `this`.",
      "Abstract class.",
    ],
    answer: 1,
    explanation:
      "Thay vì gọi trực tiếp constructor, client sử dụng một factory method [13].",
  },
  {
    id: 2565,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method được sử dụng khi nào?",
    options: [
      "Khi chi phí tạo một instance mới là đắt đỏ.",
      "Khi hệ thống cần xác định class nào để khởi tạo tại thời điểm chạy (runtime).",
      "Khi cần thêm chức năng động vào một đối tượng.",
      "Khi cần tổ chức đối tượng trong cấu trúc phân cấp.",
    ],
    answer: 1,
    explanation:
      "Nó hữu ích khi hệ thống cần xác định class nào để khởi tạo tại runtime, dựa trên các điều kiện hoặc input khác nhau [21].",
  },
  {
    id: 2566,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong ví dụ về Factory Method, `VehicleFactory` là một class gì?",
    options: [
      "Concrete class.",
      "Factory client.",
      "Abstract class.",
      "Interface.",
    ],
    answer: 2,
    explanation: "Trong ví dụ mã, `VehicleFactory` là một abstract class [23].",
  },
  {
    id: 2567,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method Pattern, `CarFactory` và `TruckFactory` kế thừa từ `VehicleFactory` và triển khai phương thức nào?",
    options: ["createVehicle()", "create()", "main()", "assemble()"],
    answer: 0,
    explanation:
      "Các Factory cụ thể (`CarFactory`, `TruckFactory`) triển khai phương thức trừu tượng `createVehicle()` của `VehicleFactory` [24].",
  },
  {
    id: 2568,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method Pattern được sử dụng khi trọng tâm là tạo ra loại đối tượng nào?",
    options: [
      "Một nhóm các đối tượng liên quan.",
      "Một sản phẩm cụ thể duy nhất.",
      "Các đối tượng có giao diện không tương thích.",
      "Các thuật toán có thể hoán đổi.",
    ],
    answer: 1,
    explanation:
      "Factory Method được sử dụng khi trọng tâm là tạo ra một sản phẩm cụ thể duy nhất [25].",
  },
  {
    id: 2569,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method Pattern dựa trên cơ chế hướng đối tượng nào?",
    options: [
      "Object composition (Kết hợp đối tượng).",
      "Subclassing (Kế thừa).",
      "Encapsulation (Đóng gói).",
      "Polymorphism (Đa hình) thông qua wildcards.",
    ],
    answer: 1,
    explanation:
      "Factory Method dựa trên subclassing, trong đó mỗi class con triển khai factory method [25].",
  },
  {
    id: 2570,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method, `Vehicle` là class cha (Superclass) có một phương thức trừu tượng tên là gì?",
    options: ["createFactory()", "createVehicle()", "create()", "produce()"],
    answer: 2,
    explanation: "`abstract class Vehicle` có `abstract void create()` [23].",
  },
  {
    id: 2571,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Điều gì xảy ra nếu class client cần tạo `Car` hoặc `Truck` mà không hardcoding class cụ thể?",
    options: [
      "Nó gọi trực tiếp constructor `new Car()`.",
      "Nó sử dụng Singleton để lấy instance.",
      "Nó sử dụng một factory method để quyết định loại nào nên được tạo.",
      "Nó sử dụng Decorator để gói đối tượng.",
    ],
    answer: 2,
    explanation:
      "Một factory method có thể được sử dụng để quyết định loại sản phẩm nào nên được tạo mà không hardcoding class cụ thể [23].",
  },
  {
    id: 2572,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong ví dụ Factory Method, `Car` và `Truck` kế thừa từ class nào?",
    options: ["VehicleFactory", "CarFactory", "Vehicle", "Test"],
    answer: 2,
    explanation: "`Car` và `Truck` kế thừa từ `Vehicle` [23].",
  },
  {
    id: 2573,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong `Test` class (client) của Factory Method, `VehicleFactory` được sử dụng để làm gì?",
    options: [
      "Để gọi phương thức `create()`.",
      "Để tạo ra factory cụ thể (`CarFactory`).",
      "Để tạo ra một `Vehicle` chung chung bằng cách gọi `createVehicle()`.",
      "Để kiểm tra `first == second`.",
    ],
    answer: 2,
    explanation:
      "Client gọi `VehicleFactory carFactory = new CarFactory();` sau đó `Vehicle car = carFactory.createVehicle();` [24].",
  },
  {
    id: 2574,
    topic: "Design Patterns",
    type: "radio",
    question: "Abstract Factory Pattern là mẫu thiết kế nào?",
    options: ["Behavioral", "Structural", "Creational", "Adapter"],
    answer: 2,
    explanation:
      "Abstract Factory Pattern là một creational design pattern [26].",
  },
  {
    id: 2575,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern cung cấp một interface để tạo ra cái gì?",
    options: [
      "Một loại đối tượng duy nhất.",
      "Các families of related or dependent objects (nhóm các đối tượng liên quan).",
      "Một instance duy nhất của một class.",
      "Các thuật toán có thể hoán đổi cho nhau.",
    ],
    answer: 1,
    explanation:
      "Abstract factory pattern cung cấp một interface để tạo ra families of related or dependent objects [26].",
  },
  {
    id: 2576,
    topic: "Design Patterns",
    type: "radio",
    question: "Abstract Factory được sử dụng khi nào?",
    options: [
      "Khi cần sao chép một đối tượng hiện có.",
      "Khi có nhiều sản phẩm liên quan và hệ thống cần duy trì tính tách biệt khỏi các triển khai cụ thể của chúng.",
      "Khi cần đảm bảo tính duy nhất của đối tượng.",
      "Khi cần gói gọn các interface không tương thích.",
    ],
    answer: 1,
    explanation:
      "Nó được sử dụng khi có nhiều sản phẩm liên quan, và hệ thống cần tách biệt khỏi các triển khai cụ thể của chúng [26].",
  },
  {
    id: 2577,
    topic: "Design Patterns",
    type: "radio",
    question: "Abstract Factory Pattern dựa trên cơ chế hướng đối tượng nào?",
    options: [
      "Subclassing (Kế thừa).",
      "Object Composition (Kết hợp đối tượng).",
      "Dynamic Dispatch.",
      "Method Overriding.",
    ],
    answer: 1,
    explanation:
      "Abstract Factory dựa trên object composition. Bản thân factory chứa các phương thức để tạo ra nhiều sản phẩm [25].",
  },
  {
    id: 2578,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Sự khác biệt chính giữa Factory Method và Abstract Factory là gì?",
    options: [
      "Factory Method dựa trên Composition, Abstract Factory dựa trên Subclassing.",
      "Factory Method tạo một loại đối tượng, Abstract Factory tạo nhóm đối tượng liên quan.",
      "Abstract Factory yêu cầu constructor private, Factory Method thì không.",
      "Factory Method không cần interface.",
    ],
    answer: 1,
    explanation:
      "Factory Method tạo một loại đối tượng, Abstract Factory tạo nhóm các đối tượng liên quan [26].",
  },
  {
    id: 2579,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong ví dụ Abstract Factory (Xe cộ), Abstract Factory Interface có tên là gì?",
    options: ["Car", "Truck", "VehicleFactory", "Main"],
    answer: 2,
    explanation: "Abstract factory interface là `VehicleFactory` [27].",
  },
  {
    id: 2580,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Các sản phẩm trừu tượng (Abstract Products) trong ví dụ Abstract Factory là gì?",
    options: [
      "ElectricCar và GasolineCar.",
      "VehicleFactory và Main.",
      "Interface Car và Interface Truck.",
      "ElectricVehicleFactory và GasolineVehicleFactory.",
    ],
    answer: 2,
    explanation:
      "Các Abstract products là `interface Car` và `interface Truck` [28].",
  },
  {
    id: 2581,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory cụ thể nào chịu trách nhiệm tạo ra Electric Car và Electric Truck?",
    options: [
      "CarFactory",
      "ElectricVehicleFactory",
      "GasolineVehicleFactory",
      "Main",
    ],
    answer: 1,
    explanation:
      "`ElectricVehicleFactory` triển khai `VehicleFactory` và tạo ra `ElectricCar` và `ElectricTruck` [29].",
  },
  {
    id: 2582,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Abstract Factory, khách hàng (client) sử dụng Factory class nào để quyết định nhóm sản phẩm được tạo?",
    options: [
      "Context class.",
      "Concrete product class.",
      "Abstract factory interface (VehicleFactory).",
      "Singleton factory.",
    ],
    answer: 2,
    explanation:
      "Client (class Main) sử dụng biến kiểu `VehicleFactory` và gán cho nó một Factory cụ thể (Electric hoặc Gasoline) [29].",
  },
  {
    id: 2583,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern giúp hệ thống duy trì tính chất gì đối với các triển khai sản phẩm cụ thể?",
    options: [
      "Hardcoding (Mã hóa cứng).",
      "Coupled (Gắn kết).",
      "Decoupled (Tách biệt).",
      "Tight coupling (Gắn kết chặt chẽ).",
    ],
    answer: 2,
    explanation:
      "Nó được sử dụng khi hệ thống cần duy trì tính tách biệt (decoupled) khỏi các triển khai cụ thể [26].",
  },
  {
    id: 2584,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Phương thức `createCar()` trong `ElectricVehicleFactory` trả về đối tượng nào?",
    options: ["GasolineCar", "ElectricTruck", "ElectricCar", "VehicleFactory"],
    answer: 2,
    explanation: "`ElectricVehicleFactory` trả về `new ElectricCar()` [29].",
  },
  {
    id: 2585,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu cần mở rộng hệ thống để hỗ trợ động cơ Diesel (Diesel Engine), chúng ta cần thêm class nào theo Abstract Factory Pattern?",
    options: [
      "Thêm phương thức `createDiesel()` vào interface `Car`.",
      "Thêm một Concrete Factory mới (ví dụ: `DieselVehicleFactory`).",
      "Thêm một Singleton cho động cơ Diesel.",
      "Thay đổi `interface VehicleFactory`.",
    ],
    answer: 1,
    explanation:
      "Cần thêm một Factory cụ thể mới để tạo nhóm sản phẩm Diesel [27].",
  },
  {
    id: 2586,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method, lớp con `Car` triển khai phương thức `create()` như thế nào?",
    options: [
      "In ra 'Truck created'.",
      "Trả về `new Truck()`.",
      "In ra 'Car created'.",
      "Gọi `super.create()`.",
    ],
    answer: 2,
    explanation:
      '`class Car extends Vehicle` có `void create() { System.out.println("Car created"); }` [23].',
  },
  {
    id: 2587,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method Pattern thuộc loại Design Pattern nào, tập trung vào việc tạo ra đối tượng?",
    options: ["Behavioral", "Structural", "Creational", "Compositional"],
    answer: 2,
    explanation: "Factory Method là Creational Pattern [13].",
  },
  {
    id: 2588,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Abstract Factory dựa trên Composition, điều đó có nghĩa là gì?",
    options: [
      "Nó bắt buộc phải có constructor private.",
      "Factory chứa các tham chiếu đến các đối tượng chịu trách nhiệm tạo sản phẩm.",
      "Mỗi factory phải là một class con của factory khác.",
      "Nó sử dụng các biến static để tạo đối tượng.",
    ],
    answer: 1,
    explanation:
      "Abstract Factory dựa trên composition. Factory chứa các phương thức để tạo nhiều sản phẩm [25].",
  },
  {
    id: 2589,
    topic: "Design Patterns",
    type: "radio",
    question: "Sử dụng Factory Method giúp client làm gì?",
    options: [
      "Quyết định chính xác class cần khởi tạo tại thời điểm biên dịch.",
      "Tạo ra các đối tượng mà không cần biết class cụ thể của đối tượng đó.",
      "Truy cập trực tiếp vào các trường private.",
      "Giảm thiểu việc sử dụng interface.",
    ],
    answer: 1,
    explanation:
      "Factory method có thể trả về các loại đối tượng khác nhau mà client không hardcoding class cụ thể [13].",
  },
  {
    id: 2590,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Factory Method được sử dụng, và cần thêm một loại sản phẩm mới (ví dụ: Boat), điều gì cần được thực hiện?",
    options: [
      "Sửa đổi `VehicleFactory` để xử lý Boat.",
      "Tạo một `Boat` class mới và một `BoatFactory` class mới kế thừa từ `VehicleFactory`.",
      "Thay đổi tất cả các class đã tồn tại.",
      "Triển khai Singleton.",
    ],
    answer: 1,
    explanation:
      "Vì Factory Method dựa trên Subclassing, cần tạo subclass mới cho sản phẩm và factory tương ứng [24].",
  },
  {
    id: 2591,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong ví dụ Abstract Factory, `GasolineCar` và `ElectricCar` thuộc nhóm nào?",
    options: [
      "Abstract factories.",
      "Abstract products.",
      "Concrete products.",
      "Client classes.",
    ],
    answer: 2,
    explanation:
      "Chúng là các triển khai sản phẩm cụ thể (Concrete product implementation) [28].",
  },
  {
    id: 2592,
    topic: "Design Patterns",
    type: "radio",
    question: "Abstract Factory đảm bảo rằng các đối tượng được tạo ra là gì?",
    options: [
      "Luôn luôn duy nhất (Singleton).",
      "Không liên quan đến nhau.",
      "Có liên quan hoặc phụ thuộc lẫn nhau.",
      "Chỉ sử dụng các kiểu nguyên thủy.",
    ],
    answer: 2,
    explanation:
      "Abstract Factory tạo ra families of related or dependent objects [26].",
  },
  {
    id: 2593,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu client trong Abstract Factory muốn chuyển từ `electric` sang `gasoline`, cần thay đổi điều gì?",
    options: [
      "Thay đổi trực tiếp các constructor của sản phẩm.",
      "Thay đổi biến `factory` để trỏ đến `GasolineVehicleFactory`.",
      "Thay đổi phương thức `assemble()`.",
      "Thay đổi interface `VehicleFactory`.",
    ],
    answer: 1,
    explanation:
      "Client thay đổi đối tượng factory được tham chiếu: `factory = new GasolineVehicleFactory();` [29, 30].",
  },
  {
    id: 2594,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Khi nào nên ưu tiên sử dụng Abstract Factory hơn Factory Method?",
    options: [
      "Khi chỉ cần tạo một loại đối tượng duy nhất.",
      "Khi cần tạo một nhóm các đối tượng liên quan với các triển khai khác nhau.",
      "Khi cần đảm bảo tính duy nhất của đối tượng.",
      "Khi cần gói gọn các interface.",
    ],
    answer: 1,
    explanation:
      "Sử dụng Abstract Factory khi bạn cần tạo một nhóm các đối tượng liên quan với các triển khai khác nhau [25].",
  },
  {
    id: 2595,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method Pattern, `VehicleFactory` là một lớp trừu tượng vì nó chứa phương thức `createVehicle()` là gì?",
    options: ["Concrete", "Static", "Abstract", "Final"],
    answer: 2,
    explanation:
      "`abstract class VehicleFactory { abstract Vehicle createVehicle(); }` [23].",
  },
  {
    id: 2596,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method giúp giảm thiểu sự phụ thuộc của client vào cái gì?",
    options: [
      "Các phương thức của interface.",
      "Các constructor cụ thể của sản phẩm.",
      "Các biến static.",
      "Các ngoại lệ checked.",
    ],
    answer: 1,
    explanation:
      "Client không gọi trực tiếp constructor, mà sử dụng factory method [13].",
  },
  {
    id: 2597,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory đảm bảo rằng, ví dụ, Electric Car và Electric Truck luôn tương thích với nhau, được gọi là gì?",
    options: [
      "Subclassing",
      "Product Family Consistency (Tính nhất quán của nhóm sản phẩm).",
      "Decoupling",
      "SRP",
    ],
    answer: 1,
    explanation:
      "Abstract factory tạo ra families of related objects, đảm bảo chúng tương thích trong cùng một 'họ' (Electric hoặc Gasoline) [26].",
  },
  {
    id: 2598,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào sau đây dựa chủ yếu vào cơ chế kế thừa (Subclassing) để tạo đối tượng?",
    options: ["Abstract Factory", "Singleton", "Strategy", "Factory Method"],
    answer: 3,
    explanation: "Factory Method dựa trên subclassing [25].",
  },
  {
    id: 2599,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Phương thức `createVehicle()` trong `CarFactory` trả về kiểu dữ liệu nào?",
    options: ["CarFactory", "VehicleFactory", "Car", "Truck"],
    answer: 2,
    explanation:
      "`CarFactory` trả về `new Car()`, `Car` là một `Vehicle` [24].",
  },
  {
    id: 2600,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method cho phép client xử lý đối tượng mới bằng cách sử dụng kiểu dữ liệu nào?",
    options: [
      "Kiểu dữ liệu cụ thể (Concrete type).",
      "Kiểu dữ liệu nguyên thủy (Primitive type).",
      "Kiểu dữ liệu chung (General type/Interface).",
      "Kiểu dữ liệu Wrapper.",
    ],
    answer: 2,
    explanation:
      "Client sử dụng `Vehicle` (là lớp chung) để tham chiếu đến `Car` hoặc `Truck` [24].",
  },
  {
    id: 2601,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu hệ thống cần tạo cả xe hơi và xe tải điện (Electric Car và Electric Truck), mẫu nào phù hợp nhất?",
    options: ["Singleton", "Factory Method", "Adapter", "Abstract Factory"],
    answer: 3,
    explanation:
      "Abstract Factory phù hợp để tạo nhóm đối tượng liên quan (Car và Truck) thuộc cùng một biến thể (Electric) [25].",
  },
  {
    id: 2602,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Abstract Factory, interface `Car` và `Truck` có phương thức chung là gì?",
    options: ["createVehicle()", "assemble()", "createCar()", "getInstance()"],
    answer: 1,
    explanation:
      "Cả hai interface `Car` và `Truck` đều có phương thức `void assemble()` [28].",
  },
  {
    id: 2603,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào được sử dụng khi bạn có một cấu trúc class cha-con và muốn các class con tự quyết định việc khởi tạo?",
    options: ["Strategy", "Decorator", "Factory Method", "Composite"],
    answer: 2,
    explanation: "Factory Method ủy quyền việc khởi tạo cho subclasses [13].",
  },
  {
    id: 2604,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Khái niệm 'Decoupled from their concrete implementations' (Tách biệt khỏi các triển khai cụ thể) là mục tiêu chính của mẫu nào?",
    options: ["Singleton", "Abstract Factory", "Strategy", "Adapter"],
    answer: 1,
    explanation:
      "Abstract Factory được sử dụng khi hệ thống cần duy trì tính tách biệt khỏi các triển khai cụ thể [26].",
  },

  // --- CHỦ ĐỀ: STRATEGY PATTERN (Q2605-Q2649) ---
  {
    id: 2605,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Design Pattern thuộc nhóm Design Pattern nào?",
    options: ["Creational", "Structural", "Behavioral", "Abstract"],
    answer: 2,
    explanation:
      "Strategy design pattern là một Behavioral Design Pattern [31, 32].",
  },
  {
    id: 2606,
    topic: "Design Patterns",
    type: "radio",
    question: "Mục đích chính của Strategy Pattern là gì?",
    options: [
      "Đảm bảo sự tồn tại của một instance duy nhất.",
      "Định nghĩa một họ các thuật toán, đóng gói chúng và làm cho chúng có thể hoán đổi cho nhau.",
      "Thêm chức năng mới một cách linh hoạt vào một đối tượng.",
      "Tổ chức các đối tượng trong cấu trúc phân cấp.",
    ],
    answer: 1,
    explanation:
      "Strategy Pattern định nghĩa một họ các thuật toán, đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi cho nhau [31, 33].",
  },
  {
    id: 2607,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Pattern cho phép thuật toán thay đổi như thế nào?",
    options: [
      "Nó phải được sửa đổi thủ công mỗi lần.",
      "Nó thay đổi độc lập với ngữ cảnh (context) sử dụng nó.",
      "Nó thay đổi dựa trên Factory Method.",
      "Nó thay đổi chỉ ở thời điểm biên dịch.",
    ],
    answer: 1,
    explanation:
      "Điều này cho phép thuật toán thay đổi độc lập với ngữ cảnh sử dụng nó [31].",
  },
  {
    id: 2608,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Thành phần cốt lõi nào định nghĩa một interface chung cho tất cả các thuật toán được hỗ trợ trong Strategy Pattern?",
    options: [
      "Context Class",
      "Concrete Strategy",
      "Strategy Interface",
      "Client Class",
    ],
    answer: 2,
    explanation:
      "Strategy interface định nghĩa một interface chung cho tất cả các thuật toán được hỗ trợ [31].",
  },
  {
    id: 2609,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Thành phần nào triển khai các thuật toán khác nhau, mỗi thuật toán trong class riêng của nó?",
    options: [
      "Strategy Interface",
      "Context Class",
      "Concrete Strategies",
      "Adapter",
    ],
    answer: 2,
    explanation:
      "Concrete strategies triển khai các thuật toán khác nhau, mỗi thuật toán trong class riêng của nó [31].",
  },
  {
    id: 2610,
    topic: "Design Patterns",
    type: "radio",
    question: "Context Class trong Strategy Pattern có trách nhiệm gì?",
    options: [
      "Triển khai thuật toán cụ thể.",
      "Định nghĩa interface chung cho tất cả các chiến lược.",
      "Duy trì tham chiếu đến đối tượng Strategy và sử dụng nó để thực thi thuật toán.",
      "Tạo ra các đối tượng Strategy.",
    ],
    answer: 2,
    explanation:
      "Context class duy trì tham chiếu đến đối tượng Strategy và sử dụng nó để thực thi thuật toán [34, 35].",
  },
  {
    id: 2611,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Pattern được sử dụng khi nào?",
    options: [
      "Khi bạn muốn chọn hành vi của một đối tượng một cách linh hoạt tại thời điểm chạy.",
      "Khi bạn cần tạo các đối tượng phức tạp.",
      "Khi bạn cần ẩn cấu trúc đối tượng phức tạp.",
      "Khi bạn muốn buộc các class con phải triển khai một phương thức.",
    ],
    answer: 0,
    explanation:
      "Nó được sử dụng khi bạn muốn chọn hành vi của một thuật toán một cách linh hoạt tại runtime [34, 36].",
  },
  {
    id: 2612,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Ví dụ về hệ thống thanh toán hỗ trợ Credit Card, PayPal, và Google Pay minh họa cho mẫu nào?",
    options: ["Singleton", "Factory Method", "Strategy Pattern", "Composite"],
    answer: 2,
    explanation:
      "Ví dụ về hệ thống thanh toán được sử dụng để minh họa Strategy Pattern [34].",
  },
  {
    id: 2613,
    topic: "Design Patterns",
    type: "radio",
    question: "Trong ví dụ thanh toán, `PaymentStrategy` đóng vai trò là gì?",
    options: [
      "Context Class.",
      "Strategy Interface.",
      "Concrete Strategy.",
      "Factory Method.",
    ],
    answer: 1,
    explanation: "`PaymentStrategy` là Strategy Interface [37].",
  },
  {
    id: 2614,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Các class như `CreditCardPayment`, `PayPalPayment`, và `GooglePayPayment` đóng vai trò là gì trong Strategy Pattern?",
    options: [
      "Context Classes.",
      "Strategy Interfaces.",
      "Concrete Strategies.",
      "Factory Methods.",
    ],
    answer: 2,
    explanation:
      "Chúng là các Concrete Strategies, triển khai phương thức `pay(double amount)` [37, 38].",
  },
  {
    id: 2615,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Class nào trong ví dụ thanh toán giữ tham chiếu đến `PaymentStrategy`?",
    options: [
      "StrategyPatternExample",
      "PaymentContext",
      "CreditCardPayment",
      "PaymentStrategy",
    ],
    answer: 1,
    explanation:
      "`PaymentContext` (Context Class) có trường private `p` kiểu `PaymentStrategy` [38].",
  },
  {
    id: 2616,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Phương thức nào được Context Class sử dụng để thực thi thuật toán đã chọn?",
    options: [
      "pay(double amount)",
      "executePayment(double amount)",
      "getStrategy()",
      "new Strategy()",
    ],
    answer: 1,
    explanation:
      "Context Class có phương thức `executePayment(double amount)` trong đó gọi `p.pay(amount)` [38].",
  },
  {
    id: 2617,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern giải quyết vấn đề nào nếu nhiều class chỉ khác nhau về hành vi?",
    options: [
      "Nó cho phép thay đổi hành vi mà không cần thay đổi cấu trúc class chứa nó.",
      "Nó buộc các class phải có cùng hành vi.",
      "Nó loại bỏ sự cần thiết của kế thừa.",
      "Nó làm cho việc khởi tạo đối tượng phức tạp hơn.",
    ],
    answer: 0,
    explanation:
      "Strategy Pattern hữu ích khi nhiều class chỉ khác nhau về hành vi [34].",
  },
  {
    id: 2618,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Khi client muốn thay đổi phương thức thanh toán trong Strategy Pattern, họ cần làm gì?",
    options: [
      "Thay đổi class `PaymentContext`.",
      "Tạo một `PaymentContext` mới với `PaymentStrategy` mới.",
      "Gọi constructor của `Concrete Strategy`.",
      "Thay đổi interface `PaymentStrategy`.",
    ],
    answer: 1,
    explanation:
      "Client tạo `PaymentContext` mới và truyền Strategy mới vào constructor: `context = new PaymentContext(new PayPalPayment());` [10].",
  },
  {
    id: 2619,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Pattern đóng gói các thuật toán như thế nào?",
    options: [
      "Trong một Singleton class.",
      "Trong các class riêng biệt, làm cho chúng có thể hoán đổi.",
      "Trong các phương thức `private final`.",
      "Sử dụng Decorator.",
    ],
    answer: 1,
    explanation:
      "Nó đóng gói mỗi thuật toán trong một class riêng biệt và làm cho chúng có thể hoán đổi [31, 33].",
  },
  {
    id: 2620,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern được mô tả là định nghĩa một 'họ các thuật toán' (family of algorithms). Điều này có ý nghĩa gì?",
    options: [
      "Chúng phải là các thuật toán kế thừa từ một class cha.",
      "Chúng phải được gói gọn và có một interface chung.",
      "Chúng phải được viết bằng cùng một ngôn ngữ.",
      "Chúng phải có cùng tốc độ thực thi.",
    ],
    answer: 1,
    explanation:
      "Strategy Interface định nghĩa một interface chung cho tất cả các thuật toán được hỗ trợ [31].",
  },
  {
    id: 2621,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu cần thêm một phương thức thanh toán mới (ví dụ: BitcoinPayment), cần thay đổi Strategy Pattern như thế nào?",
    options: [
      "Thêm logic vào `PaymentContext`.",
      "Tạo một `BitcoinPayment` class mới triển khai `PaymentStrategy`.",
      "Thay đổi tất cả các `Concrete Strategy` đã tồn tại.",
      "Sửa đổi `Strategy Interface`.",
    ],
    answer: 1,
    explanation:
      "Thêm một Concrete Strategy mới mà không cần thay đổi cấu trúc Context hoặc các Strategy cũ [31].",
  },
  {
    id: 2622,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, `Context Class` không biết chi tiết triển khai của `Concrete Strategy` nào, điều này giúp đảm bảo nguyên tắc SOLID nào?",
    options: [
      "Single Responsibility Principle (SRP).",
      "Open/Closed Principle (OCP).",
      "Liskov Substitution Principle (LSP).",
      "Dependency Inversion Principle (DIP).",
    ],
    answer: 1,
    explanation:
      "Việc mở rộng hệ thống bằng cách thêm Strategy mới mà không thay đổi Context hỗ trợ OCP [39].",
  },
  {
    id: 2623,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Strategy Pattern được sử dụng, các thuật toán phải có interface chung để làm gì?",
    options: [
      "Để chúng có thể được khởi tạo bằng Factory Method.",
      "Để Context Class có thể sử dụng chúng một cách thống nhất (uniformly).",
      "Để chúng có thể được tuần tự hóa.",
      "Để chúng có thể là Singleton.",
    ],
    answer: 1,
    explanation:
      "Strategy Interface định nghĩa interface chung cho phép Context sử dụng bất kỳ Strategy nào [31].",
  },
  {
    id: 2624,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong ví dụ thanh toán, Context Class được khởi tạo bằng đối tượng nào?",
    options: [
      "Một đối tượng `Double`.",
      "Một đối tượng `PaymentStrategy`.",
      "Một đối tượng `String`.",
      "Một đối tượng `Integer`.",
    ],
    answer: 1,
    explanation:
      "Constructor của `PaymentContext` nhận tham số kiểu `PaymentStrategy`: `public PaymentContext(PaymentStrategy p)` [38].",
  },
  {
    id: 2625,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu không sử dụng Strategy Pattern, việc triển khai nhiều hành vi khác nhau trong một class (ví dụ: `PaymentProcessor`) sẽ dẫn đến vấn đề gì?",
    options: [
      "Vi phạm SRP (Single Responsibility Principle).",
      "Vi phạm LSP.",
      "Vi phạm ISP.",
      "Vi phạm DIP.",
    ],
    answer: 0,
    explanation:
      "Nếu một class chứa nhiều thuật toán, nó sẽ có nhiều lý do để thay đổi, vi phạm SRP [40].",
  },
  {
    id: 2626,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Pattern được sử dụng khi nào trong thiết kế phần mềm?",
    options: [
      "Khi các class khác nhau cần được xử lý như nhau (Polymorphism).",
      "Khi cần gói gọn logic nghiệp vụ và dữ liệu.",
      "Khi cần đảm bảo tính linh hoạt trong việc thay đổi thuật toán.",
      "Khi cần giải quyết vấn đề đa kế thừa.",
    ],
    answer: 2,
    explanation:
      "Strategy Pattern cho phép thay đổi hành vi (thuật toán) độc lập với context [31].",
  },
  {
    id: 2627,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, client chỉ cần tương tác với thành phần nào để thực hiện hành vi?",
    options: [
      "Concrete Strategy",
      "Strategy Interface",
      "Context Class",
      "Factory Class",
    ],
    answer: 2,
    explanation:
      "Client tạo Context và gọi phương thức thực thi của Context (`executePayment`) [10].",
  },
  {
    id: 2628,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu cần áp dụng các quy tắc giảm giá khác nhau cho một đơn hàng (ví dụ: theo mùa, theo khách hàng thân thiết), mẫu nào là lý tưởng để quản lý các quy tắc giảm giá này?",
    options: ["Singleton", "Adapter", "Strategy", "Composite"],
    answer: 2,
    explanation:
      "Strategy Pattern có thể đóng gói từng quy tắc giảm giá thành một Concrete Strategy [31].",
  },
  {
    id: 2629,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào tạo ra các thuật toán có thể 'hoán đổi cho nhau' (interchangeable)?",
    options: ["Factory Method", "Decorator", "Strategy", "Prototype"],
    answer: 2,
    explanation:
      "Strategy Pattern làm cho các thuật toán có thể hoán đổi cho nhau [31, 33].",
  },
  {
    id: 2630,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong ví dụ thanh toán, `PayPalPayment.pay(double amount)` sẽ in ra điều gì?",
    options: [
      "Paid $ + amount + using Credit Card.",
      "Paid $ + amount + using PayPal.",
      "Paid $ + amount + using Google Pay.",
      "Error: payment failed.",
    ],
    answer: 1,
    explanation: "`PayPalPayment` in ra thông báo thanh toán bằng PayPal [37].",
  },
  {
    id: 2631,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Context Class được khởi tạo với `CreditCardPayment`, phương thức `executePayment(100.0)` sẽ thực thi logic nào?",
    options: [
      "Logic của PayPalPayment.",
      "Logic của CreditCardPayment.",
      "Logic của GooglePayPayment.",
      "Lỗi biên dịch.",
    ],
    answer: 1,
    explanation:
      "Nó thực thi logic của Strategy được truyền vào constructor, trong trường hợp này là CreditCardPayment [10].",
  },
  {
    id: 2632,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern được mô tả là cho phép thuật toán thay đổi độc lập với cái gì?",
    options: [
      "Lớp kế thừa.",
      "Ngữ cảnh sử dụng nó.",
      "Interface chung.",
      "Phương thức `main()`.",
    ],
    answer: 1,
    explanation:
      "Strategy Pattern cho phép thuật toán thay đổi độc lập với ngữ cảnh (context) sử dụng nó [31].",
  },
  {
    id: 2633,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Việc sử dụng Strategy Pattern để thay thế các khối `if-else` lớn là một ứng dụng phổ biến. Điều này hỗ trợ nguyên tắc SOLID nào?",
    options: [
      "Single Responsibility Principle (SRP).",
      "Open/Closed Principle (OCP).",
      "Liskov Substitution Principle (LSP).",
      "Interface Segregation Principle (ISP).",
    ],
    answer: 1,
    explanation:
      "Thay thế logic điều kiện bằng các class Strategy riêng biệt giúp class Context 'đóng để sửa đổi' nhưng 'mở để mở rộng' (thêm Strategy mới) [39].",
  },
  {
    id: 2634,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Context cần truyền dữ liệu cho Strategy, dữ liệu đó thường được truyền như thế nào?",
    options: [
      "Thông qua constructor của Context.",
      "Thông qua phương thức `executePayment(data)`.",
      "Thông qua biến static.",
      "Thông qua Singleton.",
    ],
    answer: 1,
    explanation:
      "Dữ liệu được truyền qua phương thức thực thi của Context, sau đó Context truyền nó cho Strategy, ví dụ `executePayment(double amount)` [38].",
  },
  {
    id: 2635,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Context class cần phải duy trì tham chiếu đến Strategy class dưới dạng nào?",
    options: [
      "Concrete Strategy (ví dụ: `CreditCardPayment`).",
      "Strategy Interface (ví dụ: `PaymentStrategy`).",
      "Kiểu `Object`.",
      "Kiểu `String`.",
    ],
    answer: 1,
    explanation:
      "Context class duy trì tham chiếu đến Strategy object (ví dụ: `PaymentStrategy p`) [38].",
  },
  {
    id: 2636,
    topic: "Design Patterns",
    type: "radio",
    question: "Điều gì là ĐÚNG về Context class trong Strategy Pattern?",
    options: [
      "Nó biết cách Strategy hoạt động bên trong.",
      "Nó không biết cách Strategy hoạt động, chỉ biết cách sử dụng interface của nó.",
      "Nó phải là một class trừu tượng.",
      "Nó phải là một Singleton.",
    ],
    answer: 1,
    explanation:
      "Context dựa vào Strategy Interface, tách biệt khỏi chi tiết triển khai cụ thể của Strategy (Context chỉ gọi `p.pay(amount)`) [31, 38].",
  },
  {
    id: 2637,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Strategy Pattern được sử dụng, thì class nào sẽ phải thay đổi nếu một thuật toán mới được thêm vào?",
    options: [
      "Context Class.",
      "Strategy Interface.",
      "Chỉ class `Concrete Strategy` mới.",
      "Tất cả các class đều phải thay đổi.",
    ],
    answer: 2,
    explanation:
      "Chỉ cần thêm class `Concrete Strategy` mới (hỗ trợ OCP) [31, 39].",
  },
  {
    id: 2638,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern được sử dụng khi các class khác nhau chỉ khác nhau về:",
    options: [
      "Các trường dữ liệu (fields).",
      "Thứ tự kế thừa.",
      "Hành vi (behavior).",
      "Access modifiers.",
    ],
    answer: 2,
    explanation:
      "Nó được sử dụng khi nhiều class chỉ khác nhau ở hành vi của chúng [34].",
  },
  {
    id: 2639,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Lớp `PaymentContext` trong ví dụ minh họa Strategy Pattern là gì?",
    options: [
      "Strategy Interface.",
      "Concrete Strategy.",
      "Context Class.",
      "Behavioral Factory.",
    ],
    answer: 2,
    explanation: "Nó đóng vai trò là Context Class [38].",
  },
  {
    id: 2640,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu thiết kế nào sau đây định nghĩa 'một họ các thuật toán'?",
    options: ["Abstract Factory", "Singleton", "Strategy", "Adapter"],
    answer: 2,
    explanation:
      "Strategy Design Pattern định nghĩa một họ các thuật toán [31].",
  },
  {
    id: 2641,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Pattern giúp làm cho Context Class:",
    options: [
      "Phụ thuộc chặt chẽ vào các triển khai cụ thể.",
      "Linh hoạt hơn trong việc thay đổi logic nghiệp vụ.",
      "Mở để sửa đổi.",
      "Có nhiều trách nhiệm hơn.",
    ],
    answer: 1,
    explanation:
      "Strategy cho phép thay đổi thuật toán độc lập với Context [31].",
  },
  {
    id: 2642,
    topic: "Design Patterns",
    type: "radio",
    question: "Nếu Context không có tham chiếu đến Strategy, nó sẽ làm gì?",
    options: [
      "Nó sẽ tự động tạo một Strategy mới.",
      "Nó không thể thực thi thuật toán đã chọn.",
      "Nó sẽ sử dụng thuật toán mặc định.",
      "Nó sẽ trở thành Singleton.",
    ],
    answer: 1,
    explanation:
      "Context duy trì tham chiếu đến Strategy để sử dụng nó để thực thi thuật toán [34].",
  },
  {
    id: 2643,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào sau đây khuyến khích sử dụng composition (kết hợp) thay vì inheritance (kế thừa) để thay đổi hành vi?",
    options: ["Singleton", "Factory Method", "Strategy", "Adapter"],
    answer: 2,
    explanation:
      "Strategy sử dụng Context chứa Strategy (composition) để thay đổi hành vi động.",
  },
  {
    id: 2644,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Điều gì là ĐÚNG về Context class khi nó sử dụng Strategy Pattern?",
    options: [
      "Nó phải tự nó triển khai một thuật toán.",
      "Nó được ủy thác trách nhiệm thực thi thuật toán cho đối tượng Strategy.",
      "Nó phải là abstract class.",
      "Nó phải là interface.",
    ],
    answer: 1,
    explanation:
      "Context sử dụng đối tượng Strategy để thực thi thuật toán (`p.pay(amount)`) [38].",
  },
  {
    id: 2645,
    topic: "Design Patterns",
    type: "radio",
    question: "Mẫu Strategy hỗ trợ việc tạo ra các class nào?",
    options: [
      "Các class lớn, đa năng.",
      "Các class nhỏ, tập trung vào một thuật toán cụ thể.",
      "Các class chỉ có fields (trường dữ liệu).",
      "Các class có constructor private.",
    ],
    answer: 1,
    explanation:
      "Mỗi thuật toán được đóng gói trong một class riêng biệt, khuyến khích class nhỏ và tập trung (Concrete Strategy) [31].",
  },
  {
    id: 2646,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, Strategy Interface đảm bảo điều gì cho Context?",
    options: [
      "Context biết cách khởi tạo Strategy.",
      "Context có thể thay đổi Strategy mà nó sử dụng.",
      "Context có thể truy cập các trường private của Strategy.",
      "Context có thể tự định nghĩa thuật toán.",
    ],
    answer: 1,
    explanation:
      "Strategy Interface cung cấp một hợp đồng chung, cho phép Context sử dụng các Strategy khác nhau [31].",
  },
  {
    id: 2647,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern giúp làm cho mã nguồn trở nên linh hoạt hơn bằng cách:",
    options: [
      "Giảm thiểu sự cần thiết của các interface.",
      "Tách rời các thuật toán khỏi client (Context).",
      "Bắt buộc sử dụng các phương thức static.",
      "Cần viết lại toàn bộ Context khi thay đổi thuật toán.",
    ],
    answer: 1,
    explanation:
      "Strategy Pattern tách thuật toán khỏi Context sử dụng nó [31].",
  },
  {
    id: 2648,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu cần thay đổi hành vi của một đối tượng mà không sửa đổi class của nó, nên sử dụng mẫu nào?",
    options: ["Singleton", "Factory Method", "Strategy", "Adapter"],
    answer: 2,
    explanation:
      "Strategy cho phép thay đổi thuật toán (hành vi) độc lập với context [31].",
  },
  {
    id: 2649,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern tập trung chủ yếu vào khía cạnh nào của thiết kế hướng đối tượng?",
    options: [
      "Khởi tạo đối tượng (Object Instantiation).",
      "Cấu trúc đối tượng (Object Structure).",
      "Hành vi và sự thay đổi của thuật toán (Behavior and Algorithm variation).",
      "Kế thừa (Inheritance).",
    ],
    answer: 2,
    explanation:
      "Strategy thuộc Behavioral patterns, tập trung vào việc định nghĩa và hoán đổi các thuật toán/hành vi [31].",
  },

  // --- CHỦ ĐỀ: SOLID PRINCIPLES (Q2650-Q2699) ---
  {
    id: 2650,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "SOLID là từ viết tắt của một tập hợp các hướng dẫn thiết kế nhằm mục đích gì trong lập trình hướng đối tượng?",
    options: [
      "Làm cho mã nguồn phức tạp hơn.",
      "Làm cho thiết kế phần mềm dễ hiểu, linh hoạt và dễ bảo trì hơn.",
      "Bắt buộc sử dụng Design Patterns.",
      "Hạn chế việc sử dụng đa hình.",
    ],
    answer: 1,
    explanation:
      "Các nguyên tắc SOLID là một tập hợp các hướng dẫn thiết kế nhằm làm cho thiết kế phần mềm dễ hiểu, linh hoạt và dễ bảo trì hơn [40].",
  },
  {
    id: 2651,
    topic: "SOLID Principles",
    type: "radio",
    question: "Chữ 'S' trong SOLID là viết tắt của nguyên tắc nào?",
    options: [
      "Strategy Principle.",
      "Singleton Principle.",
      "Single Responsibility Principle (SRP).",
      "Substitution Principle.",
    ],
    answer: 2,
    explanation: "S là Single Responsibility Principle (SRP) [40].",
  },
  {
    id: 2652,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc Trách nhiệm duy nhất (SRP) nói rằng một class nên có bao nhiêu lý do để thay đổi?",
    options: [
      "Không giới hạn.",
      "Hai lý do: logic nghiệp vụ và dữ liệu.",
      "Chỉ một lý do, có nghĩa là chỉ một trách nhiệm hoặc công việc.",
      "Ít nhất ba lý do.",
    ],
    answer: 2,
    explanation:
      "Single Responsibility Principle (SRP): Một class chỉ nên có một lý do để thay đổi, nghĩa là nó chỉ nên có một trách nhiệm hoặc công việc [40].",
  },
  {
    id: 2653,
    topic: "SOLID Principles",
    type: "radio",
    question: "Chữ 'O' trong SOLID là viết tắt của nguyên tắc nào?",
    options: [
      "Object-Oriented Principle.",
      "Open/Closed Principle (OCP).",
      "Overriding Principle.",
      "Optimization Principle.",
    ],
    answer: 1,
    explanation: "O là Open/Closed Principle (OCP) [39].",
  },
  {
    id: 2654,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Open/Closed Principle (OCP) nói rằng các thực thể phần mềm nên mở cho cái gì, nhưng đóng cho cái gì?",
    options: [
      "Mở cho sửa đổi, đóng cho kế thừa.",
      "Mở cho mở rộng, đóng cho sửa đổi.",
      "Mở cho client, đóng cho server.",
      "Mở cho unit testing, đóng cho integration testing.",
    ],
    answer: 1,
    explanation:
      "Open/Closed Principle (OCP): Các thực thể phần mềm nên mở để mở rộng nhưng đóng để sửa đổi [39, 41].",
  },
  {
    id: 2655,
    topic: "SOLID Principles",
    type: "radio",
    question: "Chữ 'L' trong SOLID là viết tắt của nguyên tắc nào?",
    options: [
      "Liskov Substitution Principle (LSP).",
      "Low Coupling Principle.",
      "Lazy Initialization Principle.",
      "Local Variable Principle.",
    ],
    answer: 0,
    explanation: "L là Liskov Substitution Principle (LSP) [39].",
  },
  {
    id: 2656,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Liskov Substitution Principle (LSP) nói về mối quan hệ giữa đối tượng lớp cha và lớp con như thế nào?",
    options: [
      "Đối tượng lớp con phải thay đổi hành vi của lớp cha.",
      "Đối tượng lớp cha chỉ có thể được thay thế bằng đối tượng lớp con nếu chúng là final.",
      "Đối tượng lớp cha phải được thay thế bằng đối tượng lớp con mà không ảnh hưởng đến tính đúng đắn của chương trình.",
      "LSP chỉ áp dụng cho Abstract classes.",
    ],
    answer: 2,
    explanation:
      "Liskov Substitution Principle (LSP): Các đối tượng của một superclass nên có thể thay thế bằng các đối tượng của một subclass mà không ảnh hưởng đến tính đúng đắn của chương trình [39].",
  },
  {
    id: 2657,
    topic: "SOLID Principles",
    type: "radio",
    question: "Chữ 'I' trong SOLID là viết tắt của nguyên tắc nào?",
    options: [
      "Interface Inheritance Principle.",
      "Information Hiding Principle.",
      "Interface Segregation Principle (ISP).",
      "Iterator Principle.",
    ],
    answer: 2,
    explanation: "I là Interface Segregation Principle (ISP) [39].",
  },
  {
    id: 2658,
    topic: "SOLID Principles",
    type: "radio",
    question: "Interface Segregation Principle (ISP) khuyến khích điều gì?",
    options: [
      "Sử dụng các interface lớn, đa năng.",
      "Sử dụng các interface nhỏ hơn, cụ thể hơn, để client không phụ thuộc vào các interface mà họ không sử dụng.",
      "Buộc các client phải triển khai tất cả các phương thức trong interface.",
      "Tạo ra các đối tượng singleton cho mỗi interface.",
    ],
    answer: 1,
    explanation:
      "Interface Segregation Principle (ISP): Client không nên bị buộc phải phụ thuộc vào các interface mà họ không sử dụng. Điều này khuyến khích các interface nhỏ hơn, cụ thể hơn [39].",
  },
  {
    id: 2659,
    topic: "SOLID Principles",
    type: "radio",
    question: "Chữ 'D' trong SOLID là viết tắt của nguyên tắc nào?",
    options: [
      "Design Patterns Principle.",
      "Data Hiding Principle.",
      "Dependency Inversion Principle (DIP).",
      "Dynamic Binding Principle.",
    ],
    answer: 2,
    explanation: "D là Dependency Inversion Principle (DIP) [42].",
  },
  {
    id: 2660,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Dependency Inversion Principle (DIP) nói rằng modules cấp cao (High-level modules) và modules cấp thấp (Low-level modules) nên phụ thuộc vào cái gì?",
    options: [
      "Các class cụ thể.",
      "Các interface hoặc abstraction (tính trừu tượng).",
      "Các lớp con.",
      "Các phương thức static.",
    ],
    answer: 1,
    explanation:
      "Dependency Inversion Principle (DIP): Modules cấp cao không nên phụ thuộc vào modules cấp thấp. Cả hai nên phụ thuộc vào các abstraction [42].",
  },
  {
    id: 2661,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào bị vi phạm nếu một class `ReportGenerator` xử lý cả việc tính toán dữ liệu VÀ định dạng báo cáo?",
    options: ["OCP", "SRP", "LSP", "DIP"],
    answer: 1,
    explanation:
      "Vi phạm SRP vì class có hai lý do để thay đổi (logic tính toán hoặc logic định dạng) [40].",
  },
  {
    id: 2662,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào được hỗ trợ bởi Strategy Pattern, khi cho phép thêm Strategy mới mà không thay đổi Context Class?",
    options: ["SRP", "OCP", "ISP", "LSP"],
    answer: 1,
    explanation:
      "Strategy Pattern cho phép mở rộng (thêm Strategy mới) mà không sửa đổi Context, tuân thủ OCP [39].",
  },
  {
    id: 2663,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu class `Square` kế thừa từ `Rectangle` và một số hoạt động bị lỗi khi thay thế `Rectangle` bằng `Square`, thì nguyên tắc nào bị vi phạm?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 2,
    explanation:
      "Vi phạm LSP, vì đối tượng lớp con (Square) không thể thay thế đối tượng lớp cha (Rectangle) mà không làm hỏng tính đúng đắn của chương trình [39].",
  },
  {
    id: 2664,
    topic: "SOLID Principles",
    type: "radio",
    question: "Để tuân thủ DIP, các module cấp cao nên phụ thuộc vào cái gì?",
    options: [
      "Các class Factory.",
      "Các Abstract classes và Interfaces.",
      "Các module cấp thấp.",
      "Các phương thức có constructor private.",
    ],
    answer: 1,
    explanation:
      "DIP yêu cầu các module cấp cao phụ thuộc vào abstractions [42].",
  },
  {
    id: 2665,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào ủng hộ việc tách một interface lớn thành nhiều interface nhỏ hơn, tập trung hơn?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 3,
    explanation: "ISP khuyến khích các interface nhỏ hơn, cụ thể hơn [39].",
  },
  {
    id: 2666,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Một class có nhiều phương thức `private helper` để quản lý cùng một trách nhiệm (ví dụ: `DataProcessor` có 5 helper methods chỉ để xử lý dữ liệu). Điều này có vi phạm SRP không?",
    options: [
      "Có, vì có quá nhiều phương thức.",
      "Không, miễn là tất cả các phương thức đó phục vụ MỘT trách nhiệm tổng thể.",
      "Có, vì nên sử dụng Decorator.",
      "Không, chỉ vi phạm nếu chúng là `public`.",
    ],
    answer: 1,
    explanation:
      "SRP đề cập đến trách nhiệm (job) của class. Miễn là các phương thức helper phục vụ cùng một trách nhiệm, SRP vẫn được tuân thủ [40].",
  },
  {
    id: 2667,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Việc sử dụng Abstract Factory Pattern (tạo ra các đối tượng thông qua Factory Interface) hỗ trợ nguyên tắc nào của SOLID?",
    options: ["SRP", "OCP và DIP", "LSP", "ISP"],
    answer: 1,
    explanation:
      "Abstract Factory cho phép mở rộng (OCP) và phụ thuộc vào interface (DIP) [26, 39, 42].",
  },
  {
    id: 2668,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Để tuân thủ OCP, khi một tính năng mới được yêu cầu, thay vì sửa đổi code hiện có, bạn nên làm gì?",
    options: [
      "Sử dụng Singleton.",
      "Thêm code mới thông qua kế thừa hoặc composition (ví dụ: Decorator hoặc Strategy).",
      "Xóa các class cũ.",
      "Sử dụng Reflection.",
    ],
    answer: 1,
    explanation:
      "OCP: mở để mở rộng, đóng để sửa đổi. Việc thêm code mới (mở rộng) là cách tuân thủ [39].",
  },
  {
    id: 2669,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào khẳng định tầm quan trọng của tính đa hình (polymorphism) trong việc duy trì tính đúng đắn khi thay thế các đối tượng?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 2,
    explanation:
      "LSP liên quan trực tiếp đến việc các đối tượng của lớp cha có thể thay thế bằng lớp con (substitutability) [39].",
  },
  {
    id: 2670,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "DIP giúp giảm thiểu sự phụ thuộc trực tiếp vào các class cụ thể, điều này giúp cải thiện điều gì?",
    options: [
      "Tính gắn kết (coupling) giữa các module.",
      "Tính lỏng lẻo (loose coupling) và khả năng kiểm thử.",
      "Tính duy nhất của instance.",
      "Tính đa kế thừa.",
    ],
    answer: 1,
    explanation: "Phụ thuộc vào abstraction giúp giảm coupling [42].",
  },
  {
    id: 2671,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu một class `CustomerPersistence` phải triển khai cả phương thức `saveToDatabase()` và `printToConsole()`, nó vi phạm nguyên tắc nào?",
    options: ["SRP", "LSP", "ISP", "DIP"],
    answer: 0,
    explanation:
      "`CustomerPersistence` có nhiều hơn một trách nhiệm (Persistence và Reporting/Logging) [40].",
  },
  {
    id: 2672,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Việc sử dụng Dependency Injection (ngoài phạm vi các nguồn cụ thể) là một kỹ thuật phổ biến để tuân thủ nguyên tắc nào?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 3,
    explanation:
      "DIP tập trung vào việc phụ thuộc vào abstraction, thường được thực hiện thông qua Dependency Injection [42].",
  },
  {
    id: 2673,
    topic: "SOLID Principles",
    type: "radio",
    question: "Nguyên tắc SRP nói rằng class nên tập trung vào việc gì?",
    options: [
      "Giao tiếp với các class khác.",
      "Thực hiện tất cả các hành động liên quan.",
      "Thực hiện một trách nhiệm duy nhất.",
      "Định nghĩa các interface trừu tượng.",
    ],
    answer: 2,
    explanation: "SRP: chỉ một trách nhiệm hoặc công việc [40].",
  },
  {
    id: 2674,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu một interface `IWorker` có các phương thức `feed()`, `work()`, và `sleep()`, nhưng một class `Robot` triển khai `IWorker` không sử dụng `feed()` và `sleep()`, thì nguyên tắc nào bị vi phạm?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 3,
    explanation:
      "Robot bị buộc phụ thuộc vào các phương thức (interface) mà nó không sử dụng [39].",
  },
  {
    id: 2675,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào sau đây đảm bảo rằng nếu một chương trình chạy đúng với kiểu dữ liệu `Base`, thì nó cũng phải chạy đúng khi thay thế bằng kiểu dữ liệu `Derived`?",
    options: ["OCP", "LSP", "ISP", "DIP"],
    answer: 1,
    explanation:
      "LSP: thay thế đối tượng lớp cha bằng lớp con mà không ảnh hưởng đến tính đúng đắn [39].",
  },
  {
    id: 2676,
    topic: "SOLID Principles",
    type: "radio",
    question:
      'Trong DIP, "abstraction" (tính trừu tượng) thường là gì trong Java?',
    options: [
      "Constructor private.",
      "Lớp con.",
      "Interface hoặc Abstract Class.",
      "Phương thức `main()`.",
    ],
    answer: 2,
    explanation:
      "DIP yêu cầu phụ thuộc vào abstraction, thường là Interface hoặc Abstract Class [42].",
  },
  {
    id: 2677,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Việc một class chỉ có một trách nhiệm duy nhất (SRP) dẫn đến lợi ích nào?",
    options: [
      "Class đó có constructor public.",
      "Class có thể thay đổi vì nhiều lý do.",
      "Class đó có tính gắn kết (cohesion) cao hơn.",
      "Class đó phải là Singleton.",
    ],
    answer: 2,
    explanation:
      "Một trách nhiệm duy nhất làm cho class gắn kết hơn và dễ thay đổi khi cần [40].",
  },
  {
    id: 2678,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào là nền tảng cho việc sử dụng rộng rãi các interface (ví dụ: `PaymentStrategy`) trong Strategy Pattern?",
    options: [
      "LSP và DIP",
      "SRP và OCP",
      "ISP",
      "Tất cả các nguyên tắc SOLID.",
    ],
    answer: 0,
    explanation:
      "Strategy dựa vào LSP (thay thế Strategy) và DIP (phụ thuộc vào Strategy Interface) [39, 42].",
  },
  {
    id: 2679,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc DIP đề cập đến sự phụ thuộc giữa modules cấp cao và modules cấp thấp. modules cấp cao là gì?",
    options: [
      "Các module chứa logic nghiệp vụ cốt lõi.",
      "Các module chứa các tiện ích cấp thấp (ví dụ: I/O files).",
      "Các class chỉ có fields.",
      "Các class Singleton.",
    ],
    answer: 0,
    explanation:
      "Các module cấp cao thường chứa logic nghiệp vụ quan trọng (logic cốt lõi) [42].",
  },
  {
    id: 2680,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu một class có thể được sửa đổi bằng cách thêm một phương thức mới mà không cần thay đổi code hiện có, nó tuân thủ nguyên tắc nào?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 1,
    explanation: "Open for extension, closed for modification (OCP) [39].",
  },
  {
    id: 2681,
    topic: "SOLID Principles",
    type: "radio",
    question: "Nguyên tắc LSP được thiết lập dựa trên khái niệm nào của OOP?",
    options: [
      "Encapsulation (Đóng gói).",
      "Method Overloading (Nạp chồng phương thức).",
      "Polymorphism (Đa hình) và Inheritance (Kế thừa).",
      "Abstract Class.",
    ],
    answer: 2,
    explanation:
      "LSP đặt ra quy tắc cho việc sử dụng kế thừa và đa hình một cách an toàn [39].",
  },
  {
    id: 2682,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Sử dụng DIP có thể làm tăng khả năng tái sử dụng (reusability) mã bằng cách nào?",
    options: [
      "Buộc phải sử dụng các constructor private.",
      "Tách module cấp cao khỏi chi tiết triển khai cụ thể của module cấp thấp.",
      "Ngăn chặn class bị kế thừa.",
      "Thực hiện tất cả các hành động trong một class duy nhất.",
    ],
    answer: 1,
    explanation:
      "DIP tách biệt logic nghiệp vụ khỏi chi tiết cấp thấp, tăng tính linh hoạt và tái sử dụng [42].",
  },
  {
    id: 2683,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào sau đây nói về việc không nên phụ thuộc vào các interface có quá nhiều phương thức không liên quan?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 3,
    explanation:
      "ISP: Client không nên phụ thuộc vào interface mà họ không sử dụng [39].",
  },
  {
    id: 2684,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Theo SRP, nếu một class `Employee` chứa logic tính lương VÀ logic lưu trữ dữ liệu, cần làm gì?",
    options: [
      "Sử dụng Decorator.",
      "Tách logic tính lương và lưu trữ dữ liệu thành các class riêng biệt.",
      "Sử dụng Factory Method.",
      "Biến `Employee` thành Singleton.",
    ],
    answer: 1,
    explanation:
      "Cần tách ra để mỗi class có một trách nhiệm duy nhất, tuân thủ SRP [40].",
  },
  {
    id: 2685,
    topic: "SOLID Principles",
    type: "radio",
    question: "Mục tiêu của OCP là gì?",
    options: [
      "Giảm số lượng class trong hệ thống.",
      "Cho phép hệ thống dễ dàng thích ứng với các yêu cầu mới mà không làm hỏng code cũ.",
      "Buộc tất cả các class phải là `final`.",
      "Bắt buộc sử dụng các thuật toán static.",
    ],
    answer: 1,
    explanation: "OCP giúp hệ thống linh hoạt và dễ bảo trì [39].",
  },
  {
    id: 2686,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "LSP yêu cầu điều gì đối với các hành vi của lớp con so với lớp cha?",
    options: [
      "Lớp con phải thay đổi hoàn toàn hành vi của lớp cha.",
      "Lớp con phải duy trì tính nhất quán hành vi của lớp cha (hợp đồng).",
      "Lớp con chỉ cần kế thừa các trường dữ liệu.",
      "LSP chỉ áp dụng khi sử dụng interface.",
    ],
    answer: 1,
    explanation:
      "LSP đảm bảo tính đúng đắn khi thay thế, ngụ ý rằng hợp đồng hành vi của lớp cha phải được lớp con tôn trọng [39].",
  },
  {
    id: 2687,
    topic: "SOLID Principles",
    type: "radio",
    question: "Nguyên tắc DIP đề xuất sử dụng interface trong Java để làm gì?",
    options: [
      "Để ràng buộc module cấp cao vào module cấp thấp.",
      "Để đảo ngược hướng phụ thuộc (direction of dependency).",
      "Để ngăn chặn việc tạo ra các đối tượng.",
      "Để giảm thiểu sự cần thiết của đa hình.",
    ],
    answer: 1,
    explanation:
      "DIP được gọi là 'Đảo ngược sự phụ thuộc' vì nó đảo ngược sự phụ thuộc từ cụ thể sang trừu tượng [42].",
  },
  {
    id: 2688,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu một class `UserService` phụ thuộc trực tiếp vào class `MySQLDatabase` (thay vì interface `IDatabase`), nó vi phạm nguyên tắc nào?",
    options: ["SRP", "OCP", "ISP", "DIP"],
    answer: 3,
    explanation:
      "DIP: modules cấp cao (UserService) không nên phụ thuộc vào modules cấp thấp (MySQLDatabase). Cả hai nên phụ thuộc vào abstraction [42].",
  },
  {
    id: 2689,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "ISP giúp cải thiện thiết kế bằng cách tạo ra các interface có tính chất gì?",
    options: [
      "Rất chung chung và đa năng.",
      "Có thể tái sử dụng cao và tập trung vào vai trò cụ thể.",
      "Chỉ chứa các trường static và final.",
      "Không có phương thức.",
    ],
    answer: 1,
    explanation:
      "ISP khuyến khích các interface nhỏ hơn, cụ thể hơn, tập trung vào vai trò [39].",
  },
  {
    id: 2690,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Việc sử dụng các interface nhỏ, cụ thể (ISP) giúp các client chỉ cần triển khai những gì họ cần, điều này cũng gián tiếp hỗ trợ nguyên tắc nào?",
    options: [
      "SRP, vì các interface cũng có trách nhiệm duy nhất.",
      "LSP, vì nó đảm bảo tính đúng đắn.",
      "OCP, vì nó ngăn chặn việc sửa đổi.",
      "Không có nguyên tắc nào khác.",
    ],
    answer: 0,
    explanation:
      "Interface nhỏ hơn thường có một trách nhiệm duy nhất, hỗ trợ SRP [39, 40].",
  },
  {
    id: 2691,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu một class `FileManager` xử lý cả việc Đọc/Ghi file VÀ nén dữ liệu, nó vi phạm nguyên tắc nào?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 0,
    explanation:
      "Hai trách nhiệm (I/O và Compression) nên được tách ra theo SRP [40].",
  },
  {
    id: 2692,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Trong LSP, 'tính đúng đắn của chương trình' (correctness of the program) đề cập đến điều gì?",
    options: [
      "Việc chương trình có biên dịch hay không.",
      "Việc chương trình vẫn hoạt động như mong đợi khi sử dụng lớp con thay cho lớp cha.",
      "Việc sử dụng các phương thức static.",
      "Việc khởi tạo Singleton.",
    ],
    answer: 1,
    explanation:
      "LSP đảm bảo chương trình không bị ảnh hưởng khi đối tượng được thay thế [39].",
  },
  {
    id: 2693,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc OCP được thực hiện hiệu quả nhất bằng cách kết hợp với các khái niệm nào?",
    options: [
      "Sử dụng `final` class và `private` constructor.",
      "Sử dụng Factory Method và Singleton.",
      "Sử dụng Abstraction (Interfaces và Abstract Classes).",
      "Sử dụng Method Overloading.",
    ],
    answer: 2,
    explanation:
      "OCP thường được thực hiện thông qua Abstraction và Polymorphism để cho phép mở rộng [39].",
  },
  {
    id: 2694,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "DIP được đặt tên như vậy vì nó làm gì với luồng phụ thuộc (dependency flow) thông thường?",
    options: [
      "Nó làm chậm luồng.",
      "Nó đảo ngược luồng để phụ thuộc vào abstraction.",
      "Nó làm cho luồng chạy theo một chu kỳ.",
      "Nó làm cho luồng chạy thẳng từ cao cấp đến thấp cấp.",
    ],
    answer: 1,
    explanation:
      "DIP là 'Dependency Inversion' vì nó đảo ngược sự phụ thuộc [42].",
  },
  {
    id: 2695,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Để tuân thủ ISP, nếu một interface `ITask` có 10 phương thức, và hầu hết các client chỉ cần 2 phương thức, nên làm gì?",
    options: [
      "Buộc client triển khai tất cả 10.",
      "Tách `ITask` thành 5 interface nhỏ hơn (hoặc nhiều hơn) [39].",
      "Biến `ITask` thành abstract class.",
      "Sử dụng `public static final` cho tất cả các phương thức.",
    ],
    answer: 1,
    explanation: "ISP khuyến khích interface nhỏ hơn, cụ thể hơn [39].",
  },
  {
    id: 2696,
    topic: "SOLID Principles",
    type: "radio",
    question: "Nguyên tắc SRP giúp class dễ thay đổi hơn vì:",
    options: [
      "Nó giới hạn số lượng phương thức.",
      "Khi có thay đổi, class chỉ có một lý do duy nhất để bị tác động.",
      "Nó buộc class phải là abstract.",
      "Nó cho phép sử dụng Factory Method.",
    ],
    answer: 1,
    explanation: "Chỉ một lý do để thay đổi [40].",
  },
  {
    id: 2697,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào đặt ra quy tắc cho việc sử dụng đa hình an toàn và chính xác?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 2,
    explanation: "LSP: Đảm bảo khả năng thay thế của lớp con [39].",
  },
  {
    id: 2698,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "DIP nói rằng 'Both should depend on abstractions' ('Cả hai nên phụ thuộc vào abstractions'). 'Cả hai' ở đây là ai?",
    options: [
      "Client và Server.",
      "Getter và Setter.",
      "High-level modules và Low-level modules.",
      "Class và Object.",
    ],
    answer: 2,
    explanation:
      "High-level modules và Low-level modules đều nên phụ thuộc vào abstractions [42].",
  },
  {
    id: 2699,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào trong SOLID được thiết kế để giải quyết vấn đề về sự cứng nhắc của code (rigidity) khi yêu cầu tính năng mới?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 1,
    explanation:
      "OCP giải quyết vấn đề code bị đóng chặt (closed) khi cần sửa đổi, nhưng vẫn mở (open) để thêm chức năng mới [39].",
  },

  // --- CÂU HỎI HỖN HỢP VÀ TĂNG CƯỜNG (Q2700-Q2749) ---
  {
    id: 2700,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu class `Singleton` không có từ khóa `final`, và constructor là `private`, điều gì xảy ra nếu cố gắng kế thừa nó?",
    options: [
      "Lỗi biên dịch.",
      "Lỗi runtime.",
      "Thành công, nhưng lớp con không có constructor riêng.",
      "Nó vẫn giữ được tính chất Singleton.",
    ],
    answer: 0,
    explanation:
      "Nếu chúng ta cố gắng mở rộng một class có constructor private, một lỗi biên dịch sẽ xảy ra [13].",
  },
  {
    id: 2701,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào sau đây tạo ra một nhóm các đối tượng liên quan (families of related objects)?",
    options: ["Singleton", "Factory Method", "Abstract Factory", "Strategy"],
    answer: 2,
    explanation:
      "Abstract Factory tạo ra families of related or dependent objects [26].",
  },
  {
    id: 2702,
    topic: "Design Patterns",
    type: "radio",
    question: "Strategy Pattern giúp Context class tuân thủ SRP bằng cách nào?",
    options: [
      "Cho phép Context có nhiều lý do để thay đổi.",
      "Đẩy trách nhiệm thực thi các thuật toán ra các class Strategy riêng biệt.",
      "Buộc Context phải là Singleton.",
      "Loại bỏ nhu cầu về interface.",
    ],
    answer: 1,
    explanation:
      "SRP yêu cầu một class chỉ có một trách nhiệm [40]. Strategy Pattern tách trách nhiệm thuật toán ra khỏi Context, giúp Context tập trung vào việc quản lý Strategy [31].",
  },
  {
    id: 2703,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Mô hình thiết kế nào trong số các lựa chọn sau đây giúp tuân thủ OCP một cách rõ ràng nhất?",
    options: [
      "Viết lại toàn bộ hàm `if-else` khi thêm chức năng mới.",
      "Sử dụng Strategy Pattern.",
      "Sử dụng constructor mặc định.",
      "Sử dụng các lớp không trừu tượng.",
    ],
    answer: 1,
    explanation:
      "Strategy Pattern cho phép thêm các Strategy mới (mở rộng) mà không sửa đổi Context (đóng để sửa đổi) [31, 39].",
  },
  {
    id: 2704,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu hai client gọi `Singleton.getInstance()`, điều kiện nào sau đây là ĐÚNG về các tham chiếu `first` và `second`?",
    options: [
      "Chúng luôn có giá trị khác nhau.",
      "Chúng trỏ đến cùng một đối tượng trong Heap.",
      "Chúng có thể được so sánh bằng `equals()` nhưng không phải `==`.",
      "Chỉ một trong số chúng được khởi tạo.",
    ],
    answer: 1,
    explanation:
      "Singleton đảm bảo chỉ có một instance, do đó cả hai tham chiếu trỏ đến cùng một đối tượng [12].",
  },
  {
    id: 2705,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method Pattern được sử dụng khi hệ thống cần làm gì?",
    options: [
      "Đảm bảo an toàn luồng.",
      "Tổ chức cấu trúc phân cấp phức tạp.",
      "Tách biệt client khỏi việc biết class cụ thể cần khởi tạo tại runtime.",
      "Thực hiện việc sao chép đối tượng.",
    ],
    answer: 2,
    explanation:
      "Factory Method ủy quyền quyết định khởi tạo class cụ thể cho subclasses dựa trên runtime context [21].",
  },
  {
    id: 2706,
    topic: "Design Patterns",
    type: "radio",
    question: "Context Class trong Strategy Pattern chịu trách nhiệm gì?",
    options: [
      "Lựa chọn thuật toán nào sẽ được sử dụng.",
      "Cung cấp interface cho các thuật toán.",
      "Định nghĩa chi tiết thuật toán.",
      "Tạo ra các đối tượng Strategy.",
    ],
    answer: 0,
    explanation:
      "Context Class được truyền vào Strategy (lựa chọn thuật toán) và sử dụng nó [38].",
  },
  {
    id: 2707,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Việc refactor (tái cấu trúc) một class lớn có nhiều trách nhiệm thành các class nhỏ, mỗi class có một trách nhiệm duy nhất, nhằm tuân thủ nguyên tắc nào?",
    options: ["ISP", "DIP", "SRP", "LSP"],
    answer: 2,
    explanation: "SRP: một class chỉ có một trách nhiệm [40].",
  },
  {
    id: 2708,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào cho phép thay thế đối tượng lớp cha bằng lớp con mà không ảnh hưởng đến tính đúng đắn của chương trình?",
    options: [
      "Singleton",
      "Factory Method",
      "Strategy",
      "Liskov Substitution Principle (LSP)",
    ],
    answer: 3,
    explanation: "LSP là nguyên tắc đảm bảo điều này [39].",
  },
  {
    id: 2709,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern dựa trên Object Composition có nghĩa là gì?",
    options: [
      "Nó không cần interface.",
      "Nó sử dụng các thành phần (objects) để đạt được mục tiêu.",
      "Nó chỉ sử dụng inheritance.",
      "Nó chỉ hoạt động với các kiểu nguyên thủy.",
    ],
    answer: 1,
    explanation:
      "Abstract Factory dựa trên composition (kết hợp đối tượng) [25].",
  },
  {
    id: 2710,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một hệ thống cần hỗ trợ nhiều loại nén (ZIP, RAR, GZIP) và cần chọn loại nén lúc runtime, mẫu nào nên được áp dụng?",
    options: ["Singleton", "Decorator", "Strategy", "Adapter"],
    answer: 2,
    explanation:
      "Strategy Pattern được sử dụng để chọn hành vi/thuật toán (nén) linh hoạt tại runtime [34].",
  },
  {
    id: 2711,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào giúp client không phải phụ thuộc vào các phương thức của interface mà họ không sử dụng?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 3,
    explanation:
      "ISP: Client không nên bị buộc phải phụ thuộc vào các interface họ không sử dụng [39].",
  },
  {
    id: 2712,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu thiết kế nào được sử dụng để quản lý tài nguyên hệ thống (ví dụ: kết nối cơ sở dữ liệu) một cách tập trung và duy nhất?",
    options: ["Prototype", "Composite", "Singleton", "Strategy"],
    answer: 2,
    explanation:
      "Singleton được dùng để đảm bảo chỉ có một instance (ví dụ: quản lý kết nối DB) [9].",
  },
  {
    id: 2713,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method khác với Abstract Factory ở chỗ nó tập trung vào việc tạo ra:",
    options: [
      "Một sản phẩm cụ thể duy nhất.",
      "Nhiều sản phẩm liên quan.",
      "Các thuật toán độc lập.",
      "Một instance có thể sao chép.",
    ],
    answer: 0,
    explanation: "Factory Method tập trung vào tạo một sản phẩm cụ thể [25].",
  },
  {
    id: 2714,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, Context Class gọi phương thức của Strategy thông qua tham chiếu đến cái gì?",
    options: [
      "Concrete Strategy",
      "Strategy Interface",
      "Factory Method",
      "Lớp `Object`",
    ],
    answer: 1,
    explanation:
      "Context duy trì tham chiếu đến Strategy object (interface) [31, 38].",
  },
  {
    id: 2715,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "DIP nói rằng các module cấp cao không nên phụ thuộc vào các module cấp thấp, nhưng cả hai nên phụ thuộc vào:",
    options: ["Inheritance", "Abstraction", "Singleton", "Concrete Classes"],
    answer: 1,
    explanation: "Cả hai nên phụ thuộc vào abstractions [42].",
  },
  {
    id: 2716,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào trong nhóm Creational Pattern tập trung vào việc cung cấp giao diện để tạo đối tượng mà không hardcoding class cụ thể?",
    options: ["Singleton", "Factory Method", "Adapter", "Strategy"],
    answer: 1,
    explanation:
      "Factory Method cung cấp interface để tạo đối tượng và ủy quyền cho lớp con [13].",
  },
  {
    id: 2717,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Singleton Pattern được triển khai, điều gì là bắt buộc để ngăn việc tạo instance bằng `new`?",
    options: [
      "Phương thức `getInstance()` phải là final.",
      "Class phải là `abstract`.",
      "Constructor phải là `private`.",
      "Tất cả các trường phải là `static`.",
    ],
    answer: 2,
    explanation:
      "Constructor private ngăn việc tạo đối tượng bên ngoài class [12].",
  },
  {
    id: 2718,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern được mô tả là sử dụng Object Composition. Điều này tương phản với Factory Method sử dụng gì?",
    options: ["Encapsulation", "Subclassing", "Polymorphism", "Adapter"],
    answer: 1,
    explanation:
      "Abstract Factory dựa trên Composition, Factory Method dựa trên Subclassing [25].",
  },
  {
    id: 2719,
    topic: "Design Patterns",
    type: "radio",
    question: "Khi nào nên sử dụng Strategy Pattern?",
    options: [
      "Khi cần một instance duy nhất.",
      "Khi có nhiều class chỉ khác nhau về hành vi (thuật toán).",
      "Khi cần gói gọn dữ liệu.",
      "Khi cần sử dụng Decorator.",
    ],
    answer: 1,
    explanation:
      "Strategy Pattern được sử dụng khi nhiều class chỉ khác nhau ở hành vi của chúng [34].",
  },
  {
    id: 2720,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nếu việc thay thế một đối tượng `Rectangle` bằng đối tượng `Square` dẫn đến lỗi logic trong chương trình, đó là lỗi vi phạm nguyên tắc nào?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 2,
    explanation:
      "LSP: đối tượng lớp cha phải được thay thế bằng lớp con mà không ảnh hưởng đến tính đúng đắn [39].",
  },
  {
    id: 2721,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong triển khai Singleton, việc sử dụng từ khóa `static` cho instance đảm bảo rằng instance được chia sẻ bởi cái gì?",
    options: [
      "Tất cả các class trong package.",
      "Tất cả các đối tượng của class đó.",
      "Chỉ class con.",
      "Chỉ phương thức `main()`.",
    ],
    answer: 1,
    explanation:
      "Các trường static thuộc về class và chia sẻ bởi tất cả các đối tượng [19, 43].",
  },
  {
    id: 2722,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào là thích hợp khi bạn có một class trừu tượng cần được khởi tạo thành một trong nhiều lớp con cụ thể dựa trên input runtime?",
    options: ["Singleton", "Factory Method", "Adapter", "Strategy"],
    answer: 1,
    explanation:
      "Factory Method ủy quyền việc khởi tạo cho lớp con, dựa trên ngữ cảnh/input [21].",
  },
  {
    id: 2723,
    topic: "Design Patterns",
    type: "radio",
    question: "Trong Strategy Pattern, `Concrete Strategies` đóng vai trò gì?",
    options: [
      "Triển khai các interface.",
      "Triển khai các thuật toán cụ thể.",
      "Thực hiện việc kết hợp đối tượng.",
      "Làm cầu nối giữa các interface.",
    ],
    answer: 1,
    explanation:
      "Concrete strategies triển khai các thuật toán khác nhau [31].",
  },
  {
    id: 2724,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào trong SOLID được thiết lập để làm cho code linh hoạt hơn và dễ dàng thích ứng với sự thay đổi yêu cầu?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 1,
    explanation:
      "OCP: mở để mở rộng, đóng để sửa đổi, tăng tính linh hoạt [39].",
  },
  {
    id: 2725,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Điều gì là tác dụng của `private constructor` trong Singleton ngoài việc ngăn chặn khởi tạo bên ngoài?",
    options: [
      "Nó ngăn chặn class khỏi bị kế thừa.",
      "Nó làm cho class trở thành abstract.",
      "Nó yêu cầu tất cả các phương thức phải là static.",
      "Nó buộc phải sử dụng Lazy initialization.",
    ],
    answer: 0,
    explanation:
      "Private Constructor ngăn class khỏi bị kế thừa (subclassed) [12].",
  },
  {
    id: 2726,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory tạo ra các nhóm đối tượng liên quan (families) mà không cần chỉ định class cụ thể. Điều này giúp hệ thống duy trì được tính chất gì?",
    options: ["Hardcoding", "Coupling", "Decoupling", "Immutability"],
    answer: 2,
    explanation:
      "Hệ thống cần duy trì tính tách biệt (decoupled) khỏi các triển khai cụ thể [26].",
  },
  {
    id: 2727,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Strategy Pattern được sử dụng, Context Class phụ thuộc vào cái gì để gọi thuật toán?",
    options: [
      "Strategy Interface.",
      "Concrete Strategy.",
      "Abstract Factory.",
      "Lớp con của Context.",
    ],
    answer: 0,
    explanation:
      "Context duy trì tham chiếu đến Strategy object và sử dụng nó (interface) [34].",
  },
  {
    id: 2728,
    topic: "SOLID Principles",
    type: "radio",
    question: "DIP nói rằng sự phụ thuộc nên đi theo hướng nào?",
    options: [
      "Từ Abstraction đến Concrete.",
      "Từ Concrete đến Abstraction (đảo ngược).",
      "Chỉ từ Modules cấp cao đến Modules cấp thấp.",
      "Chỉ từ Modules cấp thấp đến Modules cấp cao.",
    ],
    answer: 1,
    explanation: "DIP: modules nên phụ thuộc vào abstractions [42].",
  },
  {
    id: 2729,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Để đảm bảo rằng không ai có thể tạo thêm instance của `Singleton` class, điều gì được ngăn chặn?",
    options: [
      "Method Overriding.",
      "Calling static methods.",
      "Calling the private constructor (bên ngoài class).",
      "Garbage collection.",
    ],
    answer: 2,
    explanation:
      "Private constructor ngăn việc tạo đối tượng bên ngoài class [12].",
  },
  {
    id: 2730,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Khi nào nên ưu tiên Factory Method hơn là trực tiếp gọi constructor?",
    options: [
      "Khi cần một instance duy nhất.",
      "Khi cần ẩn logic khởi tạo và cho phép subclass quyết định loại object.",
      "Khi cần thêm chức năng động.",
      "Khi cần tổ chức dữ liệu dạng cây.",
    ],
    answer: 1,
    explanation: "Factory Method ủy quyền việc khởi tạo cho lớp con [13, 21].",
  },
  {
    id: 2731,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Thành phần nào trong Strategy Pattern là nơi client tương tác để thay đổi và thực thi thuật toán?",
    options: [
      "Concrete Strategy",
      "Strategy Interface",
      "Context Class",
      "Factory",
    ],
    answer: 2,
    explanation:
      "Client tương tác với Context để thiết lập và thực thi Strategy [10, 38].",
  },
  {
    id: 2732,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Việc sử dụng các tham số kiểu trừu tượng trong Factory Method (ví dụ: trả về `Vehicle` thay vì `Car`) hỗ trợ nguyên tắc nào?",
    options: ["OCP và LSP.", "SRP và ISP.", "DIP và SRP.", "Singleton."],
    answer: 0,
    explanation:
      "OCP: Mở rộng dễ dàng. LSP: Đối tượng con có thể thay thế lớp cha (`Car` thay thế `Vehicle`) [23, 24, 39].",
  },
  {
    id: 2733,
    topic: "Design Patterns",
    type: "radio",
    question: "Điều gì là ĐÚNG về `getInstance()` trong Singleton?",
    options: [
      "Nó phải được gọi bằng từ khóa `new`.",
      "Nó là phương thức `static` để có thể được gọi mà không cần instance.",
      "Nó trả về một `String`.",
      "Nó phải là `private`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `getInstance()` là static và được gọi trực tiếp từ class [14].",
  },
  {
    id: 2734,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Abstract Factory, interface `VehicleFactory` định nghĩa các phương thức tạo ra cái gì?",
    options: [
      "Chỉ một sản phẩm.",
      "Mỗi sản phẩm trong nhóm liên quan (Car, Truck).",
      "Chỉ các lớp con.",
      "Các thuật toán độc lập.",
    ],
    answer: 1,
    explanation: "`VehicleFactory` có `createCar()` và `createTruck()` [27].",
  },
  {
    id: 2735,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern khuyến khích việc đóng gói các hành vi vào các đối tượng Strategy riêng biệt để làm gì?",
    options: [
      "Giảm tính đa hình.",
      "Tăng tính coupling.",
      "Tăng khả năng tái sử dụng và kiểm thử của từng thuật toán.",
      "Vi phạm SRP.",
    ],
    answer: 2,
    explanation:
      "Đóng gói thuật toán riêng biệt (Concrete Strategies) làm chúng dễ tái sử dụng và thay thế [31].",
  },
  {
    id: 2736,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào sau đây đề cập trực tiếp đến sự phụ thuộc vào abstraction?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 3,
    explanation: "DIP: phụ thuộc vào abstractions [42].",
  },
  {
    id: 2737,
    topic: "Design Patterns",
    type: "radio",
    question: "Một hậu quả của việc sử dụng `private constructor` là gì?",
    options: [
      "Nó cho phép đa kế thừa.",
      "Nó yêu cầu triển khai `Serializable`.",
      "Nó ngăn chặn class khỏi bị subclassed.",
      "Nó buộc class phải là Singleton.",
    ],
    answer: 2,
    explanation: "Constructor private ngăn class khỏi bị subclassed [12].",
  },
  {
    id: 2738,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method được sử dụng khi nào là thích hợp nhất?",
    options: [
      "Khi cần tạo một nhóm các đối tượng liên quan.",
      "Khi muốn tách logic tạo đối tượng ra khỏi logic nghiệp vụ của client.",
      "Khi cần đảm bảo tính duy nhất của đối tượng.",
      "Khi cần thêm chức năng động vào đối tượng.",
    ],
    answer: 1,
    explanation: "Factory Method tách logic tạo đối tượng khỏi client [13].",
  },
  {
    id: 2739,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào sau đây có thể được sử dụng để loại bỏ các khối `switch/case` lớn hoặc `if/else` lồng nhau để chọn hành vi?",
    options: ["Singleton", "Strategy", "Adapter", "Composite"],
    answer: 1,
    explanation:
      "Strategy cho phép chọn hành vi động thay vì logic điều kiện phức tạp [34].",
  },
  {
    id: 2740,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Mục đích của SOLID là làm cho phần mềm trở nên dễ hiểu, linh hoạt và gì?",
    options: [
      "Chặt chẽ (Tightly coupled).",
      "Dễ bảo trì (Maintainable).",
      "Dễ biên dịch (Easy to compile).",
      "Chỉ sử dụng Java.",
    ],
    answer: 1,
    explanation:
      "SOLID giúp thiết kế phần mềm dễ hiểu, linh hoạt và dễ bảo trì [40].",
  },
  {
    id: 2741,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu constructor của Singleton in ra thông báo 'Singleton object created', thông báo này sẽ xuất hiện bao nhiêu lần nếu gọi `getInstance()` hai lần?",
    options: [
      "Hai lần.",
      "Một lần.",
      "Không lần nào.",
      "Nó phụ thuộc vào Garbage Collector.",
    ],
    answer: 1,
    explanation:
      "Constructor chỉ được gọi một lần khi instance được tạo ra [14].",
  },
  {
    id: 2742,
    topic: "Design Patterns",
    type: "radio",
    question: "Factory Method Pattern dựa trên cơ chế nào của OOP?",
    options: [
      "Nạp chồng phương thức (Method Overloading).",
      "Kế thừa và Ghi đè phương thức (Inheritance and Overriding).",
      "Interface Segregation.",
      "Dependency Inversion.",
    ],
    answer: 1,
    explanation:
      "Factory Method dựa trên subclassing (kế thừa) và sử dụng polymorphism (ghi đè factory method) [25].",
  },
  {
    id: 2743,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Context Class có thể thay đổi Strategy (thuật toán) như thế nào?",
    options: [
      "Chỉ một lần khi khởi tạo Context.",
      "Linh hoạt tại bất kỳ thời điểm nào (runtime).",
      "Chỉ khi Context là Singleton.",
      "Chỉ khi Strategy là abstract.",
    ],
    answer: 1,
    explanation: "Strategy cho phép chọn hành vi động tại runtime [34].",
  },
  {
    id: 2744,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào đề cập đến việc modules cấp cao không nên phụ thuộc vào modules cấp thấp?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 3,
    explanation:
      "DIP: High-level modules should not depend on low-level modules [42].",
  },
  {
    id: 2745,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu muốn đảm bảo class không thể được kế thừa, ta sử dụng từ khóa nào?",
    options: ["static", "private", "final", "abstract"],
    answer: 2,
    explanation: "Final class không thể được kế thừa [15].",
  },
  {
    id: 2746,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method Pattern, lớp cha (ví dụ: `VehicleFactory`) thường là một lớp trừu tượng vì nó cần làm gì?",
    options: [
      "Cung cấp implementation mặc định.",
      "Bắt buộc các lớp con phải triển khai phương thức tạo đối tượng.",
      "Ngăn chặn việc tạo đối tượng bằng constructor private.",
      "Tập trung vào giao tiếp.",
    ],
    answer: 1,
    explanation:
      "`VehicleFactory` là abstract class với `abstract Vehicle createVehicle()` [23].",
  },
  {
    id: 2747,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern thường được sử dụng để giải quyết vấn đề về sự đa dạng của cái gì?",
    options: [
      "Các fields (trường dữ liệu).",
      "Các constructor.",
      "Các thuật toán (algorithms).",
      "Các access modifiers.",
    ],
    answer: 2,
    explanation:
      "Strategy định nghĩa một họ các thuật toán có thể hoán đổi [31].",
  },
  {
    id: 2748,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào khuyến khích chia nhỏ interface để tránh tình trạng 'fat interface'?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 3,
    explanation: "ISP khuyến khích các interface nhỏ hơn, cụ thể hơn [39].",
  },
  {
    id: 2749,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào sau đây tạo ra các đối tượng theo nhóm (families) và dựa trên Object Composition?",
    options: ["Factory Method", "Abstract Factory", "Singleton", "Strategy"],
    answer: 1,
    explanation:
      "Abstract Factory tạo nhóm đối tượng liên quan và dựa trên Composition [25].",
  },

  // --- CÂU HỎI TĂNG CƯỜNG CHUYÊN SÂU (Q2750-Q2799) ---
  {
    id: 2750,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu phương thức `getInstance()` trong Singleton không phải là `static`, điều gì sẽ xảy ra?",
    options: [
      "Nó vẫn hoạt động bình thường.",
      "Cần phải tạo ra một instance của class để gọi nó, điều này mâu thuẫn với mục đích của Singleton.",
      "Nó có thể truy cập các trường static.",
      "Nó phải được gọi bằng từ khóa `super`.",
    ],
    answer: 1,
    explanation:
      "Phương thức `getInstance()` phải là static để có thể được gọi mà không cần instance [19, 20].",
  },
  {
    id: 2751,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Abstract Factory, interface `VehicleFactory` là một ví dụ về 'Abstraction' trong DIP không?",
    options: [
      "Có, vì nó định nghĩa một hợp đồng mà client phụ thuộc vào.",
      "Không, vì nó không phải là Abstract Class.",
      "Chỉ khi nó có constructor private.",
      "Chỉ khi nó là Singleton.",
    ],
    answer: 0,
    explanation:
      "Abstraction bao gồm cả Interface và Abstract Class [42]. `VehicleFactory` là một interface, là một hình thức của Abstraction [27].",
  },
  {
    id: 2752,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern giúp Context Class dễ dàng tuân thủ SRP bằng cách nào?",
    options: [
      "Context có thể xử lý nhiều thuật toán.",
      "Context chỉ tập trung vào việc ủy thác thực thi, loại bỏ logic thuật toán.",
      "Context là lớp con của Strategy.",
      "Context là một `final class`.",
    ],
    answer: 1,
    explanation:
      "Context chỉ tập trung vào việc sử dụng Strategy (ủy thác), thay vì chứa đựng logic thuật toán [31, 40].",
  },
  {
    id: 2753,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "LSP tập trung vào việc đảm bảo sự thay thế (substitutability) của cái gì?",
    options: [
      "Các phương thức static.",
      "Các đối tượng lớp con cho lớp cha.",
      "Các trường private.",
      "Các Factory class.",
    ],
    answer: 1,
    explanation:
      "LSP: Objects of a superclass should be replaceable with objects of a subclass [39].",
  },
  {
    id: 2754,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Factory Method cần tạo đối tượng dựa trên giá trị của một biến (ví dụ: `type = 'Car'` hay `type = 'Truck'`), thì quyết định này diễn ra ở đâu?",
    options: [
      "Trong `Concrete Factory`.",
      "Trong `Abstract Factory`.",
      "Trong `Client Code` (sử dụng Factory) hoặc bên trong Factory method (nếu là Simple Factory).",
      "Trong `Singleton`.",
    ],
    answer: 0,
    explanation:
      "Factory Method ủy quyền việc tạo cho Subclass [13]. Trong khi đó, việc quyết định dùng Factory nào thường ở Client Code [29].",
  },
  {
    id: 2755,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern được sử dụng để đóng gói các thuật toán. Việc đóng gói này dẫn đến lợi ích nào?",
    options: [
      "Các thuật toán trở nên không thể truy cập được.",
      "Khả năng dễ dàng thêm các thuật toán mới (mở rộng).",
      "Bắt buộc sử dụng Factory Method.",
      "Vi phạm SRP.",
    ],
    answer: 1,
    explanation:
      "Đóng gói thuật toán hỗ trợ OCP, cho phép mở rộng dễ dàng [31, 39].",
  },
  {
    id: 2756,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào bị vi phạm nếu một interface có các phương thức liên quan đến Cả báo cáo (Reporting) và Lưu trữ (Persistence), và một client chỉ cần Báo cáo?",
    options: [
      "SRP (Single Responsibility Principle).",
      "ISP (Interface Segregation Principle).",
      "DIP (Dependency Inversion Principle).",
      "LSP (Liskov Substitution Principle).",
    ],
    answer: 1,
    explanation:
      "ISP: Client không nên phụ thuộc vào interface họ không dùng [39].",
  },
  {
    id: 2757,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu việc khởi tạo Singleton mất nhiều thời gian, nên sử dụng phương pháp khởi tạo nào?",
    options: [
      "Eager Initialization.",
      "Lazy Initialization (khởi tạo khi được gọi lần đầu).",
      "Factory Method.",
      "Prototype Pattern.",
    ],
    answer: 1,
    explanation:
      "Lazy Initialization được ưu tiên khi chi phí khởi tạo cao (ngoài phạm vi các nguồn cụ thể).",
  },
  {
    id: 2758,
    topic: "Design Patterns",
    type: "radio",
    question: "Trong ví dụ Factory Method, `CarFactory` là một ví dụ về:",
    options: [
      "Abstract Factory.",
      "Concrete Factory.",
      "Concrete Product.",
      "Context Class.",
    ],
    answer: 1,
    explanation:
      "`CarFactory` là một class cụ thể triển khai logic tạo đối tượng [24].",
  },
  {
    id: 2759,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào sau đây cho phép cấu hình hành vi của một đối tượng tại thời điểm khởi tạo (ví dụ: tạo Context với Strategy cụ thể)?",
    options: ["Singleton", "Strategy", "Decorator", "Prototype"],
    answer: 1,
    explanation:
      "Client truyền Strategy vào Context constructor để định cấu hình hành vi [38].",
  },
  {
    id: 2760,
    topic: "SOLID Principles",
    type: "radio",
    question: "Để tuân thủ DIP, modules cấp thấp cần triển khai cái gì?",
    options: [
      "Interface mà modules cấp cao định nghĩa.",
      "Các class Factory.",
      "Constructor private.",
      "Các phương thức static.",
    ],
    answer: 0,
    explanation: "DIP nói rằng cả hai đều phụ thuộc vào abstractions [42].",
  },
  {
    id: 2761,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu `Singleton` class có phương thức `getData()` non-static, cách duy nhất để gọi nó là gì?",
    options: [
      "Sử dụng tên class trực tiếp.",
      "Sử dụng `Singleton.getInstance().getData()`.",
      "Sử dụng từ khóa `super`.",
      "Chỉ gọi bên trong chính class đó.",
    ],
    answer: 1,
    explanation:
      "Phải gọi thông qua instance duy nhất được trả về bởi `getInstance()`.",
  },
  {
    id: 2762,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method giúp quản lý các class con vì nó dựa trên điều gì?",
    options: [
      "Static variables.",
      "Constructor private.",
      "Sự đa hình của các đối tượng được tạo ra.",
      "Object composition.",
    ],
    answer: 2,
    explanation: "Factory Method dựa trên subclassing và polymorphism [25].",
  },
  {
    id: 2763,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, nếu các Concrete Strategies có logic phức tạp, thì Context Class có biết về độ phức tạp này không?",
    options: [
      "Có, vì Context cần quản lý chi tiết.",
      "Không, Context chỉ tương tác thông qua Strategy Interface.",
      "Chỉ khi Context là abstract.",
      "Chỉ khi Context là final.",
    ],
    answer: 1,
    explanation:
      "Context chỉ biết đến interface, ẩn đi chi tiết triển khai phức tạp [31].",
  },
  {
    id: 2764,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào bị vi phạm nếu một class `Base` có hành vi `A` và lớp con `Derived` ghi đè `A` theo cách không mong muốn của client?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 2,
    explanation:
      "LSP: Lớp con làm thay đổi tính đúng đắn/hợp đồng của lớp cha [39].",
  },
  {
    id: 2765,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method Pattern, `abstract class Vehicle` là ví dụ của cái gì?",
    options: [
      "Abstract Factory.",
      "Abstract Product.",
      "Concrete Factory.",
      "Strategy Interface.",
    ],
    answer: 1,
    explanation:
      "`Vehicle` là lớp trừu tượng đại diện cho sản phẩm được tạo [23].",
  },
  {
    id: 2766,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào sau đây định nghĩa một interface chung cho các thuật toán được gọi là Strategy Interface?",
    options: ["Singleton", "Factory Method", "Strategy", "Prototype"],
    answer: 2,
    explanation:
      "Strategy Interface là thành phần cốt lõi của Strategy Pattern [31].",
  },
  {
    id: 2767,
    topic: "SOLID Principles",
    type: "radio",
    question: "ISP giúp code dễ bảo trì hơn vì:",
    options: [
      "Nó loại bỏ tất cả các interface.",
      "Sự thay đổi trong một phần của interface lớn không ảnh hưởng đến các client không liên quan.",
      "Nó buộc phải sử dụng các interface lớn.",
      "Nó chỉ hoạt động với các class `final`.",
    ],
    answer: 1,
    explanation:
      "ISP: khuyến khích interface nhỏ, nếu interface nhỏ thay đổi, ít client bị ảnh hưởng hơn [39].",
  },
  {
    id: 2768,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Singleton được khởi tạo kiểu Lazy Initialization, khi nào instance thực sự được tạo?",
    options: [
      "Khi class được load.",
      "Trong constructor.",
      "Khi `getInstance()` được gọi lần đầu tiên.",
      "Trong phương thức `main()`.",
    ],
    answer: 2,
    explanation:
      "Lazy Initialization tạo instance khi nó thực sự cần thiết (khi `getInstance()` được gọi) (ngược lại với ví dụ Eager) [14].",
  },
  {
    id: 2769,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào cho phép bạn thêm các loại sản phẩm mới bằng cách chỉ cần thêm class sản phẩm và Factory tương ứng, mà không sửa đổi code cũ (tuân thủ OCP)?",
    options: ["Singleton", "Strategy", "Factory Method", "Adapter"],
    answer: 2,
    explanation:
      "Factory Method dựa trên Subclassing để mở rộng tạo đối tượng [13, 39].",
  },
  {
    id: 2770,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Context Class trong Strategy Pattern được định nghĩa với tham chiếu đến Strategy Interface thay vì Concrete Strategy, nhằm tuân thủ nguyên tắc nào?",
    options: ["SRP và LSP.", "OCP và DIP.", "ISP và SRP.", "Singleton."],
    answer: 1,
    explanation:
      "DIP: phụ thuộc vào abstraction (interface). OCP: Context không cần sửa đổi khi thêm Strategy mới [39, 42].",
  },
  {
    id: 2771,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Để tuân thủ DIP, module cấp cao cần biết về cái gì của module cấp thấp?",
    options: [
      "Tên class cụ thể của nó.",
      "Abstract class/Interface chung mà cả hai đều phụ thuộc vào.",
      "Các trường private.",
      "Chi tiết triển khai.",
    ],
    answer: 1,
    explanation:
      "DIP: modules cấp cao không biết chi tiết cấp thấp, chỉ biết về Abstraction [42].",
  },
  {
    id: 2772,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Factory Method Pattern được sử dụng để làm gì trong hệ thống sản xuất (Product System)?",
    options: [
      "Để tạo ra một kết nối duy nhất.",
      "Để cung cấp cơ chế tạo sản phẩm linh hoạt, nơi loại sản phẩm được quyết định bởi nhà máy con.",
      "Để thêm chức năng động vào sản phẩm.",
      "Để sao chép đối tượng.",
    ],
    answer: 1,
    explanation: "Factory Method ủy quyền việc khởi tạo cho lớp con [13, 21].",
  },
  {
    id: 2773,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một ứng dụng tính toán phí vận chuyển (Shipping Fee) dựa trên nhiều yếu tố (khối lượng, khoảng cách, loại khách hàng), mẫu nào là tốt nhất để quản lý các quy tắc tính phí này?",
    options: ["Singleton", "Factory Method", "Strategy", "Composite"],
    answer: 2,
    explanation: "Strategy Pattern để đóng gói từng thuật toán tính phí [31].",
  },
  {
    id: 2774,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào tập trung vào việc làm cho class có tính gắn kết (cohesion) cao hơn?",
    options: ["OCP", "SRP", "ISP", "LSP"],
    answer: 1,
    explanation:
      "SRP giúp class có tính gắn kết cao hơn bằng cách tập trung vào một trách nhiệm duy nhất [40].",
  },
  {
    id: 2775,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu `Singleton` class triển khai Eager Initialization (khởi tạo ngay lập tức), nhược điểm là gì?",
    options: [
      "Không an toàn luồng.",
      "Instance được tạo ngay cả khi nó không bao giờ được sử dụng.",
      "Phương thức `getInstance()` phải là non-static.",
      "Vi phạm SRP.",
    ],
    answer: 1,
    explanation:
      "Eager Initialization tạo instance khi class được load, có thể lãng phí tài nguyên nếu không cần thiết [14].",
  },
  {
    id: 2776,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern được sử dụng để tạo ra các đối tượng có quan hệ gì với nhau?",
    options: [
      "Không liên quan.",
      "Phụ thuộc hoặc liên quan trong cùng một họ.",
      "Luôn là Singleton.",
      "Chỉ là các lớp con.",
    ],
    answer: 1,
    explanation: "Families of related or dependent objects [26].",
  },
  {
    id: 2777,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, nếu không có Strategy Interface, Context Class sẽ phải làm gì?",
    options: [
      "Phụ thuộc vào các Concrete Strategies, vi phạm DIP.",
      "Phụ thuộc vào Factory Method.",
      "Trở thành Singleton.",
      "Tuân thủ ISP.",
    ],
    answer: 0,
    explanation:
      "Không có interface, Context sẽ phải phụ thuộc vào các triển khai cụ thể, vi phạm DIP [31, 42].",
  },
  {
    id: 2778,
    topic: "SOLID Principles",
    type: "radio",
    question: "Nguyên tắc LSP được thiết kế để hỗ trợ khả năng thay thế nào?",
    options: [
      "Thay thế Interface bằng Abstract Class.",
      "Thay thế Implementation bằng Abstraction.",
      "Thay thế Abstract Factory bằng Factory Method.",
      "Thay thế các kiểu cơ sở (base types) bằng các kiểu con (subtypes).",
    ],
    answer: 3,
    explanation:
      "LSP: Objects of a superclass should be replaceable with objects of a subclass [39].",
  },
  {
    id: 2779,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu một class có constructor public, nó có thể là một Singleton hợp lệ không?",
    options: [
      "Có, nếu phương thức `getInstance()` được đồng bộ hóa.",
      "Không, vì constructor public cho phép tạo nhiều instance.",
      "Có, nếu tất cả các trường là static.",
      "Có, nếu nó là abstract.",
    ],
    answer: 1,
    explanation:
      "Constructor public cho phép tạo instance bất cứ lúc nào, vi phạm Singleton [12].",
  },
  {
    id: 2780,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mẫu nào dựa trên Object Composition và cho phép Factory tạo ra nhiều loại sản phẩm (ví dụ: Car và Truck) cho một biến thể (Electric)?",
    options: ["Singleton", "Factory Method", "Abstract Factory", "Strategy"],
    answer: 2,
    explanation:
      "Abstract Factory dựa trên Composition và tạo ra families of related objects [25].",
  },
  {
    id: 2781,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Context Class có thể thay đổi Strategy tại runtime. Điều này minh họa cho tính linh hoạt của Strategy Pattern trong việc quản lý cái gì?",
    options: [
      "Data structure.",
      "Dynamic behavior selection (Lựa chọn hành vi động).",
      "Encapsulation.",
      "Inheritance.",
    ],
    answer: 1,
    explanation:
      "Strategy cho phép chọn hành vi/thuật toán động tại runtime [34].",
  },
  {
    id: 2782,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào yêu cầu các interface nên được chia nhỏ và tập trung vào vai trò cụ thể?",
    options: ["SRP", "OCP", "LSP", "ISP"],
    answer: 3,
    explanation: "ISP khuyến khích interface nhỏ hơn, cụ thể hơn [39].",
  },
  {
    id: 2783,
    topic: "Design Patterns",
    type: "radio",
    question: "Điều gì là ĐÚNG về instance của Singleton class?",
    options: [
      "Nó được phân bổ trên Stack memory.",
      "Nó được phân bổ trên Heap memory.",
      "Nó có thể là null nếu không được khởi tạo Lazy.",
      "Nó được tạo ra bởi constructor public.",
    ],
    answer: 1,
    explanation:
      "Tất cả các đối tượng Java đều được phân bổ động trên Heap [44].",
  },
  {
    id: 2784,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Factory Method, lớp client sử dụng tham chiếu của lớp cha (ví dụ: `Vehicle`) để làm gì?",
    options: [
      "Để gọi constructor private.",
      "Để sử dụng đa hình, gọi phương thức `create()` cụ thể của đối tượng con.",
      "Để vi phạm DIP.",
      "Để tạo ra một Abstract Factory.",
    ],
    answer: 1,
    explanation:
      "Sử dụng tham chiếu lớp cha để gọi phương thức chung (Polymorphism) [24, 45].",
  },
  {
    id: 2785,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Strategy Pattern giúp làm cho Context Class 'đóng để sửa đổi' bằng cách nào?",
    options: [
      "Context chứa logic điều kiện `if-else`.",
      "Logic mới được thêm vào thông qua các Strategy Interface mới, không cần sửa Context.",
      "Context là final class.",
      "Context là Singleton.",
    ],
    answer: 1,
    explanation: "Hỗ trợ OCP [31, 39].",
  },
  {
    id: 2786,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc nào yêu cầu Modules cấp cao không nên có sự phụ thuộc vào class cụ thể của Modules cấp thấp?",
    options: ["SRP", "OCP", "LSP", "DIP"],
    answer: 3,
    explanation: "DIP: phụ thuộc vào Abstraction [42].",
  },
  {
    id: 2787,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Mục đích của việc khai báo biến instance trong Singleton là `final` là gì?",
    options: [
      "Để cho phép nó thay đổi.",
      "Để nó không thể bị kế thừa.",
      "Để tham chiếu đến instance không thể bị gán lại.",
      "Để nó có thể được truy cập từ lớp khác.",
    ],
    answer: 2,
    explanation: "Final field là một hằng số, chỉ được thiết lập một lần [16].",
  },
  {
    id: 2788,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Abstract Factory, client sử dụng Factory để tạo ra các đối tượng nào?",
    options: [
      "Các đối tượng Strategy.",
      "Các đối tượng Abstract Product (ví dụ: `Car` và `Truck`).",
      "Các đối tượng Singleton.",
      "Các đối tượng Adapter.",
    ],
    answer: 1,
    explanation: "Client gọi phương thức tạo sản phẩm trên Factory [27, 30].",
  },
  {
    id: 2789,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Strategy Pattern được sử dụng, thì sự phụ thuộc giữa Context và Strategy là vào cái gì?",
    options: [
      "Concrete Implementation.",
      "Abstract Interface.",
      "Static Method.",
      "Final Class.",
    ],
    answer: 1,
    explanation:
      "Context phụ thuộc vào Strategy Interface (Abstraction), tuân thủ DIP [31, 42].",
  },
  {
    id: 2790,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc SRP giúp ngăn ngừa tình trạng nào trong thiết kế phần mềm?",
    options: [
      "Code quá ngắn.",
      "Thay đổi ở một phần của hệ thống gây lỗi cho các phần không liên quan.",
      "Sử dụng quá nhiều interface.",
      "Không thể kế thừa.",
    ],
    answer: 1,
    explanation:
      "Nếu chỉ có một lý do để thay đổi, phạm vi tác động của thay đổi được giới hạn [40].",
  },
  {
    id: 2791,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Việc class Singleton được khai báo là `final` giúp đảm bảo rằng class đó không thể được làm gì?",
    options: ["Sao chép (Clone).", "Khởi tạo.", "Kế thừa.", "Sử dụng đa hình."],
    answer: 2,
    explanation: "Final class: cannot be inherited [15].",
  },
  {
    id: 2792,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Abstract Factory Pattern được thiết kế để giải quyết nhu cầu tạo ra các đối tượng có quan hệ nào?",
    options: [
      "Đa hình (Polymorphism).",
      "Sản phẩm liên quan (related products).",
      "Singleton.",
      "Strategy.",
    ],
    answer: 1,
    explanation: "Abstract Factory tạo ra families of related products [26].",
  },
  {
    id: 2793,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, nếu không có interface chung, Context sẽ không thể làm gì?",
    options: [
      "Thực hiện việc tạo đối tượng.",
      "Hoán đổi các thuật toán một cách linh hoạt.",
      "Gói gọn dữ liệu.",
      "Vi phạm SRP.",
    ],
    answer: 1,
    explanation:
      "Interface chung (Strategy Interface) là cần thiết để Context có thể sử dụng bất kỳ Strategy nào [31].",
  },
  {
    id: 2794,
    topic: "SOLID Principles",
    type: "radio",
    question:
      "Nguyên tắc OCP (Open/Closed Principle) cho phép thay đổi hệ thống bằng cách nào?",
    options: [
      "Chủ yếu thông qua việc sửa đổi code đã tồn tại.",
      "Chủ yếu thông qua việc thêm code mới (mở rộng).",
      "Chủ yếu thông qua việc sử dụng Singleton.",
      "Chủ yếu thông qua việc sử dụng constructor private.",
    ],
    answer: 1,
    explanation: "Mở để mở rộng, đóng để sửa đổi [39].",
  },
  {
    id: 2795,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Vì sao việc quản lý kết nối cơ sở dữ liệu thường được thực hiện bằng Singleton?",
    options: [
      "Để làm cho việc debug dễ dàng hơn.",
      "Để ngăn chặn việc tạo ra quá nhiều kết nối lãng phí tài nguyên.",
      "Để tuân thủ LSP.",
      "Để sử dụng Factory Method.",
    ],
    answer: 1,
    explanation:
      "Ngăn chặn khởi tạo kết nối không cần thiết, tránh làm chậm hệ thống [9, 14].",
  },
  {
    id: 2796,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Nếu Abstract Factory dựa trên Object Composition, điều đó có nghĩa là bản thân Factory chứa cái gì?",
    options: [
      "Chỉ một phương thức static.",
      "Các phương thức để tạo ra nhiều sản phẩm.",
      "Constructor private.",
      "Logic điều kiện phức tạp.",
    ],
    answer: 1,
    explanation:
      "Factory chứa các phương thức để tạo ra nhiều sản phẩm (thông qua composition) [25].",
  },
  {
    id: 2797,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Trong Strategy Pattern, `Strategy Interface` là một ví dụ của cái gì trong DIP?",
    options: [
      "Low-level module.",
      "High-level module.",
      "Abstraction.",
      "Concrete class.",
    ],
    answer: 2,
    explanation: "Strategy Interface là một Abstraction [31, 42].",
  },
  {
    id: 2798,
    topic: "SOLID Principles",
    type: "radio",
    question: "Nguyên tắc SRP giúp class dễ thay đổi hơn vì nó chỉ có một gì?",
    options: [
      "Phương thức.",
      "Trách nhiệm.",
      "Interface.",
      "Constructor public.",
    ],
    answer: 1,
    explanation: "Chỉ có một trách nhiệm [40].",
  },
  {
    id: 2799,
    topic: "Design Patterns",
    type: "radio",
    question:
      "Để truy cập một Singleton, client phải gọi phương thức nào thay vì sử dụng từ khóa `new`?",
    options: ["constructor", "main()", "getInstance()", "create()"],
    answer: 2,
    explanation:
      "Client gọi `getInstance()` thay vì trực tiếp gọi constructor [14].",
  },
];
